---
plan: 09-01
phase: 09-client-portal-campaign-approval
title: "Schema Migration + Approval Operations + Content Preview Utilities"
wave: 1
depends_on: []
requirements:
  - PORTAL-02
  - PORTAL-03
  - PORTAL-04
  - PORTAL-05
  - PORTAL-06
files_modified:
  - prisma/schema.prisma
  - src/lib/campaigns/operations.ts
  - src/lib/content-preview.ts
autonomous: true
---

# Plan 09-01: Schema Migration + Approval Operations + Content Preview Utilities

## Goal

Add the `approvalsSlackChannelId` field to the Workspace model, build four approval mutation functions and a lead sample query function in the campaigns operations layer, and create the content preview utility module (spintax resolution + merge token substitution). This plan provides the data layer foundation that all other Phase 9 plans depend on.

## Context

- Campaign model already has all approval fields: `leadsApproved`, `leadsFeedback`, `leadsApprovedAt`, `contentApproved`, `contentFeedback`, `contentApprovedAt`.
- Workspace model needs `approvalsSlackChannelId String?` and `approvalsSlackChannelName String?` for the dedicated approvals Slack channel (per CONTEXT.md decision).
- `src/lib/campaigns/operations.ts` already exists with `getCampaign`, `listCampaigns`, `updateCampaignStatus`, etc. New approval functions go here.
- Content preview is needed for both the portal campaign detail page (PORTAL-04) and the email step rendering.

## must_haves

- [ ] Workspace schema has `approvalsSlackChannelId String?` and `approvalsSlackChannelName String?` fields
- [ ] `approveCampaignLeads(id)` sets `leadsApproved: true`, clears feedback, sets timestamp, and auto-transitions to `approved` if content is also approved
- [ ] `rejectCampaignLeads(id, feedback)` sets `leadsApproved: false` with feedback text
- [ ] `approveCampaignContent(id)` sets `contentApproved: true`, clears feedback, sets timestamp, and auto-transitions to `approved` if leads are also approved
- [ ] `rejectCampaignContent(id, feedback)` sets `contentApproved: false` with feedback text
- [ ] `getCampaignLeadSample(targetListId, workspaceSlug, limit?)` returns top N leads ordered by ICP score with correct workspace-specific score
- [ ] `resolveSpintax(text)` resolves `{A|B|C}` to first option, leaves single-option tokens alone
- [ ] `substituteTokens(text)` replaces `{FIRSTNAME}`, `{COMPANYNAME}`, etc. with example data
- [ ] `renderContentPreview(raw)` chains spintax then token substitution
- [ ] Prisma migration runs without errors

## Tasks

<task id="09-01-T1">
<title>Add approvalsSlackChannelId to Workspace schema and run migration</title>
<details>

**File:** `prisma/schema.prisma`

Add two optional fields to the `Workspace` model, right after the existing `notificationEmails` field:

```prisma
  approvalsSlackChannelId   String?
  approvalsSlackChannelName String?
```

Then run:
```bash
npx prisma migrate dev --name add-workspace-approvals-channel
```

Verify the migration succeeds and `npx prisma generate` completes without errors.

</details>
</task>

<task id="09-01-T2">
<title>Add approval operations and lead sample query to campaigns/operations.ts</title>
<details>

**File:** `src/lib/campaigns/operations.ts`

Add 5 new exported functions at the bottom of the file (after `saveCampaignSequences`):

### 1. `approveCampaignLeads(id: string): Promise<CampaignDetail>`

```typescript
export async function approveCampaignLeads(id: string): Promise<CampaignDetail> {
  const current = await prisma.campaign.findUnique({
    where: { id },
    select: { contentApproved: true, status: true },
  });

  if (!current) throw new Error(`Campaign not found: '${id}'`);

  const updateData: Record<string, unknown> = {
    leadsApproved: true,
    leadsApprovedAt: new Date(),
    leadsFeedback: null, // clear previous feedback on approval
  };

  // Dual approval check: if content is ALSO already approved, transition to 'approved'
  if (current.contentApproved && current.status === 'pending_approval') {
    updateData.status = 'approved';
  }

  const campaign = await prisma.campaign.update({
    where: { id },
    data: updateData,
    include: targetListInclude,
  });

  return formatCampaignDetail(campaign);
}
```

### 2. `rejectCampaignLeads(id: string, feedback: string): Promise<CampaignDetail>`

```typescript
export async function rejectCampaignLeads(id: string, feedback: string): Promise<CampaignDetail> {
  const campaign = await prisma.campaign.update({
    where: { id },
    data: {
      leadsApproved: false,
      leadsFeedback: feedback,
    },
    include: targetListInclude,
  });
  return formatCampaignDetail(campaign);
}
```

### 3. `approveCampaignContent(id: string): Promise<CampaignDetail>`

Same pattern as `approveCampaignLeads` but for content fields:

```typescript
export async function approveCampaignContent(id: string): Promise<CampaignDetail> {
  const current = await prisma.campaign.findUnique({
    where: { id },
    select: { leadsApproved: true, status: true },
  });

  if (!current) throw new Error(`Campaign not found: '${id}'`);

  const updateData: Record<string, unknown> = {
    contentApproved: true,
    contentApprovedAt: new Date(),
    contentFeedback: null,
  };

  if (current.leadsApproved && current.status === 'pending_approval') {
    updateData.status = 'approved';
  }

  const campaign = await prisma.campaign.update({
    where: { id },
    data: updateData,
    include: targetListInclude,
  });

  return formatCampaignDetail(campaign);
}
```

### 4. `rejectCampaignContent(id: string, feedback: string): Promise<CampaignDetail>`

```typescript
export async function rejectCampaignContent(id: string, feedback: string): Promise<CampaignDetail> {
  const campaign = await prisma.campaign.update({
    where: { id },
    data: {
      contentApproved: false,
      contentFeedback: feedback,
    },
    include: targetListInclude,
  });
  return formatCampaignDetail(campaign);
}
```

### 5. `getCampaignLeadSample(targetListId, workspaceSlug, limit?)`

Add a new exported interface and function:

```typescript
export interface LeadSample {
  personId: string;
  firstName: string | null;
  lastName: string | null;
  jobTitle: string | null;
  company: string | null;
  location: string | null;
  linkedinUrl: string | null;
  icpScore: number | null;
}

export async function getCampaignLeadSample(
  targetListId: string,
  workspaceSlug: string,
  limit = 50,
): Promise<{ leads: LeadSample[]; totalCount: number }> {
  const [members, totalCount] = await Promise.all([
    prisma.targetListPerson.findMany({
      where: { listId: targetListId },
      include: {
        person: {
          include: {
            workspaces: {
              where: { workspace: workspaceSlug },
              select: { icpScore: true },
            },
          },
        },
      },
    }),
    prisma.targetListPerson.count({ where: { listId: targetListId } }),
  ]);

  const leads = members
    .map((m) => ({
      personId: m.person.id,
      firstName: m.person.firstName,
      lastName: m.person.lastName,
      jobTitle: m.person.jobTitle,
      company: m.person.company,
      location: m.person.location,
      linkedinUrl: m.person.linkedinUrl,
      icpScore: m.person.workspaces[0]?.icpScore ?? null,
    }))
    .sort((a, b) => (b.icpScore ?? -1) - (a.icpScore ?? -1))
    .slice(0, limit);

  return { leads, totalCount };
}
```

**Key details:**
- ICP score lives on `PersonWorkspace`, filtered by `workspace === workspaceSlug` to avoid cross-workspace score leakage.
- `totalCount` returned alongside the 50-row sample for UI display ("Showing top 50 of N leads").
- `Person` model fields to check: `firstName`, `lastName`, `jobTitle`, `company`, `location`, `linkedinUrl` (check the schema for exact field names â€” the Person model maps to the "Lead" table via `@@map`).
- The approval functions clear previous feedback when approving (set to null) since approval replaces a rejection.

</details>
</task>

<task id="09-01-T3">
<title>Create content-preview.ts with spintax resolution and merge token substitution</title>
<details>

**File:** `src/lib/content-preview.ts` (NEW)

Create this file with three exported functions:

```typescript
/**
 * Content preview utilities for resolving spintax and merge tokens.
 *
 * Pipeline: raw text -> resolveSpintax() -> substituteTokens() -> rendered preview
 * Always resolve spintax FIRST, then substitute tokens.
 */

const EXAMPLE_DATA: Record<string, string> = {
  FIRSTNAME: "Alex",
  LASTNAME: "Smith",
  COMPANYNAME: "Acme Corp",
  COMPANY: "Acme Corp",
  JOBTITLE: "Head of Operations",
  WEBSITE: "acmecorp.com",
  TITLE: "Head of Operations",
  LOCATION: "London, UK",
};

/**
 * Resolve spintax: {A|B|C} -> A (always picks first variant for consistent preview).
 * Single-option tokens like {FIRSTNAME} are left alone for substituteTokens.
 */
export function resolveSpintax(text: string): string {
  return text.replace(/\{([^{}]+)\}/g, (match, inner: string) => {
    const options = inner.split("|");
    if (options.length === 1) return match; // merge token, not spintax
    return options[0].trim();
  });
}

/**
 * Substitute merge tokens with example data.
 * Returns both the substituted text and a list of token names found (for highlighting in UI).
 */
export function substituteTokens(text: string): {
  result: string;
  tokensFound: string[];
} {
  const tokensFound: string[] = [];
  const result = text.replace(/\{([A-Z_]+)\}/g, (match, token: string) => {
    if (EXAMPLE_DATA[token]) {
      tokensFound.push(token);
      return EXAMPLE_DATA[token];
    }
    return match; // unknown token, leave as-is
  });
  return { result, tokensFound };
}

/**
 * Full preview pipeline: spintax first, then tokens.
 */
export function renderContentPreview(raw: string): string {
  const afterSpintax = resolveSpintax(raw);
  const { result } = substituteTokens(afterSpintax);
  return result;
}
```

</details>
</task>

## Verification

```bash
# 1. Migration applied
npx prisma migrate status

# 2. Prisma client regenerated
npx prisma generate

# 3. TypeScript compiles
npx tsc --noEmit --pretty 2>&1 | head -30

# 4. Verify new fields exist in generated client
grep -r "approvalsSlackChannelId" node_modules/.prisma/client/index.d.ts | head -3

# 5. Verify operations exports
grep "export async function" src/lib/campaigns/operations.ts

# 6. Verify content-preview exports
grep "export function" src/lib/content-preview.ts
```
