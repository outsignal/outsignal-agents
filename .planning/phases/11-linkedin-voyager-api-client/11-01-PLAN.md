---
phase: 11-linkedin-voyager-api-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/package.json
  - worker/src/voyager-client.ts
autonomous: true
requirements:
  - VOYAGER-01
  - VOYAGER-02
  - VOYAGER-03
  - VOYAGER-04

must_haves:
  truths:
    - "VoyagerClient can send connection requests via Voyager API HTTP call"
    - "VoyagerClient can send messages to connected profiles via Voyager API"
    - "VoyagerClient can view profiles and extract memberUrn from response"
    - "VoyagerClient can check connection status via Voyager API"
    - "All requests include correct headers (csrf-token, x-restli-protocol-version, User-Agent, Cookie)"
    - "All requests route through SOCKS5 proxy when proxyUrl is configured"
    - "Error responses (429, 403, 401, 999, checkpoint redirect) are handled with typed results"
  artifacts:
    - path: "worker/src/voyager-client.ts"
      provides: "VoyagerClient class with all LinkedIn action methods"
      exports: ["VoyagerClient", "VoyagerError", "ActionResult"]
      min_lines: 150
    - path: "worker/package.json"
      provides: "socks-proxy-agent dependency"
      contains: "socks-proxy-agent"
  key_links:
    - from: "worker/src/voyager-client.ts"
      to: "socks-proxy-agent"
      via: "npm dependency import"
      pattern: "import.*SocksProxyAgent.*from.*socks-proxy-agent"
---

<objective>
Create the VoyagerClient class that wraps all LinkedIn Voyager API calls with proper authentication, proxy routing, and error handling.

Purpose: Replace browser automation with direct HTTP requests to LinkedIn's internal Voyager API. HTTP requests with proper cookies look like legitimate browser traffic, unlike headless Chromium which is detectable by LinkedIn's fingerprinting.

Output: `worker/src/voyager-client.ts` — a drop-in replacement execution engine for `LinkedInBrowser` that worker.ts will call in Plan 03.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/11-linkedin-voyager-api-client/11-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From worker/src/linkedin-browser.ts (interface VoyagerClient must match):
```typescript
export interface ActionResult {
  success: boolean;
  error?: string;
  details?: Record<string, unknown>;
}

export type ConnectionStatus =
  | "connected"
  | "pending"
  | "not_connected"
  | "not_connectable"
  | "unknown";
```

From worker/src/worker.ts (the consumer of VoyagerClient):
```typescript
interface ActionItem {
  id: string;
  personId: string;
  actionType: "connect" | "message" | "profile_view" | "check_connection";
  messageBody: string | null;
  priority: number;
  linkedinUrl: string | null;
}
```

From src/lib/linkedin/types.ts (shared type definitions):
```typescript
export type LinkedInActionType = "connect" | "message" | "profile_view" | "check_connection";
export type SenderHealthStatus = "healthy" | "warning" | "paused" | "blocked" | "session_expired";
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install socks-proxy-agent dependency</name>
  <files>worker/package.json</files>
  <action>
  Run `cd /Users/jjay/programs/outsignal-agents/worker && npm install socks-proxy-agent` to add the SOCKS5 proxy routing package.

  This is the only new dependency needed. `undici` ships with Node.js 18+ (built-in). Do NOT install `got`, `axios`, or `node-fetch` — use Node.js native `fetch` (backed by undici).
  </action>
  <verify>grep "socks-proxy-agent" worker/package.json returns a match</verify>
  <done>socks-proxy-agent appears in worker/package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create VoyagerClient class</name>
  <files>worker/src/voyager-client.ts</files>
  <action>
  Create `worker/src/voyager-client.ts` with the `VoyagerClient` class. This is the core execution engine that replaces `LinkedInBrowser` for all LinkedIn actions.

  **Class structure:**

  1. **VoyagerError** — Custom error class with `status: number` and `body: string` fields. Thrown on non-2xx Voyager API responses.

  2. **ActionResult** — Re-export the same interface from linkedin-browser.ts: `{ success: boolean; error?: string; details?: Record<string, unknown> }`. Keep the same shape so worker.ts can swap without changes to result handling.

  3. **ConnectionStatus** — Type alias: `"connected" | "pending" | "not_connected" | "not_connectable" | "unknown"`.

  4. **VoyagerClient constructor** — Accepts `(liAt: string, jsessionId: string, proxyUrl?: string)`.
     - Store `liAt` and `jsessionId` (strip quotes from jsessionId for CSRF token).
     - If `proxyUrl` is provided, create a `SocksProxyAgent` instance and store it. Create the agent ONCE in the constructor, reuse for all requests (do NOT re-create per request).
     - CSRF token derivation: `jsessionId.replace(/"/g, '')` — this is HIGH confidence from research. Do NOT over-engineer.

  5. **Private `request(path, options)` method** — Core HTTP caller.
     - Base URL: `https://www.linkedin.com/voyager/api`
     - Headers (all required):
       ```
       User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
       Accept: application/vnd.linkedin.normalized+json+2.1
       Accept-Language: en-US,en;q=0.9
       csrf-token: {csrfToken}
       x-restli-protocol-version: 2.0.0
       x-li-lang: en_US
       Cookie: li_at={liAt}; JSESSIONID="{jsessionId}"
       ```
     - Use Node.js native `fetch()` (NOT `import { fetch } from 'undici'` — use global fetch which is available in Node 18+).
     - For proxy: pass `{ dispatcher: this.proxyAgent }` in fetch options. TypeScript may complain about the type — cast with `as any` since SocksProxyAgent implements the Dispatcher interface but types don't align perfectly.
     - **CRITICAL: undici uses `dispatcher` NOT `agent`**. Using `{ agent: socksAgent }` silently does nothing — requests go direct without proxy.
     - Check response for redirect to `/checkpoint/` or `/challenge/` in `response.url` — return `{ success: false, error: 'checkpoint_detected' }` pattern.
     - On non-2xx: throw `VoyagerError(status, body)`.

  6. **`viewProfile(profileUrl: string): Promise<ActionResult>`** — Extract profileId slug from URL (e.g., `april-newman-27713482` from `https://www.linkedin.com/in/april-newman-27713482`). GET `/identity/profiles/{profileId}/profileView`. On success, extract `entityUrn` from response JSON (format: `urn:li:fsd_profile:ACoAAA...`) and return it in `details.memberUrn` (strip the `urn:li:fsd_profile:` prefix, return just the `ACoAAA...` part). This URN is needed by connect and message methods.

  7. **`sendConnectionRequest(profileUrl: string, note?: string): Promise<ActionResult>`** — First call `viewProfile()` to extract `memberUrn`. Then POST to `/growth/normInvitations` with body:
     ```json
     {
       "inviteeUrn": "urn:li:fsd_profile:{memberUrn}",
       "invitationType": "CONNECTION",
       "trackingId": "{random-base64-16-chars}"
     }
     ```
     Add `"message": note` only if `note` is provided (omit key entirely if no note). Generate trackingId: `Buffer.from(Math.random().toString()).toString('base64').slice(0, 16)`.
     Include `Referer: https://www.linkedin.com/in/{profileId}/` header on this request (reduces detection risk per research).

  8. **`sendMessage(profileUrl: string, message: string): Promise<ActionResult>`** — First call `viewProfile()` to extract `memberUrn`. Then POST to `/messaging/conversations` with body:
     ```json
     {
       "recipients": ["urn:li:fsd_profile:{memberUrn}"],
       "subject": "",
       "body": "{message}",
       "messageType": "MEMBER_TO_MEMBER"
     }
     ```
     This only works for 1st-degree connections (not InMail). Return `{ success: false, error: 'not_connected' }` if the API returns 403 on messaging.

  9. **`checkConnectionStatus(profileUrl: string): Promise<ConnectionStatus>`** — Extract profileId from URL. GET `/identity/profiles/{profileId}/relationships`. Parse response for `memberRelationship.distanceOfConnection`:
     - `DISTANCE_1` → `"connected"`
     - `DISTANCE_2` or `DISTANCE_3` → check for `invitation` field presence → `"pending"` if exists, `"not_connected"` if not
     - Any other/error → `"unknown"`

  10. **Error handling in each method** — Wrap in try/catch for VoyagerError:
      - `status === 429` → `{ success: false, error: 'rate_limited', details: { retry: true } }`
      - `status === 403` → `{ success: false, error: 'auth_expired', details: { retry: false } }`
      - `status === 401` → `{ success: false, error: 'unauthorized', details: { retry: false } }`
      - `status === 999` → `{ success: false, error: 'ip_blocked', details: { retry: false } }`
      - Checkpoint redirect detected → `{ success: false, error: 'checkpoint_detected', details: { retry: false } }`
      - Any other error → `{ success: false, error: String(err) }`

  **Important anti-patterns to AVOID:**
  - Do NOT import from `undici` explicitly — use global `fetch` (Node 18+)
  - Do NOT share VoyagerClient instances across senders — each sender gets its own
  - Do NOT cache JSESSIONID too long — it rotates frequently
  - Do NOT use `{ agent: proxyAgent }` — undici uses `dispatcher`
  - Do NOT add `x-li-track` header in this first implementation (optional optimization for later)
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/voyager-client.ts</verify>
  <done>VoyagerClient class compiles without errors, exports VoyagerClient, VoyagerError, ActionResult, and ConnectionStatus. Has methods: viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus. All requests include CSRF token, cookie header, User-Agent, and proxy routing.</done>
</task>

</tasks>

<verification>
- `worker/package.json` includes `socks-proxy-agent` in dependencies
- `worker/src/voyager-client.ts` exists and compiles: `cd worker && npx tsc --noEmit src/voyager-client.ts`
- VoyagerClient constructor accepts `(liAt, jsessionId, proxyUrl?)`
- CSRF token derived correctly: `jsessionId.replace(/"/g, '')`
- All 4 action methods exist: viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus
- Error handling covers 429, 403, 401, 999, and checkpoint redirects
- SocksProxyAgent used with `dispatcher` (not `agent`)
</verification>

<success_criteria>
VoyagerClient class exists in worker/src/voyager-client.ts with all four LinkedIn action methods (viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus), proper cookie-based authentication with CSRF token derivation, SOCKS5 proxy routing via socks-proxy-agent, and comprehensive error handling for LinkedIn-specific HTTP status codes.
</success_criteria>

<output>
After completion, create `.planning/phases/11-linkedin-voyager-api-client/11-01-SUMMARY.md`
</output>
