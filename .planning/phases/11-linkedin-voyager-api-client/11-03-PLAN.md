---
phase: 11-linkedin-voyager-api-client
plan: 03
type: execute
wave: 2
depends_on:
  - "11-01"
  - "11-02"
files_modified:
  - worker/src/worker.ts
autonomous: true
requirements:
  - VOYAGER-01
  - VOYAGER-04

must_haves:
  truths:
    - "Worker uses VoyagerClient for all LinkedIn action execution (connect, message, profile_view, check_connection)"
    - "Worker falls back to LinkedInBrowser only for login and cookie extraction"
    - "Worker loads Voyager cookies from API and creates VoyagerClient per sender"
    - "Worker detects auth_expired and checkpoint_detected errors and explicitly calls updateSenderHealth() to set sender healthStatus"
    - "Worker persists freshly extracted cookies after login via saveVoyagerCookies()"
  artifacts:
    - path: "worker/src/worker.ts"
      provides: "Updated worker using VoyagerClient for action execution"
      contains: "VoyagerClient"
      min_lines: 200
  key_links:
    - from: "worker/src/worker.ts"
      to: "worker/src/voyager-client.ts"
      via: "import and instantiation"
      pattern: "import.*VoyagerClient.*from.*voyager-client"
    - from: "worker/src/worker.ts"
      to: "worker/src/api-client.ts"
      via: "getVoyagerCookies and saveVoyagerCookies calls"
      pattern: "getVoyagerCookies|saveVoyagerCookies"
    - from: "worker/src/worker.ts"
      to: "worker/src/linkedin-browser.ts"
      via: "cookie extraction only (demoted from action execution)"
      pattern: "extractVoyagerCookies"
    - from: "worker/src/worker.ts"
      to: "worker/src/api-client.ts"
      via: "updateSenderHealth calls for ip_blocked/checkpoint_detected"
      pattern: "updateSenderHealth"
---

<objective>
Update worker.ts to use VoyagerClient for all LinkedIn action execution, demoting LinkedInBrowser to cookie-capture-only. This is the integration plan that wires everything together.

Purpose: Complete the swap from browser automation to HTTP-based Voyager API calls. The worker loop, scheduling, and action reporting stay the same — only the execution engine changes.

Output: Updated `worker/src/worker.ts` that creates `VoyagerClient` per sender (using stored cookies) and executes all actions via HTTP.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/11-linkedin-voyager-api-client/11-RESEARCH.md
@.planning/phases/11-linkedin-voyager-api-client/11-01-SUMMARY.md
@.planning/phases/11-linkedin-voyager-api-client/11-02-SUMMARY.md
@worker/src/worker.ts
@worker/src/voyager-client.ts
@worker/src/api-client.ts
@worker/src/linkedin-browser.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From worker/src/voyager-client.ts (Plan 01 output):
```typescript
export class VoyagerClient {
  constructor(liAt: string, jsessionId: string, proxyUrl?: string);
  async viewProfile(profileUrl: string): Promise<ActionResult>;
  async sendConnectionRequest(profileUrl: string, note?: string): Promise<ActionResult>;
  async sendMessage(profileUrl: string, message: string): Promise<ActionResult>;
  async checkConnectionStatus(profileUrl: string): Promise<ConnectionStatus>;
}

export interface ActionResult {
  success: boolean;
  error?: string;
  details?: Record<string, unknown>;
}
```

From worker/src/linkedin-browser.ts (Plan 02 output):
```typescript
export class LinkedInBrowser {
  voyagerCookies: { liAt: string; jsessionId: string } | null;
  async extractVoyagerCookies(): Promise<{ liAt: string; jsessionId: string } | null>;
  // ... existing methods (launch, login, close, etc.)
}
```

From worker/src/api-client.ts (Plan 02 output):
```typescript
export class ApiClient {
  async saveVoyagerCookies(senderId: string, cookies: { liAt: string; jsessionId: string }): Promise<void>;
  async getVoyagerCookies(senderId: string): Promise<{ liAt: string; jsessionId: string } | null>;
  async updateSenderHealth(senderId: string, healthStatus: string): Promise<void>;
  // ... existing methods
}
```

From worker/src/worker.ts (current structure):
```typescript
export class Worker {
  private activeBrowsers: Map<string, LinkedInBrowser>;  // Will become activeClients
  private async getOrLaunchBrowser(sender: SenderConfig): Promise<LinkedInBrowser>;  // Will become getOrCreateClient
  private async executeAction(browser: LinkedInBrowser, action: ActionItem): Promise<void>;  // Will use VoyagerClient
  private async processSender(sender: SenderConfig): Promise<void>;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace LinkedInBrowser with VoyagerClient in worker.ts</name>
  <files>worker/src/worker.ts</files>
  <action>
  Update `worker/src/worker.ts` to use `VoyagerClient` for action execution while keeping `LinkedInBrowser` available for cookie capture on session expiry.

  **Changes to make:**

  1. **Update imports:**
     - Add: `import { VoyagerClient } from "./voyager-client.js";`
     - Add: `import type { ActionResult } from "./voyager-client.js";`
     - Keep: `import { LinkedInBrowser } from "./linkedin-browser.js";` (still needed for cookie capture)
     - Remove: `import type { ActionResult } from "./linkedin-browser.js";` (now from voyager-client)

  2. **Replace `activeBrowsers` map with `activeClients` map:**
     - Change: `private activeBrowsers: Map<string, LinkedInBrowser> = new Map();` → `private activeClients: Map<string, VoyagerClient> = new Map();`
     - This map holds VoyagerClient instances per sender (one per sender, reused within a tick).

  3. **Replace `getOrLaunchBrowser()` with `getOrCreateVoyagerClient(sender)`:**
     ```typescript
     private async getOrCreateVoyagerClient(sender: SenderConfig): Promise<VoyagerClient> {
       // Reuse existing client if available
       const existing = this.activeClients.get(sender.id);
       if (existing) return existing;

       // Try to load stored Voyager cookies
       let cookies = await this.api.getVoyagerCookies(sender.id);

       if (!cookies) {
         // No stored cookies — need to login via browser and extract
         console.log(`[Worker] No Voyager cookies for ${sender.name} — launching browser for login`);
         cookies = await this.loginAndExtractCookies(sender);
         if (!cookies) {
           throw new Error('Failed to obtain Voyager cookies via browser login');
         }
       }

       const client = new VoyagerClient(cookies.liAt, cookies.jsessionId, sender.proxyUrl ?? undefined);
       this.activeClients.set(sender.id, client);
       return client;
     }
     ```

  4. **Add `loginAndExtractCookies()` private method:**
     ```typescript
     private async loginAndExtractCookies(
       sender: SenderConfig,
     ): Promise<{ liAt: string; jsessionId: string } | null> {
       const browser = new LinkedInBrowser([], sender.proxyUrl ?? undefined);
       browser.setSenderId(sender.id);

       try {
         const launchResult = await browser.launch();

         if (launchResult.needsLogin) {
           const credentials = await this.api.getSenderCredentials(sender.id);
           if (!credentials) {
             console.error(`[Worker] No credentials for ${sender.name} — cannot login`);
             return null;
           }

           const loginSuccess = await browser.login(
             credentials.email,
             credentials.password,
             credentials.totpSecret,
             { daemonAlreadyRunning: true },
           );

           if (!loginSuccess) {
             console.error(`[Worker] Login failed for ${sender.name}`);
             return null;
           }
         }

         // Extract Voyager cookies from the browser session
         const cookies = await browser.extractVoyagerCookies();
         if (cookies) {
           // Persist cookies to API for future use
           await this.api.saveVoyagerCookies(sender.id, cookies);
           console.log(`[Worker] Voyager cookies extracted and saved for ${sender.name}`);
         }

         return cookies;
       } finally {
         await browser.close();
       }
     }
     ```

  5. **Update `executeAction()` to use VoyagerClient:**
     Change signature from `(browser: LinkedInBrowser, action: ActionItem)` to `(client: VoyagerClient, action: ActionItem)`:
     ```typescript
     private async executeAction(client: VoyagerClient, action: ActionItem): Promise<void> {
       let result: ActionResult;

       if (!action.linkedinUrl) {
         await this.safeMarkFailed(action.id, "No LinkedIn URL for person");
         return;
       }

       const profileUrl = action.linkedinUrl;

       try {
         switch (action.actionType) {
           case "profile_view":
             result = await client.viewProfile(profileUrl);
             break;

           case "connect":
             result = await client.sendConnectionRequest(profileUrl);
             break;

           case "message":
             if (!action.messageBody) {
               result = { success: false, error: "No message body provided" };
               break;
             }
             result = await client.sendMessage(profileUrl, action.messageBody);
             break;

           case "check_connection": {
             const status = await client.checkConnectionStatus(profileUrl);
             result = {
               success: true,
               details: { connectionStatus: status },
             };
             break;
           }

           default:
             result = { success: false, error: `Unknown action type: ${action.actionType}` };
         }
       } catch (error) {
         result = { success: false, error: String(error) };
       }

       // Report result back to API
       if (result.success) {
         console.log(`[Worker] Action ${action.id} completed successfully`);
         await this.safeMarkComplete(action.id, result.details);
       } else {
         console.error(`[Worker] Action ${action.id} failed: ${result.error}`);
         await this.safeMarkFailed(action.id, result.error ?? "Unknown error");

         // Handle auth/blocking errors — invalidate cached client and update sender health
         // IMPORTANT: markFailed() only updates LinkedInAction.status — it does NOT update
         // Sender.healthStatus. We must call updateSenderHealth() explicitly.
         if (result.error === 'auth_expired' || result.error === 'unauthorized') {
           console.warn(`[Worker] Auth expired for sender ${senderId} — removing cached client`);
           this.activeClients.delete(senderId); // Will re-create with fresh cookies next tick
           await this.api.updateSenderHealth(senderId, 'session_expired').catch(err =>
             console.error(`[Worker] Failed to update sender health:`, err)
           );
         }
         if (result.error === 'ip_blocked') {
           console.error(`[Worker] Sender ${senderId} IP blocked — updating health to blocked`);
           this.activeClients.delete(senderId);
           await this.api.updateSenderHealth(senderId, 'blocked').catch(err =>
             console.error(`[Worker] Failed to update sender health:`, err)
           );
         }
         if (result.error === 'checkpoint_detected') {
           console.error(`[Worker] Sender ${senderId} checkpoint detected — updating health to blocked`);
           this.activeClients.delete(senderId);
           await this.api.updateSenderHealth(senderId, 'blocked').catch(err =>
             console.error(`[Worker] Failed to update sender health:`, err)
           );
         }
       }
     }
     ```

  6. **Update `processSender()`:**
     - Replace `browser = await this.getOrLaunchBrowser(sender)` → `client = await this.getOrCreateVoyagerClient(sender)`
     - Replace `await this.executeAction(browser, action)` → `await this.executeAction(client, action)`
     - Remove the CAPTCHA and restriction browser health checks (these are browser-specific; VoyagerClient handles errors in the response codes instead):
       ```typescript
       // REMOVE this block — VoyagerClient handles errors via HTTP status codes:
       // try {
       //   if (await browser.checkForCaptcha()) { ... }
       //   if (await browser.checkForRestriction()) { ... }
       // }
       ```
     - In the catch block for `getOrCreateVoyagerClient`, keep the pattern of marking all actions as failed.

  7. **Update `stop()`:**
     - Replace browser cleanup with client cleanup. VoyagerClient has no close method (it's just HTTP), so just clear the map:
       ```typescript
       async stop(): Promise<void> {
         console.log("[Worker] Stopping...");
         this.running = false;
         this.activeClients.clear();
       }
       ```

  8. **Fix `auth_expired` handler in executeAction:**
     The `this.activeClients.delete(action.id)` should be `this.activeClients.delete(senderId)` — but we don't have senderId in executeAction's scope. Instead, extract the sender ID from the client cache by finding which sender maps to this client, OR pass senderId as an additional parameter to executeAction. **Preferred approach:** Change executeAction signature to `(client: VoyagerClient, action: ActionItem, senderId: string)` and pass `sender.id` from processSender.

  **What NOT to change:**
  - The tick() method stays the same (business hours check, workspace iteration)
  - The processWorkspace() method stays the same (sender filtering)
  - The poll delay and action delay logic stays the same
  - safeMarkComplete and safeMarkFailed stay the same
  - The closeBrowser() private method can be removed entirely (or left as dead code — prefer removing)
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/worker.ts</verify>
  <done>Worker uses VoyagerClient for all action execution. LinkedInBrowser is only used for login + cookie extraction (via loginAndExtractCookies). Worker creates VoyagerClient per sender using stored cookies, falls back to browser login when no cookies available. Auth/blocking errors handled by invalidating cached clients.</done>
</task>

<task type="auto">
  <name>Task 2: Clean up unused browser imports and verify full compilation</name>
  <files>worker/src/worker.ts</files>
  <action>
  After Task 1, verify the full worker compiles and clean up any remaining dead code:

  1. Remove unused imports from linkedin-browser.ts:
     - `ActionResult` should now come from voyager-client.ts
     - Keep `LinkedInBrowser` import (still used for loginAndExtractCookies)

  2. Remove the `closeBrowser()` private method if it exists (no longer needed since VoyagerClient is stateless HTTP).

  3. Remove `activeBrowsers` field if it still exists (replaced by `activeClients`).

  4. Verify the full worker compilation including all imports:
     ```bash
     cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit
     ```
     This compiles ALL worker files together, catching cross-file type issues.

  5. Verify the import chain is clean:
     - worker.ts imports from voyager-client.ts, linkedin-browser.ts, api-client.ts, scheduler.ts
     - voyager-client.ts imports from socks-proxy-agent
     - linkedin-browser.ts imports from child_process
     - api-client.ts has no new imports

  If there are type errors, fix them. Common issues:
  - ActionResult import collision between voyager-client and linkedin-browser — use only the one from voyager-client
  - ConnectionStatus type may differ between the two files — VoyagerClient's version should be canonical
  - SocksProxyAgent type casting may need `as any` for dispatcher
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit</verify>
  <done>Full worker project compiles without errors. No dead code remains. Import chain is clean: worker.ts → voyager-client.ts (action execution), linkedin-browser.ts (cookie capture only), api-client.ts (cookie persistence), scheduler.ts (timing).</done>
</task>

</tasks>

<verification>
- Full worker compilation passes: `cd worker && npx tsc --noEmit`
- worker.ts imports VoyagerClient from voyager-client.ts
- worker.ts creates VoyagerClient per sender with stored cookies
- worker.ts falls back to LinkedInBrowser for login + cookie extraction when no cookies exist
- executeAction uses VoyagerClient methods (viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus)
- Auth expired errors call `updateSenderHealth(senderId, 'session_expired')` AND invalidate cached VoyagerClient
- ip_blocked and checkpoint_detected errors call `updateSenderHealth(senderId, 'blocked')` AND invalidate cached VoyagerClient
- updateSenderHealth calls are wrapped in .catch() so they don't break the action processing flow
- No browser health checks (CAPTCHA, restriction) — replaced by HTTP error handling
- stop() clears activeClients map
</verification>

<success_criteria>
Worker executes all LinkedIn actions via VoyagerClient HTTP calls. LinkedInBrowser is only launched when cookies are missing and a browser login is needed to extract fresh ones. Full worker project compiles without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/11-linkedin-voyager-api-client/11-03-SUMMARY.md`
</output>
