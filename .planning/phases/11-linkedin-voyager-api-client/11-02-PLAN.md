---
phase: 11-linkedin-voyager-api-client
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/src/linkedin-browser.ts
  - worker/src/api-client.ts
  - src/app/api/linkedin/senders/[id]/cookies/route.ts
  - src/app/api/linkedin/senders/[id]/health/route.ts
autonomous: true
requirements:
  - VOYAGER-05
  - VOYAGER-04

must_haves:
  truths:
    - "LinkedInBrowser can extract li_at and JSESSIONID cookies after successful login"
    - "Extracted cookies can be persisted to the API via api-client.ts"
    - "ApiClient can load Voyager cookies (li_at + JSESSIONID) from the API for a sender"
    - "ApiClient can update sender healthStatus via updateSenderHealth()"
    - "GET /api/linkedin/senders/{id}/cookies returns decrypted cookies (following credentials endpoint pattern)"
    - "PATCH /api/linkedin/senders/{id}/health updates Sender.healthStatus"
  artifacts:
    - path: "worker/src/linkedin-browser.ts"
      provides: "extractVoyagerCookies() method on LinkedInBrowser"
      contains: "extractVoyagerCookies"
    - path: "worker/src/api-client.ts"
      provides: "saveVoyagerCookies(), getVoyagerCookies(), and updateSenderHealth() methods on ApiClient"
      contains: "saveVoyagerCookies"
    - path: "src/app/api/linkedin/senders/[id]/cookies/route.ts"
      provides: "GET endpoint returning decrypted Voyager cookies"
      contains: "decrypt"
    - path: "src/app/api/linkedin/senders/[id]/health/route.ts"
      provides: "PATCH endpoint updating Sender.healthStatus"
      contains: "healthStatus"
  key_links:
    - from: "worker/src/linkedin-browser.ts"
      to: "worker/src/api-client.ts"
      via: "cookie extraction feeds into cookie persistence"
      pattern: "extractVoyagerCookies|saveVoyagerCookies"
    - from: "worker/src/api-client.ts"
      to: "/api/linkedin/senders/{id}/session"
      via: "HTTP POST to persist cookies"
      pattern: "senders.*session"
    - from: "worker/src/api-client.ts"
      to: "/api/linkedin/senders/{id}/cookies"
      via: "HTTP GET to load decrypted cookies"
      pattern: "senders.*cookies"
    - from: "worker/src/api-client.ts"
      to: "/api/linkedin/senders/{id}/health"
      via: "HTTP PATCH to update sender health status"
      pattern: "senders.*health"
---

<objective>
Add Voyager cookie extraction to LinkedInBrowser, cookie persistence methods to ApiClient, and the required API endpoints for cookie retrieval and sender health updates.

Purpose: The VoyagerClient (Plan 01) needs li_at + JSESSIONID cookies to authenticate. These cookies come from agent-browser's login flow. This plan adds the extraction bridge, persistence layer, AND the server-side API endpoints needed by the worker. It also adds the health status update mechanism that Plan 03 needs for handling ip_blocked and checkpoint_detected errors.

Output: LinkedInBrowser gains `extractVoyagerCookies()` method; ApiClient gains `saveVoyagerCookies()`, `getVoyagerCookies()`, and `updateSenderHealth()` methods; two new API endpoints created.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/11-linkedin-voyager-api-client/11-RESEARCH.md
@worker/src/linkedin-browser.ts
@worker/src/api-client.ts
@src/app/api/linkedin/senders/[id]/credentials/route.ts
@src/app/api/linkedin/senders/[id]/session/route.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From worker/src/linkedin-browser.ts (existing class to extend):
```typescript
export class LinkedInBrowser {
  private session: string;
  private proxyUrl: string | undefined;
  private launched: boolean;
  // ... existing methods: launch, login, close, viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus, checkForCaptcha, checkForRestriction

  // Uses execFileSync to run agent-browser CLI commands
  private exec(args: string): string;
}
```

From worker/src/api-client.ts (existing class to extend):
```typescript
export class ApiClient {
  // Existing method — saves raw cookies array:
  async updateSession(senderId: string, cookies: unknown[]): Promise<void>;

  // Existing method — gets credentials for auto-login:
  async getSenderCredentials(senderId: string): Promise<{...} | null>;
}
```

Sender.sessionData field stores AES-256-GCM encrypted JSON via the API.
The API endpoint POST /api/linkedin/senders/{id}/session accepts and encrypts cookie data.

**IMPORTANT:** The existing GET `/api/linkedin/senders/{id}/session` does NOT return sessionData — it only returns `{ sessionStatus, healthStatus, lastActiveAt }` for dashboard polling. The worker needs a separate endpoint to retrieve decrypted cookies.

From src/app/api/linkedin/senders/[id]/credentials/route.ts (pattern to follow for cookies endpoint):
```typescript
// Worker-only GET endpoint that:
// 1. Checks verifyWorkerAuth()
// 2. Reads encrypted field from Sender
// 3. Decrypts with decrypt() from @/lib/crypto
// 4. Returns decrypted data as JSON
```

From src/lib/linkedin/types.ts (health status values):
```typescript
export type SenderHealthStatus = "healthy" | "warning" | "paused" | "blocked" | "session_expired";
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extractVoyagerCookies() to LinkedInBrowser</name>
  <files>worker/src/linkedin-browser.ts</files>
  <action>
  Add a new public method `extractVoyagerCookies()` to the `LinkedInBrowser` class that extracts `li_at` and `JSESSIONID` cookies from the agent-browser session after a successful login.

  **Method signature:**
  ```typescript
  async extractVoyagerCookies(): Promise<{ liAt: string; jsessionId: string } | null>
  ```

  **Implementation approach:**
  The agent-browser uses CDP (Chrome DevTools Protocol) under the hood. Use the `eval` command to execute JavaScript in the browser context and extract cookies from `document.cookie`.

  ```typescript
  async extractVoyagerCookies(): Promise<{ liAt: string; jsessionId: string } | null> {
    try {
      // Navigate to LinkedIn to ensure we're on the right domain
      // (cookies are domain-scoped)
      const result = this.exec(
        'eval "(() => { const c = {}; document.cookie.split(\\";\\").forEach(p => { const [k,...v] = p.trim().split(\\"=\\"); c[k] = v.join(\\"=\\"); }); return JSON.stringify({ li_at: c.li_at || null, JSESSIONID: c.JSESSIONID || null }); })()"'
      );

      const parsed = JSON.parse(result.trim());
      if (!parsed.li_at || !parsed.JSESSIONID) {
        // li_at may be HttpOnly — try CDP Network.getAllCookies as fallback
        return this.extractCookiesViaCDP();
      }
      return { liAt: parsed.li_at, jsessionId: parsed.JSESSIONID };
    } catch (err) {
      console.error('[LinkedInBrowser] Cookie extraction failed:', err);
      return null;
    }
  }
  ```

  **CDP fallback** — If `document.cookie` doesn't include `li_at` (it may be HttpOnly), add a fallback method:
  ```typescript
  private extractCookiesViaCDP(): { liAt: string; jsessionId: string } | null {
    try {
      // agent-browser's eval can access CDP via the browser session
      // Alternative: use the exec method to call a CDP command
      // For now, try reading from the session's cookie store
      const result = this.exec(
        'eval "(() => { return JSON.stringify(document.cookie); })()"'
      );
      // Parse the cookie string for li_at and JSESSIONID
      const cookieStr = JSON.parse(result.trim());
      const liAt = this.parseCookieValue(cookieStr, 'li_at');
      const jsessionId = this.parseCookieValue(cookieStr, 'JSESSIONID');
      if (!liAt || !jsessionId) return null;
      return { liAt, jsessionId };
    } catch {
      return null;
    }
  }
  ```

  **Add a helper** to parse individual cookie values from a cookie string:
  ```typescript
  private parseCookieValue(cookieStr: string, name: string): string | null {
    const match = cookieStr.match(new RegExp(`(?:^|;\\s*)${name}=([^;]*)`));
    return match ? match[1] : null;
  }
  ```

  **IMPORTANT:** Place the new methods after the existing public methods (after `checkForRestriction()`) but before the private helper methods. Do NOT modify any existing methods.

  **Also update the `login()` method** to call `extractVoyagerCookies()` after a successful login and log the result:
  After the existing login success path (where `return true` is about to happen), add:
  ```typescript
  // Extract Voyager API cookies for HTTP-based actions
  const voyagerCookies = await this.extractVoyagerCookies();
  if (voyagerCookies) {
    console.log('[LinkedInBrowser] Voyager cookies extracted successfully');
  } else {
    console.warn('[LinkedInBrowser] Failed to extract Voyager cookies — HTTP actions will not work');
  }
  ```
  Store the extracted cookies on an instance property `private voyagerCookies: { liAt: string; jsessionId: string } | null = null;` so they can be accessed after login.
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/linkedin-browser.ts</verify>
  <done>LinkedInBrowser has extractVoyagerCookies() method that returns { liAt, jsessionId } or null. Method is called after successful login. Cookies stored on instance property for access by worker.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Add Voyager cookie persistence and health update methods to ApiClient</name>
  <files>worker/src/api-client.ts</files>
  <action>
  Add three new methods to the `ApiClient` class for saving/loading Voyager cookies and updating sender health status.

  **1. `saveVoyagerCookies(senderId, cookies)` method:**
  ```typescript
  /**
   * Save Voyager API cookies (li_at + JSESSIONID) for a sender.
   * These are stored encrypted in Sender.sessionData via the existing session endpoint.
   * The cookies are stored as a JSON object with type marker for the API to distinguish
   * from the old browser cookie array format.
   */
  async saveVoyagerCookies(
    senderId: string,
    cookies: { liAt: string; jsessionId: string },
  ): Promise<void> {
    await this.request(`/api/linkedin/senders/${senderId}/session`, {
      method: "POST",
      body: JSON.stringify({
        cookies: [
          { type: "voyager", liAt: cookies.liAt, jsessionId: cookies.jsessionId }
        ],
      }),
    });
  }
  ```

  The existing `POST /api/linkedin/senders/{id}/session` endpoint accepts a `cookies` array and encrypts + stores it as JSON in `Sender.sessionData`. By wrapping the Voyager cookies in the same array format with a `type: "voyager"` marker, the existing endpoint works without modification. The worker will parse this on load.

  **2. `getVoyagerCookies(senderId)` method:**

  **IMPORTANT:** The existing GET `/api/linkedin/senders/{id}/session` does NOT return `sessionData` — it only returns `{ sessionStatus, healthStatus, lastActiveAt }` for dashboard polling. A new dedicated endpoint `GET /api/linkedin/senders/{id}/cookies` is created in Task 3 to return decrypted cookies. This follows the same pattern as the existing `GET /api/linkedin/senders/{id}/credentials` endpoint.

  ```typescript
  /**
   * Load Voyager API cookies for a sender from the cookies endpoint.
   * Uses GET /api/linkedin/senders/{id}/cookies which decrypts sessionData server-side.
   * Returns null if no cookies are stored or if they're in the old browser format.
   */
  async getVoyagerCookies(
    senderId: string,
  ): Promise<{ liAt: string; jsessionId: string } | null> {
    try {
      const result = await this.request<{ cookies: unknown[] }>(
        `/api/linkedin/senders/${senderId}/cookies`,
      );

      // Look for voyager-type cookie entry
      if (Array.isArray(result.cookies)) {
        const voyagerEntry = result.cookies.find(
          (entry: any) => entry && typeof entry === 'object' && entry.type === 'voyager'
        ) as { type: string; liAt: string; jsessionId: string } | undefined;

        if (voyagerEntry?.liAt && voyagerEntry?.jsessionId) {
          return { liAt: voyagerEntry.liAt, jsessionId: voyagerEntry.jsessionId };
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  ```

  **3. `updateSenderHealth(senderId, healthStatus)` method:**

  This method is needed because the existing `markFailed()` action endpoint does NOT update `Sender.healthStatus` — it only updates `LinkedInAction.status` and `LinkedInAction.error`. Plan 03's worker needs to explicitly set sender health when it detects `ip_blocked` or `checkpoint_detected` errors.

  ```typescript
  /**
   * Update the health status of a sender.
   * Called by the worker when it detects auth failures, IP blocks, or checkpoint challenges.
   * The fail action endpoint does NOT update sender health — only action status.
   */
  async updateSenderHealth(
    senderId: string,
    healthStatus: string,
  ): Promise<void> {
    await this.request(`/api/linkedin/senders/${senderId}/health`, {
      method: "PATCH",
      body: JSON.stringify({ healthStatus }),
    });
  }
  ```

  Place all three methods after the existing `updateSession()` method. Do NOT modify existing methods.
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/api-client.ts</verify>
  <done>ApiClient has saveVoyagerCookies(), getVoyagerCookies(), and updateSenderHealth() methods. saveVoyagerCookies persists via existing session endpoint. getVoyagerCookies loads from new /cookies endpoint. updateSenderHealth patches sender health via new /health endpoint.</done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoints for cookie retrieval and health updates</name>
  <files>src/app/api/linkedin/senders/[id]/cookies/route.ts, src/app/api/linkedin/senders/[id]/health/route.ts</files>
  <action>
  Create two new worker-only API endpoints needed by the ApiClient methods from Task 2.

  **1. Cookie retrieval endpoint: `src/app/api/linkedin/senders/[id]/cookies/route.ts`**

  Follow the exact same pattern as the existing `src/app/api/linkedin/senders/[id]/credentials/route.ts` — worker-auth-gated, reads encrypted field, decrypts, returns JSON.

  ```typescript
  import { NextRequest, NextResponse } from "next/server";
  import { verifyWorkerAuth } from "@/lib/linkedin/auth";
  import { prisma } from "@/lib/db";
  import { decrypt } from "@/lib/crypto";

  /**
   * GET /api/linkedin/senders/[id]/cookies
   * Returns decrypted session cookies for a sender.
   * Worker-only endpoint — used to load Voyager API cookies (li_at + JSESSIONID).
   * Follows the same pattern as the credentials endpoint.
   */
  export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> },
  ) {
    if (!verifyWorkerAuth(request)) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    try {
      const { id } = await params;

      const sender = await prisma.sender.findUnique({
        where: { id },
        select: {
          id: true,
          sessionData: true,
          sessionStatus: true,
        },
      });

      if (!sender) {
        return NextResponse.json({ error: "Sender not found" }, { status: 404 });
      }

      if (!sender.sessionData) {
        return NextResponse.json({ cookies: null });
      }

      // Decrypt session data
      let cookies: unknown[];
      try {
        const decrypted = decrypt(sender.sessionData);
        cookies = JSON.parse(decrypted);
      } catch {
        return NextResponse.json(
          { error: "Failed to decrypt session data" },
          { status: 500 },
        );
      }

      return NextResponse.json({ cookies });
    } catch (error) {
      console.error("Get cookies error:", error);
      return NextResponse.json(
        { error: "Failed to get cookies" },
        { status: 500 },
      );
    }
  }
  ```

  **2. Health update endpoint: `src/app/api/linkedin/senders/[id]/health/route.ts`**

  ```typescript
  import { NextRequest, NextResponse } from "next/server";
  import { verifyWorkerAuth } from "@/lib/linkedin/auth";
  import { prisma } from "@/lib/db";

  /**
   * PATCH /api/linkedin/senders/[id]/health
   * Update the health status of a sender.
   * Worker-only endpoint — called when the worker detects auth failures, IP blocks, or checkpoints.
   */
  export async function PATCH(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> },
  ) {
    if (!verifyWorkerAuth(request)) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    try {
      const { id } = await params;
      const body = await request.json();

      const validStatuses = ["healthy", "warning", "paused", "blocked", "session_expired"];
      if (!body.healthStatus || !validStatuses.includes(body.healthStatus)) {
        return NextResponse.json(
          { error: `Invalid healthStatus. Must be one of: ${validStatuses.join(", ")}` },
          { status: 400 },
        );
      }

      await prisma.sender.update({
        where: { id },
        data: {
          healthStatus: body.healthStatus,
        },
      });

      return NextResponse.json({ ok: true });
    } catch (error) {
      console.error("Update health error:", error);
      return NextResponse.json(
        { error: "Failed to update health status" },
        { status: 500 },
      );
    }
  }
  ```

  **Directory creation:** Create `src/app/api/linkedin/senders/[id]/cookies/` and `src/app/api/linkedin/senders/[id]/health/` directories before writing the files.
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/app/api/linkedin/senders/\[id\]/cookies/route.ts src/app/api/linkedin/senders/\[id\]/health/route.ts</verify>
  <done>Two new API endpoints created: GET /api/linkedin/senders/{id}/cookies (returns decrypted session cookies, following credentials endpoint pattern) and PATCH /api/linkedin/senders/{id}/health (updates Sender.healthStatus). Both are worker-auth-gated.</done>
</task>

</tasks>

<verification>
- `worker/src/linkedin-browser.ts` compiles: `cd worker && npx tsc --noEmit src/linkedin-browser.ts`
- `worker/src/api-client.ts` compiles: `cd worker && npx tsc --noEmit src/api-client.ts`
- API endpoints compile: `npx tsc --noEmit` (full project)
- LinkedInBrowser has `extractVoyagerCookies()` public method
- LinkedInBrowser has `voyagerCookies` instance property
- ApiClient has `saveVoyagerCookies()`, `getVoyagerCookies()`, and `updateSenderHealth()` methods
- `getVoyagerCookies` calls GET `/api/linkedin/senders/{id}/cookies` (NOT the session endpoint)
- `updateSenderHealth` calls PATCH `/api/linkedin/senders/{id}/health`
- Login flow triggers cookie extraction automatically
- GET cookies endpoint decrypts sessionData using `decrypt()` from `@/lib/crypto`
- PATCH health endpoint validates healthStatus against allowed values
</verification>

<success_criteria>
LinkedInBrowser can extract li_at + JSESSIONID cookies from agent-browser session after login. ApiClient can persist cookies (via existing session POST), load them (via new cookies GET endpoint), and update sender health (via new health PATCH endpoint). The cookie retrieval follows the same decrypt-and-return pattern as the credentials endpoint. The health update provides the mechanism for Plan 03 to set sender health on ip_blocked/checkpoint_detected errors (since markFailed does NOT update Sender.healthStatus).
</success_criteria>

<output>
After completion, create `.planning/phases/11-linkedin-voyager-api-client/11-02-SUMMARY.md`
</output>
