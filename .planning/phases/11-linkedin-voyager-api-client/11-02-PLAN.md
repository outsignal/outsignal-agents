---
phase: 11-linkedin-voyager-api-client
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/src/linkedin-browser.ts
  - worker/src/api-client.ts
autonomous: true
requirements:
  - VOYAGER-05

must_haves:
  truths:
    - "LinkedInBrowser can extract li_at and JSESSIONID cookies after successful login"
    - "Extracted cookies can be persisted to the API via api-client.ts"
    - "ApiClient can load Voyager cookies (li_at + JSESSIONID) from the API for a sender"
  artifacts:
    - path: "worker/src/linkedin-browser.ts"
      provides: "extractVoyagerCookies() method on LinkedInBrowser"
      contains: "extractVoyagerCookies"
    - path: "worker/src/api-client.ts"
      provides: "saveVoyagerCookies() and getVoyagerCookies() methods on ApiClient"
      contains: "saveVoyagerCookies"
  key_links:
    - from: "worker/src/linkedin-browser.ts"
      to: "worker/src/api-client.ts"
      via: "cookie extraction feeds into cookie persistence"
      pattern: "extractVoyagerCookies|saveVoyagerCookies"
    - from: "worker/src/api-client.ts"
      to: "/api/linkedin/senders/{id}/session"
      via: "HTTP POST to persist cookies"
      pattern: "senders.*session"
---

<objective>
Add Voyager cookie extraction to LinkedInBrowser and cookie persistence methods to ApiClient, enabling the transition from browser-based action execution to HTTP-based Voyager API calls.

Purpose: The VoyagerClient (Plan 01) needs li_at + JSESSIONID cookies to authenticate. These cookies come from agent-browser's login flow. This plan adds the extraction bridge and persistence layer.

Output: LinkedInBrowser gains `extractVoyagerCookies()` method; ApiClient gains `saveVoyagerCookies()` and `getVoyagerCookies()` methods.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/11-linkedin-voyager-api-client/11-RESEARCH.md
@worker/src/linkedin-browser.ts
@worker/src/api-client.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From worker/src/linkedin-browser.ts (existing class to extend):
```typescript
export class LinkedInBrowser {
  private session: string;
  private proxyUrl: string | undefined;
  private launched: boolean;
  // ... existing methods: launch, login, close, viewProfile, sendConnectionRequest, sendMessage, checkConnectionStatus, checkForCaptcha, checkForRestriction

  // Uses execFileSync to run agent-browser CLI commands
  private exec(args: string): string;
}
```

From worker/src/api-client.ts (existing class to extend):
```typescript
export class ApiClient {
  // Existing method — saves raw cookies array:
  async updateSession(senderId: string, cookies: unknown[]): Promise<void>;

  // Existing method — gets credentials for auto-login:
  async getSenderCredentials(senderId: string): Promise<{...} | null>;
}
```

Sender.sessionData field stores AES-256-GCM encrypted JSON via the API.
The API endpoint POST /api/linkedin/senders/{id}/session accepts and encrypts cookie data.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extractVoyagerCookies() to LinkedInBrowser</name>
  <files>worker/src/linkedin-browser.ts</files>
  <action>
  Add a new public method `extractVoyagerCookies()` to the `LinkedInBrowser` class that extracts `li_at` and `JSESSIONID` cookies from the agent-browser session after a successful login.

  **Method signature:**
  ```typescript
  async extractVoyagerCookies(): Promise<{ liAt: string; jsessionId: string } | null>
  ```

  **Implementation approach:**
  The agent-browser uses CDP (Chrome DevTools Protocol) under the hood. Use the `eval` command to execute JavaScript in the browser context and extract cookies from `document.cookie`.

  ```typescript
  async extractVoyagerCookies(): Promise<{ liAt: string; jsessionId: string } | null> {
    try {
      // Navigate to LinkedIn to ensure we're on the right domain
      // (cookies are domain-scoped)
      const result = this.exec(
        'eval "(() => { const c = {}; document.cookie.split(\\";\\").forEach(p => { const [k,...v] = p.trim().split(\\"=\\"); c[k] = v.join(\\"=\\"); }); return JSON.stringify({ li_at: c.li_at || null, JSESSIONID: c.JSESSIONID || null }); })()"'
      );

      const parsed = JSON.parse(result.trim());
      if (!parsed.li_at || !parsed.JSESSIONID) {
        // li_at may be HttpOnly — try CDP Network.getAllCookies as fallback
        return this.extractCookiesViaCDP();
      }
      return { liAt: parsed.li_at, jsessionId: parsed.JSESSIONID };
    } catch (err) {
      console.error('[LinkedInBrowser] Cookie extraction failed:', err);
      return null;
    }
  }
  ```

  **CDP fallback** — If `document.cookie` doesn't include `li_at` (it may be HttpOnly), add a fallback method:
  ```typescript
  private extractCookiesViaCDP(): { liAt: string; jsessionId: string } | null {
    try {
      // agent-browser's eval can access CDP via the browser session
      // Alternative: use the exec method to call a CDP command
      // For now, try reading from the session's cookie store
      const result = this.exec(
        'eval "(() => { return JSON.stringify(document.cookie); })()"'
      );
      // Parse the cookie string for li_at and JSESSIONID
      const cookieStr = JSON.parse(result.trim());
      const liAt = this.parseCookieValue(cookieStr, 'li_at');
      const jsessionId = this.parseCookieValue(cookieStr, 'JSESSIONID');
      if (!liAt || !jsessionId) return null;
      return { liAt, jsessionId };
    } catch {
      return null;
    }
  }
  ```

  **Add a helper** to parse individual cookie values from a cookie string:
  ```typescript
  private parseCookieValue(cookieStr: string, name: string): string | null {
    const match = cookieStr.match(new RegExp(`(?:^|;\\s*)${name}=([^;]*)`));
    return match ? match[1] : null;
  }
  ```

  **IMPORTANT:** Place the new methods after the existing public methods (after `checkForRestriction()`) but before the private helper methods. Do NOT modify any existing methods.

  **Also update the `login()` method** to call `extractVoyagerCookies()` after a successful login and log the result:
  After the existing login success path (where `return true` is about to happen), add:
  ```typescript
  // Extract Voyager API cookies for HTTP-based actions
  const voyagerCookies = await this.extractVoyagerCookies();
  if (voyagerCookies) {
    console.log('[LinkedInBrowser] Voyager cookies extracted successfully');
  } else {
    console.warn('[LinkedInBrowser] Failed to extract Voyager cookies — HTTP actions will not work');
  }
  ```
  Store the extracted cookies on an instance property `private voyagerCookies: { liAt: string; jsessionId: string } | null = null;` so they can be accessed after login.
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/linkedin-browser.ts</verify>
  <done>LinkedInBrowser has extractVoyagerCookies() method that returns { liAt, jsessionId } or null. Method is called after successful login. Cookies stored on instance property for access by worker.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Add Voyager cookie persistence methods to ApiClient</name>
  <files>worker/src/api-client.ts</files>
  <action>
  Add two new methods to the `ApiClient` class for saving and loading Voyager cookies (li_at + JSESSIONID) via the existing session API endpoint.

  **1. `saveVoyagerCookies(senderId, cookies)` method:**
  ```typescript
  /**
   * Save Voyager API cookies (li_at + JSESSIONID) for a sender.
   * These are stored encrypted in Sender.sessionData via the existing session endpoint.
   * The cookies are stored as a JSON object with type marker for the API to distinguish
   * from the old browser cookie array format.
   */
  async saveVoyagerCookies(
    senderId: string,
    cookies: { liAt: string; jsessionId: string },
  ): Promise<void> {
    await this.request(`/api/linkedin/senders/${senderId}/session`, {
      method: "POST",
      body: JSON.stringify({
        cookies: [
          { type: "voyager", liAt: cookies.liAt, jsessionId: cookies.jsessionId }
        ],
      }),
    });
  }
  ```

  The existing `POST /api/linkedin/senders/{id}/session` endpoint accepts a `cookies` array and encrypts + stores it as JSON in `Sender.sessionData`. By wrapping the Voyager cookies in the same array format with a `type: "voyager"` marker, the existing endpoint works without modification. The worker will parse this on load.

  **2. `getVoyagerCookies(senderId)` method:**
  ```typescript
  /**
   * Load Voyager API cookies for a sender from the session endpoint.
   * Returns null if no cookies are stored or if they're in the old browser format.
   */
  async getVoyagerCookies(
    senderId: string,
  ): Promise<{ liAt: string; jsessionId: string } | null> {
    try {
      const result = await this.request<{ sessionData: unknown[] }>(
        `/api/linkedin/senders/${senderId}/session`,
      );

      // Look for voyager-type cookie entry
      if (Array.isArray(result.sessionData)) {
        const voyagerEntry = result.sessionData.find(
          (entry: any) => entry && typeof entry === 'object' && entry.type === 'voyager'
        ) as { type: string; liAt: string; jsessionId: string } | undefined;

        if (voyagerEntry?.liAt && voyagerEntry?.jsessionId) {
          return { liAt: voyagerEntry.liAt, jsessionId: voyagerEntry.jsessionId };
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  ```

  **Note:** The GET endpoint for session data may not exist yet. If the existing `/api/linkedin/senders/{id}/session` only supports POST, the `getVoyagerCookies` method should use the sender detail endpoint instead. Check if `getSenders()` already returns `sessionData` in the SenderItem interface — if it does, add a comment noting that cookies can be loaded from the sender list response as a fallback. In that case, change `getVoyagerCookies` to:

  ```typescript
  async getVoyagerCookies(senderId: string): Promise<{ liAt: string; jsessionId: string } | null> {
    try {
      // Session data is returned in the sender detail, parsed by the API (decrypted server-side)
      const result = await this.request<{ cookies: unknown[] }>(
        `/api/linkedin/senders/${senderId}/session`,
      );
      if (Array.isArray(result.cookies)) {
        const voyagerEntry = result.cookies.find(
          (entry: any) => entry?.type === 'voyager'
        ) as { type: string; liAt: string; jsessionId: string } | undefined;
        if (voyagerEntry?.liAt && voyagerEntry?.jsessionId) {
          return { liAt: voyagerEntry.liAt, jsessionId: voyagerEntry.jsessionId };
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  ```

  Place both methods after the existing `updateSession()` method. Do NOT modify existing methods.
  </action>
  <verify>cd /Users/jjay/programs/outsignal-agents/worker && npx tsc --noEmit src/api-client.ts</verify>
  <done>ApiClient has saveVoyagerCookies() and getVoyagerCookies() methods. saveVoyagerCookies persists li_at + JSESSIONID via existing session endpoint with voyager type marker. getVoyagerCookies loads and parses them back.</done>
</task>

</tasks>

<verification>
- `worker/src/linkedin-browser.ts` compiles: `cd worker && npx tsc --noEmit src/linkedin-browser.ts`
- `worker/src/api-client.ts` compiles: `cd worker && npx tsc --noEmit src/api-client.ts`
- LinkedInBrowser has `extractVoyagerCookies()` public method
- LinkedInBrowser has `voyagerCookies` instance property
- ApiClient has `saveVoyagerCookies()` and `getVoyagerCookies()` methods
- Login flow triggers cookie extraction automatically
</verification>

<success_criteria>
LinkedInBrowser can extract li_at + JSESSIONID cookies from agent-browser session after login, and ApiClient can persist and load these cookies via the session API endpoint. The cookie extraction is called automatically during login flow.
</success_criteria>

<output>
After completion, create `.planning/phases/11-linkedin-voyager-api-client/11-02-SUMMARY.md`
</output>
