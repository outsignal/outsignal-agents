# Phase 8 Research: Campaign Entity + Writer Integration

**Completed:** 2026-02-27
**Researcher:** Phase 8 codebase explorer

---

## COMPREHENSIVE RESEARCH REPORT: Phase 8 Campaign Entity + Writer Integration

This document provides a thorough analysis of the outsignal-agents codebase to prepare for Phase 8 implementation.

---

## 1. PRISMA SCHEMA OVERVIEW

### Current Models (Key for Phase 8)

**File**: `/Users/jjay/programs/outsignal-agents/prisma/schema.prisma`

#### Workspace (lines 10-69)
- Central client entity with ICP config, campaign brief, and notification settings
- Fields: `id`, `slug` (unique), `name`, `vertical`, `apiToken`
- Stores all client strategy (ICP, differentiators, case studies, messaging)
- Relations: `senders` (Sender[]), implicit to TargetList via `workspaceSlug`

#### Person (lines 71-97, @map "Lead")
- Central person record, workspace-agnostic
- `id`, `email` (unique), `firstName`, `lastName`, `company`, `companyDomain`, `jobTitle`, `phone`, `linkedinUrl`, `location`, `vertical`, `source`, `status`
- Status values: "new" | "contacted" | "replied" | "interested" | "bounced" | "unsubscribed"
- Enrichment data stored in `enrichmentData` JSON column
- Relations: `workspaces` (PersonWorkspace[]), `lists` (TargetListPerson[])

#### PersonWorkspace (lines 99-119, @map "LeadWorkspace")
- Junction table for Person ↔ Workspace many-to-many relationship
- `id`, `personId` (FK), `workspace` (slug string, NOT a FK), `sourceId`, `status`, `vertical`, `tags`
- **ICP scoring fields**: `icpScore` (0-100), `icpReasoning`, `icpConfidence` ("high"|"medium"|"low"), `icpScoredAt`
- Unique constraint: `[personId, workspace]`
- **Key insight**: Workspace-specific data lives here; Person is just the central store

#### TargetList (lines 338-349)
- Represents a saved list of people for a workspace
- `id`, `name`, `workspaceSlug` (string, indexed), `description`, `createdAt`, `updatedAt`
- Relations: `people` (TargetListPerson[])
- **Important**: NOT FK to Workspace; uses `workspaceSlug` string reference
- **Current use**: Stores lists of people; no direct campaign linkage

#### TargetListPerson (lines 351-363)
- Junction table: TargetList ↔ Person many-to-many
- `id`, `listId` (FK), `personId` (FK), `addedAt`
- Unique constraint: `[listId, personId]`

#### EmailDraft (lines 272-291)
- Stores email/LinkedIn drafts generated by Writer Agent
- `id`, `workspaceSlug`, `campaignName`, `channel` ("email"|"linkedin"), `sequenceStep`
- Email-specific: `subjectLine`, `subjectVariantB`, `bodyHtml`, `bodyText`, `delayDays`
- Status: "draft" | "review" | "approved" | "deployed"
- `version`, `feedback`, `createdAt`, `updatedAt`
- Indexed by `[workspaceSlug, campaignName]` and `status`
- **Key observation**: Already tracks campaign drafts but NO explicit Campaign model

#### AgentRun (lines 229-244)
- Audit log for all agent executions
- `id`, `agent` ("research"|"leads"|"writer"|"campaign"), `workspaceSlug`, `input` (JSON), `output` (JSON), `status`, `steps` (JSON), `durationMs`, `error`
- Relations: None (just audit logging)

#### CampaignSequenceRule (lines 503-524)
- Rules for LinkedIn sequencing tied to campaigns
- `id`, `workspaceSlug`, `campaignName`, `triggerEvent`, `triggerStepRef`, `actionType`, `messageTemplate`, `delayMinutes`, `requireConnected`, `position`
- Indexed by `[workspaceSlug, campaignName]`
- **Connection point**: Campaign name as string reference

#### WebhookEvent (lines 145-158)
- Logs all EmailBison webhook events
- `id`, `workspace`, `eventType`, `campaignId` (string), `leadEmail`, `senderEmail`, `payload`, `receivedAt`
- **Event types**: EMAIL_SENT, LEAD_REPLIED, LEAD_INTERESTED, UNTRACKED_REPLY_RECEIVED
- Indexed by `[workspace, eventType]`, `[leadEmail]`, `[senderEmail, eventType]`

### Database Relationships Summary

```
Person (email unique, workspace-agnostic)
├── PersonWorkspace (N:M junction, workspace-scoped data)
├── TargetListPerson (N:M junction with TargetList)
│   └── TargetList
│       └── workspaceSlug (string reference)
│
Workspace (slug unique, central client record)
├── TargetList (N:1 via workspaceSlug string)
├── Sender
├── LinkedInAction
└── [MISSING: Campaign model would fit here]

EmailDraft
├── workspaceSlug (string reference to Workspace)
└── campaignName (string reference to campaign in EmailBison)

CampaignSequenceRule
├── workspaceSlug (string reference)
└── campaignName (string reference)

WebhookEvent
├── workspace (string reference)
├── campaignId (string reference to EmailBison campaign)
└── leadEmail (string reference to Person.email)
```

### Where Campaign Model Fits

**Key insight from v1.0 schema**: There is NO Campaign model in the local database. Currently:
- **EmailBison** manages campaigns (external system)
- **EmailDraft** stores copy generated by Writer Agent (keyed by `campaignName` string)
- **CampaignSequenceRule** stores LinkedIn sequence rules (keyed by `campaignName` string)

**Phase 8 Campaign Model should be**:
```
Campaign {
  id: String @id @default(cuid())
  name: String
  workspaceSlug: String (FK to Workspace.slug)
  description: String?

  // Links to EmailBison
  emailBisonCampaignId: Int? (nullable until created)
  emailBisonSequenceId: Int?

  // Content ownership
  targetListId: String? (FK to TargetList, initial lead source)
  status: String ("draft" | "review" | "scheduled" | "active" | "completed" | "paused")

  // Writer Agent output
  emailDrafts: EmailDraft[] (relation, filtered by workspaceSlug + campaignName)
  linkedinSequenceRules: CampaignSequenceRule[] (relation, filtered)

  // Leads assigned to this campaign
  campaignLeads: CampaignLead[] (N:M junction: Campaign ↔ PersonWorkspace)

  // Metadata
  createdAt: DateTime @default(now())
  updatedAt: DateTime @updatedAt
  publishedAt: DateTime? (when moved to client review)
  launchedAt: DateTime? (when sent to EmailBison)

  workspace: Workspace @relation(fields: [workspaceSlug], references: [slug])

  @@index([workspaceSlug])
  @@index([status])
  @@index([emailBisonCampaignId])
}

CampaignLead {
  id: String @id @default(cuid())
  campaignId: String (FK)
  personWorkspaceId: String (FK to PersonWorkspace)
  addedAt: DateTime

  campaign: Campaign @relation(fields: [campaignId], references: [id])
  personWorkspace: PersonWorkspace @relation(fields: [personWorkspaceId], references: [id])

  @@unique([campaignId, personWorkspaceId])
}
```

---

## 2. WRITER AGENT IMPLEMENTATION

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/agents/writer.ts` (395 lines)

### Current Implementation

#### Tools Provided (6)

1. **getWorkspaceIntelligence** (lines 12-51)
   - Returns: workspace name, slug, vertical, ICP fields, campaign brief, website analysis
   - Input: `slug` string
   - Used to understand client before writing

2. **getCampaignPerformance** (lines 53-92)
   - Returns: array of campaigns with metrics (reply_rate, open_rate, bounce_rate)
   - Input: `workspaceSlug`
   - Calls EmailBison API: `getClientForWorkspace().getCampaigns()`

3. **getSequenceSteps** (lines 94-119)
   - Returns: existing email copy from campaigns (subject, body, delay_days)
   - Inputs: `workspaceSlug`, `campaignId` (number)
   - Calls EmailBison API: `getClientForWorkspace().getSequenceSteps(campaignId)`

4. **searchKnowledgeBase** (lines 121-157)
   - Query: free-text search for cold email best practices
   - Returns: matching chunks with title/content
   - Calls: `searchKnowledge(query, { limit, tags })`
   - Tags available: "cold-email", "linkedin", "subject-lines" (from knowledge base)

5. **getExistingDrafts** (lines 159-197)
   - Returns: EmailDraft records filtered by workspace and optional campaign name
   - Input: `workspaceSlug`, optional `campaignName`
   - Shows previous versions/feedback for revision context

6. **saveDraft** (lines 199-259)
   - **Creates** an EmailDraft record in database
   - Inputs: `workspaceSlug`, `campaignName`, `channel` ("email"|"linkedin"), `sequenceStep`, `subjectLine`, `subjectVariantB`, `bodyText`, `bodyHtml`, `delayDays`
   - Always creates with `status: "draft"`
   - Returns: `{ id, status: "saved", message }`

#### System Prompt & Agent Behavior (lines 262-343)

**Agent Name**: `writer` (used in AgentRun.agent field)
**Model**: `claude-opus-4-20250514` (lines 347)
**Max Steps**: 10 (line 350)

**Process mandated by prompt**:
1. Call `getWorkspaceIntelligence` to understand client
2. Call `getCampaignPerformance` and `getSequenceSteps` to see what works
3. Call `searchKnowledgeBase` to ground in frameworks
4. Call `getExistingDrafts` to check prior versions
5. Write sequence copy
6. Call `saveDraft` for each step

**Output format** (lines 315-340):
```json
{
  "campaignName": "string",
  "channel": "email" | "linkedin" | "email_linkedin",
  "emailSteps": [
    {
      "position": 1,
      "subjectLine": "...",
      "subjectVariantB": "...",
      "body": "...",
      "delayDays": 0,
      "notes": "Why this works"
    }
  ],
  "linkedinSteps": [
    {
      "position": 1,
      "type": "connection_request" | "message" | "inmail",
      "body": "...",
      "delayDays": 0,
      "notes": "Why this works"
    }
  ],
  "reviewNotes": "Self-critique"
}
```

#### Input/Output Types

**WriterInput** (from types.ts):
```typescript
interface WriterInput {
  workspaceSlug: string;
  task: string;
  channel?: "email" | "linkedin" | "email_linkedin";
  campaignName?: string;
  feedback?: string;
}

interface WriterOutput {
  campaignName: string;
  channel: "email" | "linkedin" | "email_linkedin";
  emailSteps?: EmailStep[];
  linkedinSteps?: LinkedInStep[];
  reviewNotes: string;
}
```

### How It's Called (line 363-374)

```typescript
export async function runWriterAgent(input: WriterInput): Promise<WriterOutput> {
  const userMessage = buildWriterMessage(input);
  const result = await runAgent<WriterOutput>(writerConfig, userMessage, {
    triggeredBy: "cli",
    workspaceSlug: input.workspaceSlug,
  });
  return result.output;
}
```

**Called from**:
- Orchestrator's `delegateToWriter` tool
- CLI scripts
- Direct API calls

### Knowledge Base Integration (lines 121-157)

**Interface**: `searchKnowledge(query, { limit?, tags? })`

**Implementation** (`/Users/jjay/programs/outsignal-agents/src/lib/knowledge/store.ts`):
- Fetches all `KnowledgeDocument` records from DB
- Splits documents into chunks (800-1200 chars each)
- Simple keyword matching (no embeddings yet)
- Returns top N by keyword match count
- **Current documents**: 46 docs (as of 2026-02-26)

---

## 3. ORCHESTRATOR CONFIGURATION

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/agents/orchestrator.ts` (525 lines)

### Tool Definitions (Relevant for Phase 8)

#### Delegation Tools (lines 16-161)

1. **delegateToResearch** (lines 18-57)
   - Hands off website analysis to Research Agent
   - Returns: companyOverview, icpIndicators, valuePropositions, caseStudies, painPoints, differentiators, suggestions

2. **delegateToLeads** (lines 59-95)
   - Hands off lead search/list management to Leads Agent
   - Input schema: `workspaceSlug` (optional), `task` (string), `conversationContext` (optional)
   - Returns: `{ status, action, summary, data }`

3. **delegateToWriter** (lines 97-141)
   - Hands off email/LinkedIn copy generation to Writer Agent
   - **Input schema**:
     ```typescript
     {
       workspaceSlug: string,
       task: string,
       channel?: "email" | "linkedin" | "email_linkedin",
       campaignName?: string,
       feedback?: string
     }
     ```
   - Returns: `{ status, campaignName, channel, emailSteps (count), linkedinSteps (count), reviewNotes }`

4. **delegateToCampaign** (lines 143-161)
   - **PLACEHOLDER** - currently returns `{ status: "not_available", message: "..." }`
   - Intended for: "create a campaign in EmailBison, add leads to a campaign, configure sequence steps, or check campaign status"
   - Input schema: `workspaceSlug`, `task`, optional `campaignName`

#### Dashboard Tools (lines 165-467)
- Direct query tools (no delegation): listWorkspaces, getWorkspaceInfo, getCampaigns, getReplies, getSenderHealth, queryPeople, listProposals, createProposal

### Orchestrator System Prompt (lines 483-516)

**Model**: `claude-sonnet-4-20250514` (line 521)
**Max Steps**: 12 (line 523)

Key guidance:
- Delegate complex tasks (analysis, copy writing, lead search)
- Use dashboard tools for simple queries
- When orchestrator delegates to Writer Agent and it completes, the orchestrator summarizes results

### Tool Wiring Pattern (lines 471-479)

```typescript
export const orchestratorTools = {
  // Delegation tools (specialist agents)
  delegateToResearch,
  delegateToLeads,
  delegateToWriter,
  delegateToCampaign,  // ← Currently a stub
  // Existing dashboard tools
  ...dashboardTools,
};
```

**For Phase 8**: Campaign agent delegation tool would be wired here, alongside existing delegations.

---

## 4. WEBHOOK HANDLER FOR REPLY EVENTS

**File**: `/Users/jjay/programs/outsignal-agents/src/app/api/webhooks/emailbison/route.ts` (138 lines)

### Webhook Event Flow

#### Incoming Events (lines 7-22)
- **Payload structure**: `{ event: {type: string, ...}, data: {...} }`
- **Extracted fields**:
  - `eventType`: "EMAIL_SENT", "LEAD_REPLIED", "LEAD_INTERESTED", "UNTRACKED_REPLY_RECEIVED", etc.
  - `workspaceSlug`: from query param `?workspace=` or event data
  - `leadEmail`: from `data.lead.email` or `data.reply.from_email_address`
  - `senderEmail`: from `data.sender_email.email` or `data.reply.primary_to_email_address`
  - `subject`: `data.reply.email_subject`
  - `textBody`: `data.reply.text_body`
  - `automatedReply`: `data.reply.automated_reply` (boolean)
  - `interested`: `data.reply.interested` (boolean)
  - `leadName`: from `data.lead.first_name` + `data.lead.last_name`

#### Event Processing (lines 23-130)

**1. Webhook Event Logging** (lines 23-32)
```typescript
await prisma.webhookEvent.create({
  workspace, eventType, campaignId, leadEmail, senderEmail, payload
})
```

**2. Status Updates on Email Events** (lines 34-49)
- EMAIL_SENT → updates Person.status from "new" to "contacted"
- Also updates PersonWorkspace.status

**3. Status Updates on Reply Events** (lines 51-73)
- LEAD_REPLIED, LEAD_INTERESTED, UNTRACKED_REPLY_RECEIVED → maps to status updates
- Status map:
  - "LEAD_REPLIED" → "replied"
  - "LEAD_INTERESTED" → "interested"
  - "UNTRACKED_REPLY_RECEIVED" → "replied"
- Updates both Person and PersonWorkspace records

**4. LinkedIn Fast-Track** (lines 75-113)
- On LEAD_REPLIED or LEAD_INTERESTED:
  - Fetch Person by email
  - Check for LinkedIn URL
  - Try to bump existing pending connection to Priority 1
  - If no existing action, enqueue new P1 connection request
  - Calls: `bumpPriority()`, `enqueueAction()`

**5. Notification Dispatch** (lines 115-130)
- On LEAD_REPLIED, LEAD_INTERESTED, UNTRACKED_REPLY_RECEIVED (if not automatedReply):
  - Call `notifyReply()` with extracted data

### Context Available for Reply Suggestions (Phase 8)

At webhook receipt, the following context is available:
- `leadEmail`: Exact email of replier
- `leadName`: Name (if available)
- `subject`: Reply subject line
- `textBody`: Full reply text (up to 300 chars preview currently)
- `senderEmail`: Email that was replied to
- `workspaceSlug`: Workspace context
- `campaignId` (from EmailBison): Campaign the lead was in
- `interested`: Boolean flag if marked interested

**Missing from webhook**: No message history (prior emails in sequence). Would need to fetch from EmailBison API if needed for reply suggestion context.

---

## 5. NOTIFICATIONS SYSTEM

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/notifications.ts` (127 lines)

### notifyReply() Function

**Input params**:
```typescript
{
  workspaceSlug: string;
  leadName?: string | null;
  leadEmail: string;
  senderEmail: string;
  subject: string | null;
  bodyPreview: string | null;
  interested?: boolean;
}
```

### Slack Notification Format (lines 27-95)

**Channel**: `workspace.slackChannelId` (if configured)

**Blocks structure**:
1. **Header block**: "Interested Reply Received" or "New Reply Received"
2. **Name section** (if available): `*Name:* {leadName}`
3. **From section**: `*From:* {leadEmail}`
4. **Subject section** (if available): `*Subject:* {subject}`
5. **Body preview section**: `{bodyPreview}` (first 300 chars)
6. **Action button**: "Reply in Outsignal" → links to `https://app.outsignal.ai/inbox`

**For Phase 8**: Could add a 7th section:
```
{
  type: "section",
  text: {
    type: "mrkdwn",
    text: "*Suggested Response:* [AI-generated reply]"
  }
}
```

### Email Notification Format (lines 97-126)

**Recipients**: `workspace.notificationEmails` (JSON array of emails)

**Subject**: `[{workspace.name}] {label} from {leadName or leadEmail}`

**Body HTML**:
- Title
- Name (if available)
- From email
- Subject (if available)
- Body preview
- Button: "Reply in Outsignal" (styled with brand color #F0FF7A)

**For Phase 8**: Could add a suggested response block in HTML between body preview and button.

---

## 6. KNOWLEDGE BASE SYSTEM

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/knowledge/store.ts` (186 lines)

### Data Model

**KnowledgeDocument** (schema lines 260-270):
- `id`, `title`, `source` ("upload"|"url"), `content` (full text), `chunks` (JSON array of strings), `tags` (comma-separated), `createdAt`

### Chunking Strategy (lines 13-85)

**Constants**:
- `CHUNK_TARGET_SIZE = 800` characters
- `CHUNK_MAX_SIZE = 1200` characters

**Algorithm** (`chunkText()`):
1. Split text on paragraph boundaries (`\n{2,}`)
2. Accumulate paragraphs into chunks, target ~800 chars
3. If chunk exceeds 1200 chars, split by sentences
4. Return array of chunks

**Result**: ~800 char chunks suitable for keyword matching

### Search Interface (lines 117-158)

**`searchKnowledge(query: string, options?: { limit?: number, tags?: string })`**

**Implementation**:
1. Fetch all KnowledgeDocument (or filter by tags)
2. For each document, parse `chunks` JSON array
3. For each chunk, count keyword matches (case-insensitive substring)
4. Score chunks by match count
5. Sort by score descending
6. Return top N (default 10)

**Returns**:
```typescript
Array<{
  title: string;      // Document title
  chunk: string;      // The chunk text
  tags: string | null; // Document tags
}>
```

**Limitations**:
- No embeddings (simple keyword matching)
- No semantic understanding
- Tag filtering is document-level, not chunk-level

### Document Management

**`ingestDocument()`**: Takes content, splits into chunks, stores document + chunks JSON

**`listDocuments()`**: Returns all documents with metadata

**`deleteDocument()`**: Removes document by ID

### Current Knowledge Base

- **46 documents** ingested (as of 2026-02-26)
- **Topics**: cold email copy, Loom outreach, Clay workflows, LinkedIn, lead gen, GTM strategy
- **Ingestion CLI**: `scripts/ingest-document.ts`

---

## 7. AGENT FRAMEWORK & RUNNER

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/agents/runner.ts` (116 lines)

### Agent Execution Pattern

**`runAgent<TOutput>(config: AgentConfig, userMessage: string, options?)`**

**Process**:
1. Create `AgentRun` record (audit logging)
2. Call `generateText()` with:
   - Model from config
   - System prompt from config
   - User message
   - Tools from config
   - Stop condition: `stepCountIs(config.maxSteps ?? 10)`
3. Extract tool calls and results from response steps
4. Try to parse structured output from response text:
   - First tries triple-backtick JSON: ` ```json\n{...}\n``` `
   - Falls back to raw text as JSON
   - Falls back to raw text if not JSON
5. Update `AgentRun` record with output, steps, duration
6. Return typed result

### AgentConfig Interface

```typescript
interface AgentConfig {
  name: string; // "research" | "leads" | "writer" | "campaign"
  model: "claude-opus-4-20250514" | "claude-sonnet-4-20250514" | "claude-haiku-4-5-20251001";
  systemPrompt: string;
  tools: Record<string, Tool>;
  maxSteps?: number; // default 10
}
```

### AgentRunResult Type

```typescript
interface AgentRunResult<TOutput> {
  output: TOutput;           // Parsed/typed output
  text: string;              // Raw text response from model
  steps: ToolCallStep[];     // Array of tool calls + results
  durationMs: number;        // Execution time
}
```

### Database Audit Log (AgentRun)

- `agent` field captures which agent ran
- `input` and `output` stored as JSON strings
- `steps` captured for debugging tool call chains
- `status`: "running" | "complete" | "failed"
- `triggeredBy`: "orchestrator" | "cli" | "api" | "pipeline"
- Indexed by `[agent, workspaceSlug]` and `[status]`

---

## 8. LEADS AGENT ARCHITECTURE (as Template for Campaign)

**File**: `/Users/jjay/programs/outsignal-agents/src/lib/agents/leads.ts` (228 lines)

### Agent Structure Pattern

**Layer 1: Agent Definition** (leads.ts)
- Define tools with Zod schemas
- System prompt with clear instructions
- Export `runLeadsAgent()` function
- Export `leadsConfig` and `leadsTools`

**Layer 2: Operations Layer** (leads/operations.ts)
- Pure business logic functions
- Database queries via Prisma
- Return typed results (not raw DB records)
- NO tool logic in operations (operations are reusable)

**Layer 3: Tools** (leads.ts)
- Thin wrappers around operations
- Convert operation results to tool responses
- Handle errors gracefully

### Leads Agent Tools (lines 9-146)

1. **searchPeople**: calls `operations.searchPeople(params)`
2. **createList**: calls `operations.createList(params)`
3. **addPeopleToList**: calls `operations.addPeopleToList(listId, personIds)`
4. **getList**: calls `operations.getList(listId)`
5. **getLists**: calls `operations.getLists(params)`
6. **scoreList**: calls `operations.scoreList(listId, workspaceSlug)` — **COSTS CREDITS**
7. **exportListToEmailBison**: calls `operations.exportListToEmailBison(listId, workspaceSlug)` — **COSTS CREDITS**

### Key Pattern: Operations Module

**Location**: `/Users/jjay/programs/outsignal-agents/src/lib/leads/operations.ts`

**Principle**: All Prisma queries and business logic **live in operations.ts**, not in the agent tool closures.

**Benefits**:
- Operations can be reused by multiple agents or API routes
- Easier to test
- Clear separation of concerns
- Can be called by MCP tools later

**For Phase 8**: Create `/Users/jjay/programs/outsignal-agents/src/lib/campaigns/operations.ts` with:
- `createCampaign(params)`
- `addLeadsToCampaign(campaignId, personWorkspaceIds)`
- `getCampaign(id)`
- `listCampaigns(workspaceSlug)`
- `generateReplysuggestion(campaignId, replyContext)` ← For webhook integration
- `publishCampaignToDashboard(campaignId)` ← Move to client review
- `deployToCampaignEmailBison(campaignId)` ← Launch campaign

---

## 9. API ROUTE PATTERNS

### Pattern 1: List & Create Routes

**File**: `/Users/jjay/programs/outsignal-agents/src/app/api/lists/route.ts`

**GET /api/lists**
- Query params: `?q=` (name search), `?workspace=` (workspace filter)
- Returns: JSON array of lists with enrichment stats
- No auth required (implicit; data is keyed by workspaceSlug)

**POST /api/lists**
- Body: `{ name, workspaceSlug, description }`
- Validation: name and workspaceSlug required
- Returns: `201 { list }`

### Pattern 2: Detail & Delete Routes

**File**: `/Users/jjay/programs/outsignal-agents/src/app/api/lists/[id]/route.ts`

**GET /api/lists/[id]**
- Params: `id` (TargetList ID)
- Query: `?page=` (pagination, default 1)
- Returns: Full list detail + paginated people array + summary stats
- Includes: enrichment summary (withEmail, withLinkedin, withCompany counts)

**DELETE /api/lists/[id]**
- Removes the list (cascade deletes join records via Prisma)

### Pattern 3: Export Routes

**File**: `/Users/jjay/programs/outsignal-agents/src/app/api/lists/[id]/export/route.ts`

**GET /api/lists/[id]/export**
- No auth required (implicit)
- Returns: CSV file download
- Validates all members have verified emails (verification gate)
- If any unverified, returns 400 with error message
- Response headers: `Content-Type: text/csv`, `Content-Disposition: attachment`

### Workspace Ownership Enforcement

**Current approach**: Uses `workspaceSlug` string field (NOT a FK)
- Routes accept `workspaceSlug` as query param or request body
- **No runtime validation** of whether user owns workspace
- This is OK for internal dashboard (auth is admin password)
- Would need middleware for client-facing routes

**For Phase 8**: Campaign CRUD routes would follow same pattern:
- POST `/api/campaigns` — body: `{ name, workspaceSlug, ... }`
- GET `/api/campaigns?workspace=slug` — filter by workspace
- GET `/api/campaigns/[id]` — detail endpoint
- PATCH `/api/campaigns/[id]` — update (e.g., approve drafts)
- DELETE `/api/campaigns/[id]` — delete

---

## 10. CHAT ROUTE & ORCHESTRATOR INTEGRATION

**File**: `/Users/jjay/programs/outsignal-agents/src/app/api/chat/route.ts` (45 lines)

### Chat Route Behavior

**POST /api/chat**

**Input**:
```json
{
  "messages": [...],  // Vercel AI SDK message format
  "context": {
    "pathname": "/workspace/rise",
    "workspaceSlug": "rise"
  }
}
```

**Processing**:
1. Receive message array + context
2. Convert to model messages with tools: `convertToModelMessages(messages, { tools: orchestratorTools })`
3. Call `streamText()` with:
   - Model: `orchestratorConfig.model` (claude-sonnet-4-20250514)
   - System prompt: `buildSystemPrompt(context)` — adds current pathname/workspace as context hints
   - Tools: `orchestratorTools` (all delegation + dashboard tools)
   - Stop condition: `stepCountIs(12)` max steps
4. Stream response back as `toUIMessageStreamResponse()`

**Key insight**:
- The chat route is stateless (no session, no auth, just delegation to orchestrator)
- Context (workspace slug) is passed in request body
- Tools are evaluated on each turn, agent decides what to call
- When agent calls `delegateToWriter`, the Writer Agent runs independently

### How Delegation Works

When orchestrator tool (e.g., `delegateToWriter`) is called:
1. Tool's `execute()` function is invoked immediately
2. It calls `runWriterAgent(input)` which:
   - Calls `runAgent<WriterOutput>(writerConfig, userMessage, { workspaceSlug })`
   - This creates an AgentRun record
   - Writer Agent runs independently with its own tools
   - Returns typed WriterOutput to the orchestrator
3. Orchestrator receives result and includes it in response text

---

## 11. IMPLEMENTATION ROADMAP FOR PHASE 8

Based on research, here's the dependency chain for Phase 8:

### Step 1: Database Schema
Add Campaign & CampaignLead models to schema.prisma (lines to add after TargetList/TargetListPerson)

### Step 2: Operations Layer
Create `/src/lib/campaigns/operations.ts` following the Leads Agent pattern:
- `createCampaign(workspaceSlug, name, targetListId?, description?): Promise<Campaign>`
- `getCampaign(id): Promise<CampaignDetail>`
- `listCampaigns(workspaceSlug): Promise<CampaignSummary[]>`
- `addLeadsToCampaign(campaignId, personWorkspaceIds): Promise<{ added, skipped }>`
- `updateCampaignStatus(campaignId, status): Promise<Campaign>`
- `publishCampaignForReview(campaignId): Promise<Campaign>`
- `deployCampaignToEmailBison(campaignId): Promise<{ emailBisonCampaignId }>`

### Step 3: Campaign Agent
Create `/src/lib/agents/campaign.ts`:
- Import tools that wrap operations (createCampaign, addLeads, getCampaign, etc.)
- Add tools for EmailBison interaction (createEmailBisonCampaign, assignSequenceSteps)
- System prompt: "Campaign Agent manages campaign lifecycle: creation, lead assignment, EmailBison sync"
- Configuration with maxSteps

### Step 4: Orchestrator Tool
Update `/src/lib/agents/orchestrator.ts`:
- Replace stub `delegateToCampaign` with real implementation calling `runCampaignAgent()`
- Add Campaign Agent import

### Step 5: Writer Agent Reply Suggestion
Update `/src/lib/agents/writer.ts`:
- Add new tool: `generateReplySuggestion(workspaceSlug, campaignId, replyEmail, replySubject, replyBody)`
- Tool logic: fetch campaign/lead context, call Writer Agent in "suggestion mode", return markdown

### Step 6: Webhook Integration
Update `/src/app/api/webhooks/emailbison/route.ts`:
- On LEAD_REPLIED or LEAD_INTERESTED:
  - Extract campaign context
  - Call reply suggestion generation (if enabled)
  - Include suggested response in Slack/email notifications

### Step 7: API Routes
Create:
- `/api/campaigns` — GET list, POST create
- `/api/campaigns/[id]` — GET detail, PATCH update, DELETE remove
- `/api/campaigns/[id]/leads` — GET list, POST add
- `/api/campaigns/[id]/publish` — POST move to review
- `/api/campaigns/[id]/deploy` — POST send to EmailBison

### Step 8: UI Updates (out of scope for this research)
- Campaign creation form
- Lead assignment UI
- Draft approval/feedback UI
- Launch confirmation UI

---

## SUMMARY TABLE: Critical Files & Their Roles

| File | Lines | Purpose | Key for Phase 8 |
|------|-------|---------|-----------------|
| prisma/schema.prisma | 538 | Database schema | Add Campaign & CampaignLead models |
| src/lib/agents/writer.ts | 395 | Writer Agent + saveDraft tool | Hooks into campaign drafts |
| src/lib/agents/orchestrator.ts | 525 | Central orchestrator + delegateToWriter | Replace delegateToCampaign stub |
| src/lib/agents/types.ts | 129 | Type definitions | Add CampaignInput/Output |
| src/lib/agents/runner.ts | 116 | Agent execution engine | Unchanged (core framework) |
| src/lib/leads/operations.ts | ~400 | Operations template | Copy pattern for campaigns/operations.ts |
| src/app/api/webhooks/emailbison/route.ts | 138 | Webhook ingestion | Add reply suggestion dispatch |
| src/lib/notifications.ts | 127 | Slack/email notifications | Add suggested response block |
| src/lib/knowledge/store.ts | 186 | Knowledge base search | Used by Writer Agent (unchanged) |
| src/app/api/lists/route.ts | 117 | API route pattern | Template for /api/campaigns routes |
| src/app/api/chat/route.ts | 45 | Orchestrator chat entrypoint | Unchanged (works with new agent) |

---

## CONCLUSION

The codebase is well-structured for Phase 8 implementation. Key takeaways:

1. **No existing Campaign model** — Phase 8 will be the first "native" local Campaign entity (prior workflow used EmailBison campaigns + string references)

2. **EmailDraft already exists** — Writer Agent drafts are already captured; Campaign model just ties them together

3. **Clear layering** — Operations ↔ Tools ↔ Agents pattern enables clean code and reusability

4. **Webhook context ready** — All needed context is available for reply suggestions (email, name, subject, body, campaign)

5. **Pattern precedents** — Leads Agent is a perfect template for Campaign Agent structure

6. **No auth enforcement** — Routes use `workspaceSlug` string ownership (fine for admin dashboard)

This research document provides the foundation to execute Phase 8 with confidence.
