---
phase: 08-campaign-entity-writer
plan: "03"
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/lib/campaigns/operations.ts
autonomous: true
requirements:
  - CAMP-02
  - CAMP-05

must_haves:
  truths:
    - "Campaign CRUD operations exist as a shared operations layer (same pattern as leads/operations.ts)"
    - "createCampaign enforces workspace ownership and validates workspace exists"
    - "updateCampaignStatus validates transitions against the state machine (invalid transitions return error)"
    - "getCampaign returns full campaign detail with TargetList info and sequence data"
    - "publishForReview transitions status to pending_approval and sets publishedAt timestamp"
  artifacts:
    - path: "src/lib/campaigns/operations.ts"
      provides: "Campaign CRUD and lifecycle operations"
      exports: ["createCampaign", "getCampaign", "listCampaigns", "updateCampaign", "updateCampaignStatus", "deleteCampaign", "publishForReview", "saveCampaignSequences"]
  key_links:
    - from: "src/lib/campaigns/operations.ts"
      to: "prisma/schema.prisma (Campaign)"
      via: "prisma.campaign CRUD queries"
      pattern: "prisma\\.campaign\\."
    - from: "src/lib/campaigns/operations.ts"
      to: "prisma/schema.prisma (Workspace)"
      via: "workspace existence check on create"
      pattern: "prisma\\.workspace\\.findUnique"
---

<objective>
Create the Campaign operations layer following the established leads/operations.ts pattern — all Prisma queries and business logic for campaigns centralized in one module.

Purpose: Agent tools, API routes, and future MCP tools will be thin wrappers around these operations. Centralizing prevents logic divergence (lesson from Phase 7.1).
Output: src/lib/campaigns/operations.ts with 8 exported functions.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-campaign-entity-writer/08-CONTEXT.md
@.planning/phases/08-campaign-entity-writer/08-01-SUMMARY.md

<interfaces>
<!-- Pattern to follow: leads/operations.ts -->

From src/lib/leads/operations.ts:
```typescript
// Result types are exported interfaces at the top
export interface PersonSearchResult { ... }
export interface SearchPeopleParams { ... }

// Functions: query Prisma, return typed results
export async function searchPeople(params: SearchPeopleParams): Promise<...>
export async function createList(params: ...): Promise<TargetList>
export async function getList(listId: string): Promise<...>
export async function getLists(params: ...): Promise<...>
export async function scoreList(listId: string, workspaceSlug: string, options?: ...): Promise<...>
export async function exportListToEmailBison(listId: string, workspaceSlug: string): Promise<...>
```

<!-- Campaign model from Plan 01 (will exist after Plan 01 executes) -->
Campaign model fields (from 08-01-PLAN):
- id, name, workspaceSlug, description, status, channels (JSON array)
- targetListId (FK to TargetList)
- emailSequence (JSON), linkedinSequence (JSON)
- leadsApproved, leadsFeedback, leadsApprovedAt
- contentApproved, contentFeedback, contentApprovedAt
- emailBisonCampaignId, emailBisonSequenceId
- publishedAt, deployedAt, createdAt, updatedAt

Status transitions:
draft -> internal_review -> pending_approval -> approved -> deployed -> active
active -> paused -> active
any -> completed
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Campaign operations layer with CRUD and lifecycle functions</name>
  <files>src/lib/campaigns/operations.ts</files>
  <action>
Create `src/lib/campaigns/operations.ts` following the leads/operations.ts pattern. ALL Prisma queries live here — no business logic in agent tools or API routes.

**Exported types:**

```typescript
export interface CreateCampaignParams {
  workspaceSlug: string;
  name: string;
  description?: string;
  channels?: string[]; // ["email"], ["linkedin"], or ["email", "linkedin"]
  targetListId?: string;
}

export interface UpdateCampaignParams {
  name?: string;
  description?: string;
  channels?: string[];
  targetListId?: string;
}

export interface CampaignSummary {
  id: string;
  name: string;
  workspaceSlug: string;
  status: string;
  channels: string[];
  targetListName: string | null;
  leadsApproved: boolean;
  contentApproved: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface CampaignDetail extends CampaignSummary {
  description: string | null;
  emailSequence: unknown[] | null; // parsed JSON
  linkedinSequence: unknown[] | null; // parsed JSON
  targetListId: string | null;
  targetListPeopleCount: number;
  leadsFeedback: string | null;
  leadsApprovedAt: Date | null;
  contentFeedback: string | null;
  contentApprovedAt: Date | null;
  emailBisonCampaignId: number | null;
  publishedAt: Date | null;
  deployedAt: Date | null;
}
```

**Exported functions (8 total):**

1. `createCampaign(params: CreateCampaignParams): Promise<CampaignDetail>`
   - Validate workspace exists (findUnique by slug, throw if not found)
   - Default channels to `["email"]` if not provided
   - Create campaign with `prisma.campaign.create()`
   - Store channels as `JSON.stringify(channels)`
   - Return formatted CampaignDetail

2. `getCampaign(id: string): Promise<CampaignDetail | null>`
   - Find by id, include targetList with _count of people
   - Parse channels, emailSequence, linkedinSequence from JSON strings
   - Return formatted CampaignDetail or null

3. `listCampaigns(workspaceSlug: string): Promise<CampaignSummary[]>`
   - Find all campaigns for workspace, ordered by updatedAt desc
   - Include targetList for name
   - Parse channels from JSON for each

4. `updateCampaign(id: string, params: UpdateCampaignParams): Promise<CampaignDetail>`
   - Update only provided fields
   - If channels provided, JSON.stringify before storing
   - Return updated CampaignDetail

5. `updateCampaignStatus(id: string, newStatus: string): Promise<CampaignDetail>`
   - Implement state machine validation:
   ```typescript
   const VALID_TRANSITIONS: Record<string, string[]> = {
     draft: ["internal_review"],
     internal_review: ["pending_approval", "draft"],
     pending_approval: ["approved", "internal_review"],
     approved: ["deployed"],
     deployed: ["active"],
     active: ["paused", "completed"],
     paused: ["active", "completed"],
   };
   // Also allow any -> completed
   ```
   - Fetch current campaign, check current status
   - If transition not in VALID_TRANSITIONS[currentStatus] and newStatus !== "completed", throw Error with descriptive message
   - Update and return

6. `deleteCampaign(id: string): Promise<void>`
   - Delete campaign by id
   - Only allow deletion in "draft" or "internal_review" status (throw error otherwise)

7. `publishForReview(id: string): Promise<CampaignDetail>`
   - Validate current status allows transition to "pending_approval" (must be in "internal_review")
   - Validate campaign has emailSequence or linkedinSequence (at least one non-null)
   - Validate campaign has targetListId (leads must be linked)
   - Update status to "pending_approval", set publishedAt to now()
   - Return updated CampaignDetail

8. `saveCampaignSequences(id: string, data: { emailSequence?: unknown[]; linkedinSequence?: unknown[] }): Promise<CampaignDetail>`
   - Store provided sequences as JSON.stringify on the campaign
   - Only update provided fields (skip null/undefined)
   - Return updated CampaignDetail

**IMPORTANT:** Follow the zero-Prisma-in-agents pattern. All queries here, agent tools will be thin wrappers.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>src/lib/campaigns/operations.ts exists with 8 exported functions and 4 exported types, follows leads/operations.ts pattern, TypeScript compiles without errors, state machine validates transitions</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. operations.ts exports: createCampaign, getCampaign, listCampaigns, updateCampaign, updateCampaignStatus, deleteCampaign, publishForReview, saveCampaignSequences
3. State machine rejects invalid transitions (e.g., draft -> approved throws)
4. createCampaign validates workspace existence
5. publishForReview validates campaign has content and leads
6. Zero raw SQL — all Prisma client calls
</verification>

<success_criteria>
Campaign operations layer is complete with all 8 functions, typed interfaces, and state machine validation. Follows the established leads/operations.ts pattern exactly.
</success_criteria>

<output>
After completion, create `.planning/phases/08-campaign-entity-writer/08-03-SUMMARY.md`
</output>
