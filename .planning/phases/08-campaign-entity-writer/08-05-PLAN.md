---
phase: 08-campaign-entity-writer
plan: "05"
type: execute
wave: 3
depends_on:
  - "08-03"
  - "08-04"
files_modified:
  - src/lib/agents/campaign.ts
  - src/lib/agents/orchestrator.ts
  - src/lib/agents/types.ts
  - src/app/api/campaigns/route.ts
  - src/app/api/campaigns/[id]/route.ts
  - src/app/api/campaigns/[id]/publish/route.ts
autonomous: true
requirements:
  - CAMP-03
  - CAMP-05
  - WRITER-03

must_haves:
  truths:
    - "Admin types 'create a campaign for Rise using the fintech CTO list' in Cmd+J and a Campaign record is created with TargetList linked"
    - "Admin types 'write email sequence for this campaign' and the orchestrator delegates to writer agent with campaign context"
    - "Admin can review content in chat and give feedback for iteration"
    - "Admin types 'push this campaign for client approval' and status transitions to pending_approval"
    - "Campaign CRUD API routes exist at /api/campaigns/* with workspace ownership enforcement"
    - "Campaign agent delegation in orchestrator is fully functional (replaces stub)"
  artifacts:
    - path: "src/lib/agents/campaign.ts"
      provides: "Campaign agent with tools for create, manage, and promote campaigns"
      exports: ["runCampaignAgent", "campaignConfig", "campaignTools"]
    - path: "src/app/api/campaigns/route.ts"
      provides: "GET list and POST create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/campaigns/[id]/route.ts"
      provides: "GET detail, PATCH update, DELETE remove endpoints"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/campaigns/[id]/publish/route.ts"
      provides: "POST publish for client review endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/lib/agents/campaign.ts"
      to: "src/lib/campaigns/operations.ts"
      via: "thin tool wrappers around operations functions"
      pattern: "operations\\.(createCampaign|getCampaign|listCampaigns)"
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/campaign.ts"
      via: "delegateToCampaign executes runCampaignAgent"
      pattern: "runCampaignAgent"
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/writer.ts"
      via: "delegateToWriter passes campaignId for campaign-aware writing"
      pattern: "campaignId"
---

<objective>
Create the Campaign Agent, wire it into the orchestrator (replacing the stub), build CRUD API routes, and enable the full Cmd+J workflow: create campaign -> generate content -> iterate -> push for approval.

Purpose: This is the central UX plan — the admin can now manage the full campaign lifecycle through natural language chat.
Output: Campaign agent, live orchestrator delegation, CRUD API routes, campaign-aware content generation via Cmd+J.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-campaign-entity-writer/08-CONTEXT.md
@.planning/phases/08-campaign-entity-writer/08-03-SUMMARY.md
@.planning/phases/08-campaign-entity-writer/08-04-SUMMARY.md

<interfaces>
<!-- Campaign operations from Plan 03 -->
From src/lib/campaigns/operations.ts:
```typescript
export async function createCampaign(params: CreateCampaignParams): Promise<CampaignDetail>
export async function getCampaign(id: string): Promise<CampaignDetail | null>
export async function listCampaigns(workspaceSlug: string): Promise<CampaignSummary[]>
export async function updateCampaign(id: string, params: UpdateCampaignParams): Promise<CampaignDetail>
export async function updateCampaignStatus(id: string, newStatus: string): Promise<CampaignDetail>
export async function deleteCampaign(id: string): Promise<void>
export async function publishForReview(id: string): Promise<CampaignDetail>
export async function saveCampaignSequences(id: string, data: {...}): Promise<CampaignDetail>
```

<!-- Leads operations for list lookup -->
From src/lib/leads/operations.ts:
```typescript
export async function getLists(params: { workspaceSlug: string }): Promise<ListSummary[]>
export async function getList(listId: string): Promise<ListDetail | null>
```

<!-- Orchestrator stub to replace -->
From src/lib/agents/orchestrator.ts (lines 143-161):
```typescript
const delegateToCampaign = tool({
  description: "Delegate a task to the Campaign Agent...",
  inputSchema: z.object({
    workspaceSlug: z.string(),
    task: z.string(),
    campaignName: z.string().optional(),
  }),
  execute: async () => {
    return { status: "not_available", message: "..." };
  },
});
```

<!-- Writer delegation for campaign-aware writing -->
From src/lib/agents/orchestrator.ts:
```typescript
const delegateToWriter = tool({
  ...
  inputSchema: z.object({
    workspaceSlug: z.string(),
    task: z.string(),
    channel: z.enum([...]).optional(),
    campaignName: z.string().optional(),
    feedback: z.string().optional(),
  }),
  ...
});
```

<!-- Agent pattern from leads.ts -->
Pattern: tools -> system prompt -> config -> runXxxAgent() -> buildXxxMessage() -> exports
```typescript
export async function runLeadsAgent(input: LeadsInput): Promise<LeadsOutput> {
  const userMessage = buildLeadsMessage(input);
  const result = await runAgent<LeadsOutput>(leadsConfig, userMessage, { ... });
  return result.output;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Campaign Agent with tools</name>
  <files>src/lib/agents/campaign.ts, src/lib/agents/types.ts</files>
  <action>
Create `src/lib/agents/campaign.ts` following the exact pattern from leads.ts.

**Update CampaignInput in types.ts** (replace existing stub):
```typescript
export interface CampaignInput {
  workspaceSlug: string;
  task: string;
  campaignId?: string;    // For operations on existing campaign
  campaignName?: string;  // For creating or finding by name
}

export interface CampaignOutput {
  action: string; // "create" | "list" | "get" | "update" | "publish" | "generate_content" | "unknown"
  summary: string;
  campaignId?: string;
  data?: unknown;
}
```

**Campaign Agent tools (6 tools, all wrapping operations.ts):**

1. `createCampaign` — wraps `operations.createCampaign()`. Input: workspaceSlug, name, description?, channels?, targetListId?. Agent confirms details before creating (system prompt instruction). If user mentions a list by name, the agent should find the list ID first.

2. `getCampaign` — wraps `operations.getCampaign()`. Input: campaignId. Returns full detail.

3. `listCampaigns` — wraps `operations.listCampaigns()`. Input: workspaceSlug. Returns summary list.

4. `findTargetList` — wraps `operations.getLists()` from leads operations. Input: workspaceSlug, nameFilter?. Helps agent resolve list names to IDs when user says "use the fintech CTO list".

5. `updateCampaignStatus` — wraps `operations.updateCampaignStatus()`. Input: campaignId, newStatus. Agent uses this for internal status transitions.

6. `publishForReview` — wraps `operations.publishForReview()`. Input: campaignId. Transitions to pending_approval. System prompt tells agent to confirm with admin before publishing. After publishing, agent should mention that client notification would fire (Phase 9 will implement the actual notification).

**System prompt for Campaign Agent:**
- You are the Campaign Agent — manages campaign lifecycle for Outsignal
- You can create campaigns, link TargetLists, update status, and publish for client review
- When creating: always confirm campaign details (name, list, channels) with the admin before calling createCampaign
- Content generation is separate — the orchestrator delegates that to the Writer Agent
- When admin says "push for approval", use publishForReview and confirm it was published
- Campaign context is tracked implicitly — "this campaign" refers to the last-mentioned campaign

**Agent config:**
- name: "campaign"
- model: "claude-sonnet-4-20250514" (Sonnet — campaign ops are structured, not creative)
- maxSteps: 8

**Export:** `runCampaignAgent`, `campaignConfig`, `campaignTools`
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Campaign agent created with 6 tools wrapping operations layer, CampaignInput/Output types updated, runCampaignAgent entry point exported, follows leads.ts pattern exactly</done>
</task>

<task type="auto">
  <name>Task 2: Wire Campaign Agent into orchestrator and update writer delegation</name>
  <files>src/lib/agents/orchestrator.ts</files>
  <action>
**Step 1: Replace delegateToCampaign stub with real implementation.**

Replace the stub `delegateToCampaign` tool (lines 143-161) with:

```typescript
const delegateToCampaign = tool({
  description:
    "Delegate a task to the Campaign Agent. Use this when the user wants to: create a campaign, list campaigns, get campaign details, link a target list to a campaign, or push a campaign for client approval. The Campaign Agent handles all campaign lifecycle operations.",
  inputSchema: z.object({
    workspaceSlug: z.string().describe("Workspace slug"),
    task: z.string().describe("What you want the Campaign Agent to do"),
    campaignId: z.string().optional().describe("Campaign ID (for operations on existing campaign)"),
    campaignName: z.string().optional().describe("Campaign name (for creating or finding)"),
  }),
  execute: async ({ workspaceSlug, task, campaignId, campaignName }) => {
    try {
      const result = await runCampaignAgent({ workspaceSlug, task, campaignId, campaignName });
      return {
        status: "complete",
        action: result.action,
        summary: result.summary,
        campaignId: result.campaignId,
        data: result.data,
      };
    } catch (error) {
      return {
        status: "failed",
        error: error instanceof Error ? error.message : "Campaign Agent failed",
      };
    }
  },
});
```

Add import: `import { runCampaignAgent } from "./campaign";`

**Step 2: Update delegateToWriter to pass campaignId.**

Update the delegateToWriter tool's inputSchema to add:
```typescript
campaignId: z.string().optional().describe("Campaign ID — pass this when generating content for a specific campaign"),
```

Update the execute function to pass campaignId to runWriterAgent:
```typescript
const result = await runWriterAgent({
  workspaceSlug, task, channel, campaignName, feedback, campaignId,
});
```

**Step 3: Update orchestrator system prompt.**

Update the ORCHESTRATOR_SYSTEM_PROMPT to:
- Change `delegateToCampaign` from "(coming soon)" to active description
- Add guidance for campaign workflow:
  ```
  ## Campaign Workflow (Cmd+J):
  - "Create a campaign for Rise" → delegateToCampaign (creates Campaign entity)
  - "Write email sequence for this campaign" → delegateToWriter (with campaignId)
  - "Make step 2 shorter" → delegateToWriter (with feedback + campaignId)
  - "Write LinkedIn messages" → delegateToWriter (with channel=linkedin + campaignId)
  - "Push for client approval" → delegateToCampaign (publishes for review)

  When the user creates a campaign and then asks to generate content, pass the campaignId from the create response to the writer delegation. Track the active campaign context.
  ```
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | head -20 && grep -c "runCampaignAgent" src/lib/agents/orchestrator.ts</automated>
  </verify>
  <done>delegateToCampaign is live (not a stub), delegateToWriter passes campaignId, orchestrator system prompt includes campaign workflow guidance, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 3: Create Campaign CRUD API routes</name>
  <files>src/app/api/campaigns/route.ts, src/app/api/campaigns/[id]/route.ts, src/app/api/campaigns/[id]/publish/route.ts</files>
  <action>
Create Campaign API routes following the exact pattern from `src/app/api/lists/route.ts`.

**1. `src/app/api/campaigns/route.ts`:**

```typescript
// GET /api/campaigns?workspace=slug — list campaigns for workspace
// POST /api/campaigns — create new campaign
```

GET handler:
- Extract `workspace` from query params (required — return 400 if missing)
- Call `listCampaigns(workspace)` from operations
- Return JSON: `{ campaigns: CampaignSummary[] }`

POST handler:
- Extract `{ name, workspaceSlug, description, channels, targetListId }` from body
- Validate name and workspaceSlug are present (return 400 if not)
- Call `createCampaign(params)` from operations
- Return 201 with `{ campaign: CampaignDetail }`
- Wrap in try/catch, return 500 on error

**2. `src/app/api/campaigns/[id]/route.ts`:**

```typescript
// GET /api/campaigns/[id] — campaign detail
// PATCH /api/campaigns/[id] — update campaign
// DELETE /api/campaigns/[id] — delete campaign
```

GET handler:
- Extract `id` from params
- Call `getCampaign(id)` from operations
- Return 404 if null, otherwise JSON: `{ campaign: CampaignDetail }`

PATCH handler:
- Extract `id` from params, body fields: `{ name?, description?, channels?, targetListId? }`
- Call `updateCampaign(id, body)` from operations
- Return JSON: `{ campaign: CampaignDetail }`

DELETE handler:
- Extract `id` from params
- Call `deleteCampaign(id)` from operations
- Return 204 on success
- Catch error for non-draft deletion attempts, return 400

**3. `src/app/api/campaigns/[id]/publish/route.ts`:**

```typescript
// POST /api/campaigns/[id]/publish — push campaign for client review
```

POST handler:
- Extract `id` from params
- Call `publishForReview(id)` from operations
- Return JSON: `{ campaign: CampaignDetail, message: "Campaign published for client review" }`
- Catch validation errors (missing content, wrong status), return 400

**Workspace ownership enforcement (CAMP-05):**
All list/detail endpoints verify the campaign's workspaceSlug matches the request context. For now (admin dashboard only), this is implicit through the query filter. The client portal (Phase 9) will add explicit session-based enforcement.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>Campaign CRUD API routes exist at /api/campaigns, /api/campaigns/[id], and /api/campaigns/[id]/publish. All routes use operations layer (zero inline Prisma). TypeScript compiles.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Campaign agent has 6 tools, all wrapping operations.ts
3. Orchestrator's delegateToCampaign calls runCampaignAgent (not a stub)
4. Orchestrator's delegateToWriter passes campaignId
5. POST /api/campaigns creates a campaign record
6. GET /api/campaigns?workspace=rise returns campaign list
7. GET /api/campaigns/[id] returns campaign detail
8. POST /api/campaigns/[id]/publish transitions to pending_approval
9. DELETE /api/campaigns/[id] only works for draft/internal_review
</verification>

<success_criteria>
Admin can create campaigns, generate content, iterate, and push for approval entirely through Cmd+J chat. Campaign CRUD API routes are functional with workspace ownership. The full campaign lifecycle is operational through natural language.
</success_criteria>

<output>
After completion, create `.planning/phases/08-campaign-entity-writer/08-05-SUMMARY.md`
</output>
