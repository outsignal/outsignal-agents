---
phase: 08-campaign-entity-writer
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
autonomous: true
requirements:
  - CAMP-01
  - CAMP-02
  - CAMP-04

must_haves:
  truths:
    - "Campaign model exists in Prisma schema with full status lifecycle (draft, internal_review, pending_approval, approved, deployed, active, paused, completed)"
    - "Campaign has a 1:1 link to TargetList via targetListId"
    - "Campaign stores email and LinkedIn sequences as JSON columns"
    - "Campaign has separate approval fields for leads and content (each with approved boolean, feedback text, timestamp)"
    - "Campaign has channel selection as an array field supporting email, linkedin, or both"
    - "Status transition map is documented as a comment in the schema for reference"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Campaign model with all fields and indexes"
      contains: "model Campaign"
  key_links:
    - from: "prisma/schema.prisma (Campaign)"
      to: "prisma/schema.prisma (Workspace)"
      via: "workspaceSlug -> Workspace.slug relation"
      pattern: "workspace\\s+Workspace\\s+@relation"
    - from: "prisma/schema.prisma (Campaign)"
      to: "prisma/schema.prisma (TargetList)"
      via: "targetListId -> TargetList.id relation"
      pattern: "targetList\\s+TargetList"
---

<objective>
Add the Campaign model to Prisma schema as a first-class entity owning leads (via TargetList) and content (via JSON sequence columns), with the full status lifecycle and separate lead/content approval fields.

Purpose: Campaign is the core entity for Phase 8-10 — everything (content generation, client review, deployment) hangs off this model.
Output: Updated prisma/schema.prisma with Campaign model, `prisma db push` applied to production DB.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-campaign-entity-writer/08-CONTEXT.md

<interfaces>
<!-- Existing models that Campaign needs to relate to -->

From prisma/schema.prisma:
```prisma
model Workspace {
  id       String  @id @default(cuid())
  slug     String  @unique
  name     String
  ...
  senders Sender[]
}

model TargetList {
  id            String   @id @default(cuid())
  name          String
  workspaceSlug String
  description   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  people TargetListPerson[]
  @@index([workspaceSlug])
}

model EmailDraft {
  id              String   @id @default(cuid())
  workspaceSlug   String
  campaignName    String
  channel         String   @default("email")
  sequenceStep    Int
  ...
  @@index([workspaceSlug, campaignName])
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Campaign model to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the Campaign model after the TargetListPerson model (before the LinkedIn Sequencer section). The model must include:

**Identity and ownership:**
- `id` String @id @default(cuid())
- `name` String — campaign name (admin-provided)
- `workspaceSlug` String — FK to Workspace.slug
- `description` String? — optional campaign description

**Status lifecycle:**
- `status` String @default("draft") — valid values: "draft" | "internal_review" | "pending_approval" | "approved" | "deployed" | "active" | "paused" | "completed"
- Add a comment block above the status field documenting the valid transitions:
  draft -> internal_review -> pending_approval -> approved -> deployed -> active -> paused -> completed
  (also: active -> paused -> active, any -> completed)

**Channel selection:**
- `channels` String @default("[\"email\"]") — JSON array of channels: ["email"], ["linkedin"], or ["email", "linkedin"]

**Lead ownership:**
- `targetListId` String? — FK to TargetList.id (nullable until list linked)
- `targetList` TargetList? @relation(fields: [targetListId], references: [id])

**Content storage (JSON columns per user decision):**
- `emailSequence` String? — JSON: array of { position, subjectLine, subjectVariantB?, body, delayDays, notes? }
- `linkedinSequence` String? — JSON: array of { position, type, body, delayDays, notes? }

**Separate approval fields (CAMP-04):**
- `leadsApproved` Boolean @default(false)
- `leadsFeedback` String?
- `leadsApprovedAt` DateTime?
- `contentApproved` Boolean @default(false)
- `contentFeedback` String?
- `contentApprovedAt` DateTime?

**EmailBison linkage (for Phase 10 deploy):**
- `emailBisonCampaignId` Int? — nullable until deployed
- `emailBisonSequenceId` Int?

**Timestamps:**
- `createdAt` DateTime @default(now())
- `updatedAt` DateTime @updatedAt
- `publishedAt` DateTime? — when pushed for client review
- `deployedAt` DateTime? — when deployed to EmailBison/LinkedIn

**Relation:**
- `workspace` Workspace @relation(fields: [workspaceSlug], references: [slug])

**Indexes:**
- @@index([workspaceSlug])
- @@index([status])
- @@unique([workspaceSlug, name]) — prevent duplicate campaign names per workspace

Also add a `campaigns Campaign[]` relation field to the Workspace model (add after `senders Sender[]`).

Also add a `campaigns Campaign[]` relation field to the TargetList model (add after `people TargetListPerson[]`).
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx prisma validate 2>&1 | head -20</automated>
  </verify>
  <done>Campaign model exists in schema.prisma with all specified fields, relations to Workspace and TargetList are valid, prisma validate passes with no errors</done>
</task>

<task type="auto">
  <name>Task 2: Push schema to database</name>
  <files>prisma/schema.prisma</files>
  <action>
Run `npx prisma db push` to apply the Campaign model to the production Neon database. This is safe — it adds a new table with no data migration needed (additive change only).

Then run `npx prisma generate` to regenerate the Prisma client with the new Campaign type.

Verify the Campaign model is accessible by running a quick node script:
```bash
cd /Users/jjay/programs/outsignal-agents && node -e "const { PrismaClient } = require('@prisma/client'); const p = new PrismaClient(); p.campaign.count().then(c => { console.log('Campaign count:', c); p.\$disconnect(); }).catch(e => { console.error(e); p.\$disconnect(); })"
```
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && node -e "const { PrismaClient } = require('@prisma/client'); const p = new PrismaClient(); p.campaign.count().then(c => { console.log('OK: Campaign count =', c); process.exit(0); }).catch(e => { console.error('FAIL:', e.message); process.exit(1); })"</automated>
  </verify>
  <done>Campaign table exists in Neon database, Prisma client can query it, count returns 0 (empty table as expected)</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes with no errors
2. Campaign model has all 20+ fields specified in the task
3. Workspace model has `campaigns Campaign[]` relation
4. TargetList model has `campaigns Campaign[]` relation
5. Campaign table accessible via Prisma client (count query returns 0)
6. Status field defaults to "draft"
7. Channels field defaults to `["email"]`
8. Both approval field sets exist (leads + content)
</verification>

<success_criteria>
Campaign model is a first-class entity in the Prisma schema with status lifecycle, channel selection, TargetList ownership, JSON sequence columns, separate lead/content approval fields, and EmailBison linkage fields. Database has been pushed and Prisma client regenerated.
</success_criteria>

<output>
After completion, create `.planning/phases/08-campaign-entity-writer/08-01-SUMMARY.md`
</output>
