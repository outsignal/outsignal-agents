---
phase: 07-leads-agent-dashboard
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/lib/agents/leads.ts
  - src/lib/agents/types.ts
autonomous: true
requirements: [LEAD-01, LEAD-02, LEAD-03, LEAD-04, LEAD-06]

must_haves:
  truths:
    - "Leads Agent has tools for searchPeople, createList, addPeopleToList, getList, getLists, scoreList, exportListToEmailBison"
    - "Each tool is a thin wrapper calling the corresponding operations.ts function — no Prisma queries in tool closures"
    - "Leads Agent system prompt instructs friendly-but-brief tone with credit-gate awareness"
    - "runLeadsAgent() calls runAgent() which auto-creates AgentRun audit record"
    - "LeadsInput and LeadsOutput types are updated in types.ts to match the new agent"
  artifacts:
    - path: "src/lib/agents/leads.ts"
      provides: "Leads Agent configuration, tools, and runLeadsAgent() entry point"
      exports: ["runLeadsAgent", "leadsConfig", "leadsTools"]
      min_lines: 120
    - path: "src/lib/agents/types.ts"
      provides: "Updated LeadsInput/LeadsOutput types"
      contains: "LeadsInput"
  key_links:
    - from: "src/lib/agents/leads.ts"
      to: "src/lib/leads/operations.ts"
      via: "import * as operations"
      pattern: "import.*from.*leads/operations"
    - from: "src/lib/agents/leads.ts"
      to: "src/lib/agents/runner.ts"
      via: "import runAgent"
      pattern: "import.*runAgent.*from.*runner"
---

<objective>
Build the Leads Agent — specialist agent with tools wrapping the operations layer.

Purpose: LEAD-01 through LEAD-04 require the admin to search, create lists, score, and export from chat. LEAD-06 requires audit trail logging. This plan creates the agent that powers all of those capabilities via the `runAgent()` framework.

Output: `src/lib/agents/leads.ts` (agent config + tools + runLeadsAgent) and updated `src/lib/agents/types.ts`.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-leads-agent-dashboard/07-RESEARCH.md
@.planning/phases/07-leads-agent-dashboard/07-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 output: src/lib/leads/operations.ts -->
<!-- Executor should read the actual file, but these are the expected exports: -->
```typescript
// src/lib/leads/operations.ts
export async function searchPeople(params: SearchPeopleParams): Promise<SearchPeopleResult>
export async function createList(params: CreateListParams): Promise<TargetList>
export async function addPeopleToList(listId: string, personIds: string[]): Promise<AddPeopleResult>
export async function getList(listId: string): Promise<ListDetail>
export async function getLists(params: GetListsParams): Promise<ListsResult>
export async function scoreList(listId: string, workspaceSlug: string): Promise<ScoreListResult>
export async function exportListToEmailBison(listId: string, workspaceSlug: string): Promise<ExportResult>
```

<!-- From src/lib/agents/runner.ts: -->
```typescript
export async function runAgent<TOutput = unknown>(
  config: AgentConfig,
  userMessage: string,
  options?: { triggeredBy?: string; workspaceSlug?: string },
): Promise<AgentRunResult<TOutput>>
```

<!-- From src/lib/agents/types.ts: -->
```typescript
export interface AgentConfig {
  name: string;
  model: "claude-opus-4-20250514" | "claude-sonnet-4-20250514" | "claude-haiku-4-5-20251001";
  systemPrompt: string;
  tools: Record<string, Tool>;
  maxSteps?: number;
}

export interface AgentRunResult<TOutput = unknown> {
  output: TOutput;
  text: string;
  steps: ToolCallStep[];
  durationMs: number;
}
```

<!-- From src/lib/agents/research.ts — pattern to follow: -->
```typescript
const researchTools = { /* ... tool definitions ... */ };
const researchConfig: AgentConfig = { name: "research", model: "...", systemPrompt: PROMPT, tools: researchTools, maxSteps: 8 };
export async function runResearchAgent(input: ResearchInput): Promise<ResearchOutput> {
  const userMessage = buildResearchMessage(input);
  const result = await runAgent<ResearchOutput>(researchConfig, userMessage, { triggeredBy: "cli", workspaceSlug: input.workspaceSlug });
  return result.output;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update LeadsInput and LeadsOutput types</name>
  <files>src/lib/agents/types.ts</files>
  <action>
Update the existing `LeadsInput` and `LeadsOutput` interfaces in `src/lib/agents/types.ts`.

Replace the current LeadsInput:
```typescript
export interface LeadsInput {
  workspaceSlug: string;
  task: string;
  limit?: number;
  sources?: string[];
}
```

With:
```typescript
export interface LeadsInput {
  workspaceSlug?: string;
  task: string;
  conversationContext?: string; // Prior search results or list context for refinement
}
```

Replace the current LeadsOutput:
```typescript
export interface LeadsOutput {
  leadsFound: number;
  leadsImported: number;
  leadsEnriched: number;
  duplicatesSkipped: number;
  sourceSummary: Record<string, number>;
  topLeads: { name: string; company: string; score: number }[];
}
```

With:
```typescript
export interface LeadsOutput {
  action: string; // "search" | "create_list" | "add_to_list" | "score" | "export" | "get_list" | "list_lists" | "unknown"
  summary: string; // Human-readable summary of what was done
  data?: unknown; // The raw result data from the operation
}
```

The LeadsOutput is intentionally loose because the Leads Agent is a conversational agent — it returns text descriptions and may call multiple tools. The structured output is parsed from agent text by the runner.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/lib/agents/types.ts 2>&1 | head -10</automated>
  </verify>
  <done>
    - LeadsInput has workspaceSlug (optional), task (required), conversationContext (optional)
    - LeadsOutput has action, summary, data fields
    - No other types in the file are modified
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Leads Agent with tools and system prompt</name>
  <files>src/lib/agents/leads.ts</files>
  <action>
Create `src/lib/agents/leads.ts` following the pattern in `src/lib/agents/research.ts`.

**Tools** — Each is a thin wrapper over `operations.ts`. Import: `import * as operations from "@/lib/leads/operations";`

1. **searchPeople** tool:
   - Description: "Search people in the database by criteria. Use for: finding leads by title, vertical, company, location, ICP score. Searches are FREE (no credit cost). Returns up to 25 results per page with ICP scores where available."
   - inputSchema: z.object with query?, jobTitle?, vertical?, location?, workspaceSlug?, minIcpScore?, hasVerifiedEmail?, page?, limit? (default 25)
   - execute: `return operations.searchPeople(params)`

2. **createList** tool:
   - Description: "Create a new target list for a workspace. Use after a search to save results."
   - inputSchema: z.object with name (required), workspaceSlug (required), description?
   - execute: `return operations.createList(params)`

3. **addPeopleToList** tool:
   - Description: "Add people to an existing target list by their IDs. Deduplicates automatically."
   - inputSchema: z.object with listId (required), personIds (string array, required)
   - execute: `return operations.addPeopleToList(listId, personIds)`

4. **getList** tool:
   - Description: "Get details of a target list including all people and their enrichment data."
   - inputSchema: z.object with listId (required)
   - execute: `return operations.getList(listId)`

5. **getLists** tool:
   - Description: "List all target lists, optionally filtered by workspace."
   - inputSchema: z.object with workspaceSlug?, query?
   - execute: `return operations.getLists(params)`

6. **scoreList** tool:
   - Description: "Score all unscored people in a target list against the workspace ICP criteria. Skips already-scored people. COSTS CREDITS (Firecrawl + Claude Haiku per person). Always show the user how many will be scored before proceeding."
   - inputSchema: z.object with listId (required), workspaceSlug (required)
   - execute: `return operations.scoreList(listId, workspaceSlug)`

7. **exportListToEmailBison** tool:
   - Description: "Export verified leads from a target list to the EmailBison workspace. Only exports people with verified emails. If unverified people exist, returns a count and asks user to verify first. COSTS CREDITS for verification. Leads are uploaded to the workspace — campaign assignment must be done manually in EmailBison."
   - inputSchema: z.object with listId (required), workspaceSlug (required)
   - execute: `return operations.exportListToEmailBison(listId, workspaceSlug)`

**System Prompt** — `LEADS_SYSTEM_PROMPT`:
```
You are the Outsignal Leads Agent — a specialist for managing the lead pipeline through natural language.

## Capabilities
You can: search people, create target lists, add people to lists, score leads against ICP criteria, and export verified leads to EmailBison.

## Interaction Rules
- Break multi-step flows into separate steps. Complete one action, show results, then suggest next steps.
- CREDIT GATE: Searches are free. Scoring and export COST CREDITS. Always preview counts before running scoring or export. Say how many people will be scored/exported and ask for confirmation.
- For search results, present as a compact table: Name | Title | Company | Email Status | ICP Score | Vertical
- After search results, suggest next actions: "Want to: [Add to a list] [Score these] [Export]"
- ICP scores include a one-line reason (e.g. "85 — title match, verified email, target vertical")

## Conversational Refinement
The conversation history may contain previous search results. When the user says things like "narrow to London only" or "filter to fintech", refine the previous search with additional filters rather than starting from scratch.

## Voice
Friendly but brief. Warm and efficient, light personality. Examples:
- "Nice — found 47 CTOs in fintech! 32 have verified emails. Want to build a list?"
- "No results for CTOs in fintech in Lagos. Try broadening: drop the location, or try 'technology' instead of 'fintech'?"

## Error Handling
- Empty results: suggest refinements
- Unrecognized queries: show capabilities list
- API failures: report transparently + offer retry
- Missing ICP criteria: tell user to configure it first

## Important Notes
- Export to EmailBison means uploading leads to the workspace lead list. There is NO API to assign leads to a campaign — that must be done manually in EmailBison UI.
- When scoring, only unscored people are scored. Already-scored people are skipped (no wasted credits).
```

**Agent Config**:
```typescript
const leadsConfig: AgentConfig = {
  name: "leads",
  model: "claude-sonnet-4-20250514",
  systemPrompt: LEADS_SYSTEM_PROMPT,
  tools: leadsTools,
  maxSteps: 8,
};
```

**runLeadsAgent function**:
```typescript
export async function runLeadsAgent(input: LeadsInput): Promise<LeadsOutput> {
  const userMessage = buildLeadsMessage(input);
  const result = await runAgent<LeadsOutput>(leadsConfig, userMessage, {
    triggeredBy: "orchestrator",
    workspaceSlug: input.workspaceSlug,
  });
  return result.output;
}

function buildLeadsMessage(input: LeadsInput): string {
  const parts: string[] = [];
  if (input.workspaceSlug) parts.push(`Workspace: ${input.workspaceSlug}`);
  if (input.conversationContext) parts.push(`Context: ${input.conversationContext}`);
  parts.push("", `Task: ${input.task}`);
  return parts.join("\n");
}
```

Export: `leadsConfig`, `leadsTools`, `runLeadsAgent`.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/lib/agents/leads.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - `src/lib/agents/leads.ts` exists with 7 tools, system prompt, config, and runLeadsAgent()
    - Every tool execute() delegates to operations.ts — no Prisma imports in this file
    - System prompt includes credit-gate instructions, conversational refinement, and voice guidelines
    - runLeadsAgent() calls runAgent() which auto-creates AgentRun (LEAD-06 satisfied)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for both `src/lib/agents/leads.ts` and `src/lib/agents/types.ts`
- `grep -c "prisma\." src/lib/agents/leads.ts` returns 0 (no direct Prisma usage — all through operations.ts)
- `grep -c "operations\." src/lib/agents/leads.ts` returns >= 7 (one per tool)
- `grep "runAgent" src/lib/agents/leads.ts` shows runAgent is called in runLeadsAgent()
</verification>

<success_criteria>
- Leads Agent has all 7 tools matching the operations layer functions
- No business logic lives in tool closures — all delegated to operations.ts
- System prompt enforces credit-gate, conversational refinement, and friendly-brief voice per CONTEXT.md decisions
- AgentRun audit trail is automatic via runAgent() (LEAD-06)
</success_criteria>

<output>
After completion, create `.planning/phases/07-leads-agent-dashboard/07-02-SUMMARY.md`
</output>
