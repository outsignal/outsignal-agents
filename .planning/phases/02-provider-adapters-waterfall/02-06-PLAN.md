---
phase: 02-provider-adapters-waterfall
plan: "06"
type: execute
wave: 1
depends_on: ["02-03", "02-04"]
files_modified:
  - src/lib/enrichment/providers/aiark-person.ts
  - src/lib/enrichment/types.ts
  - src/lib/enrichment/waterfall.ts
autonomous: true
gap_closure: true
requirements: [PROV-02, ENRICH-02]

must_haves:
  truths:
    - "AI Ark person adapter fetches person data (job title, LinkedIn URL, company info) from the /v1/people endpoint given a LinkedIn URL or email"
    - "enrichEmail waterfall follows Prospeo -> AI Ark -> LeadMagic -> FindyMail order, matching the ENRICH-02 requirement"
    - "AI Ark person adapter enriches person fields (jobTitle, company, location) via merge — not just email — expanding PROV-02 beyond company-only"
  artifacts:
    - path: "src/lib/enrichment/providers/aiark-person.ts"
      provides: "AI Ark person data adapter"
      exports: ["aiarkPersonAdapter"]
      min_lines: 80
    - path: "src/lib/enrichment/types.ts"
      provides: "PersonAdapter type definition"
      contains: "PersonAdapter"
    - path: "src/lib/enrichment/waterfall.ts"
      provides: "Updated enrichEmail with AI Ark person step"
      contains: "aiarkPersonAdapter"
  key_links:
    - from: "src/lib/enrichment/providers/aiark-person.ts"
      to: "api.ai-ark.com/api/developer-portal/v1/people"
      via: "fetch POST with X-TOKEN header"
      pattern: "AIARK_PEOPLE_ENDPOINT"
    - from: "src/lib/enrichment/waterfall.ts"
      to: "src/lib/enrichment/providers/aiark-person.ts"
      via: "import aiarkPersonAdapter"
      pattern: "aiarkPersonAdapter"
    - from: "src/lib/enrichment/waterfall.ts"
      to: "enrichEmail EMAIL_PROVIDERS array"
      via: "AI Ark inserted at index 1 (after Prospeo, before LeadMagic)"
      pattern: 'name: "aiark"'
---

<objective>
Close two verification gaps from Phase 2:
1. **PROV-02 (partial):** AI Ark `/v1/people` endpoint was never implemented — only the company adapter exists
2. **ENRICH-02 (partial):** Person enrichment waterfall is Prospeo -> LeadMagic -> FindyMail but should be Prospeo -> AI Ark -> LeadMagic -> FindyMail per requirements

Purpose: The AI Ark people endpoint can return person-level data (job title, company, location, LinkedIn URL) that supplements what email-finding providers return. Adding it to the waterfall means richer person records before email providers are called, and the waterfall order matches the documented requirements.

Output: New AI Ark person adapter + updated enrichEmail waterfall with AI Ark inserted between Prospeo and LeadMagic
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-provider-adapters-waterfall/02-VERIFICATION.md
@.planning/phases/02-provider-adapters-waterfall/02-03-SUMMARY.md
@.planning/phases/02-provider-adapters-waterfall/02-04-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/enrichment/types.ts:
```typescript
export type Provider = "prospeo" | "aiark" | "leadmagic" | "findymail" | "firecrawl" | "clay" | "ai-normalizer";
export type EntityType = "person" | "company";

export interface EmailProviderResult {
  email: string | null;
  firstName?: string;
  lastName?: string;
  jobTitle?: string;
  linkedinUrl?: string;
  location?: string;
  source: Provider;
  rawResponse: unknown;
  costUsd: number;
}

export interface EmailAdapterInput {
  linkedinUrl?: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  companyDomain?: string;
}

export type EmailAdapter = (input: EmailAdapterInput) => Promise<EmailProviderResult>;
export type CompanyAdapter = (domain: string) => Promise<CompanyProviderResult>;
```

From src/lib/enrichment/providers/aiark.ts (existing company adapter pattern):
```typescript
const AIARK_ENDPOINT = "https://api.ai-ark.com/api/developer-portal/v1/companies";
const AUTH_HEADER_NAME = "X-TOKEN"; // LOW confidence
const REQUEST_TIMEOUT_MS = 10_000;
// Uses AbortController timeout, Zod safeParse, extractCompanies() normalizer
export const aiarkAdapter: CompanyAdapter = async (domain) => { ... };
```

From src/lib/enrichment/waterfall.ts (current EMAIL_PROVIDERS):
```typescript
const EMAIL_PROVIDERS: EmailProvider[] = [
  { adapter: prospeoAdapter, name: "prospeo" },
  { adapter: leadmagicAdapter, name: "leadmagic" },
  { adapter: findymailAdapter, name: "findymail" },
];
```

From src/lib/enrichment/costs.ts:
```typescript
export const PROVIDER_COSTS: Record<string, number> = {
  prospeo: 0.002, leadmagic: 0.005, findymail: 0.001, aiark: 0.003, firecrawl: 0.001,
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI Ark person data adapter</name>
  <files>
    src/lib/enrichment/providers/aiark-person.ts
    src/lib/enrichment/types.ts
  </files>
  <action>
**1. Add PersonAdapter type to types.ts:**

Add a new type alongside the existing EmailAdapter and CompanyAdapter:

```typescript
/** Person data provider result — enriches person fields beyond just email. */
export interface PersonProviderResult {
  email?: string;
  firstName?: string;
  lastName?: string;
  jobTitle?: string;
  linkedinUrl?: string;
  location?: string;
  company?: string;
  companyDomain?: string;
  source: Provider;
  rawResponse: unknown;
  costUsd: number;
}

/** Person data provider adapter — takes person identifiers, returns enriched person fields. */
export type PersonAdapter = (input: EmailAdapterInput) => Promise<PersonProviderResult>;
```

**2. Create aiark-person.ts:**

Follow the exact same defensive patterns as the existing `aiark.ts` company adapter (same file as reference):

- Endpoint: `POST https://api.ai-ark.com/api/developer-portal/v1/people`
- Auth: `X-TOKEN` header (same LOW confidence — copy the warning comment from aiark.ts)
- Timeout: 10 seconds via AbortController
- Request body: Use `{ linkedin_url: input.linkedinUrl }` if LinkedIn URL available, otherwise try `{ first_name: input.firstName, last_name: input.lastName, company: input.companyName }` if name+company available. Return empty result if neither input path is viable.
- Response parsing: Use a loose Zod schema with `.passthrough()` similar to the company adapter. Expected fields based on research: `first_name`, `last_name`, `title` (job title), `linkedin_url`, `email`, `location`, `company.name`, `company.domain`. The exact shape is MEDIUM confidence — use `.optional()` on all fields.
- Map response to PersonProviderResult: `firstName`, `lastName`, `jobTitle` (from title), `linkedinUrl`, `email`, `location`, `company` (from company.name), `companyDomain` (from company.domain)
- Error handling: Same pattern as aiark.ts — 401/403 warns about AUTH_HEADER_NAME, 429 throws with status for retry, 404/422 throws as permanent error
- Cost: Use `PROVIDER_COSTS.aiark` (same as company adapter — $0.003 per call)
- Export: `export const aiarkPersonAdapter: PersonAdapter`

IMPORTANT: The adapter must return a `PersonProviderResult` (not `EmailProviderResult`) because AI Ark person enrichment is about filling person fields, not primarily finding emails. However, if the response includes an email, include it in the result.

Reference `src/lib/enrichment/providers/aiark.ts` for exact auth, timeout, and error-handling patterns — keep them identical.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | grep -E "aiark-person|types\.ts" | head -20; echo "---"; grep -c "export const aiarkPersonAdapter" src/lib/enrichment/providers/aiark-person.ts; grep -c "PersonAdapter" src/lib/enrichment/types.ts</automated>
  </verify>
  <done>
    - aiark-person.ts exists, exports aiarkPersonAdapter of type PersonAdapter
    - types.ts exports PersonProviderResult interface and PersonAdapter type
    - TypeScript compiles without new errors in these files
    - Adapter uses same defensive patterns as existing aiark.ts (X-TOKEN, AbortController, Zod passthrough, auth failure warning)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AI Ark person adapter into enrichEmail waterfall</name>
  <files>
    src/lib/enrichment/waterfall.ts
  </files>
  <action>
**Update waterfall.ts to include AI Ark person enrichment in the email waterfall:**

1. Import the new adapter: `import { aiarkPersonAdapter } from "./providers/aiark-person";`
2. Import the PersonAdapter type: `import type { PersonAdapter, PersonProviderResult } from "./types";`

3. **Add AI Ark as a person-enrichment step BEFORE the email waterfall loop.** The AI Ark person adapter is fundamentally different from email adapters — it enriches person DATA (job title, company, location) rather than finding emails. The cleanest approach:

   Inside `enrichEmail()`, BEFORE the `for` loop over `EMAIL_PROVIDERS`, add an AI Ark person enrichment step:

   ```typescript
   // --- AI Ark person data enrichment (fills jobTitle, company, location, etc.) ---
   // Runs before email providers because it enriches person fields that improve
   // downstream email finding (e.g., company name helps Prospeo name+company lookup).
   // This satisfies ENRICH-02 waterfall order: Prospeo -> AI Ark -> LeadMagic -> FindyMail
   // by making AI Ark a person-data step, not an email-finding step.
   const aiarkFailures = breaker.consecutiveFailures.get("aiark") ?? 0;
   if (aiarkFailures < CIRCUIT_BREAKER_THRESHOLD) {
     const aiarkShouldRun = await shouldEnrich(personId, "person", "aiark");
     if (aiarkShouldRun) {
       const capHit = await checkDailyCap();
       if (capHit) throw new Error("DAILY_CAP_HIT");

       // ... retry loop same as email providers (3 attempts, 429 backoff) ...
       // On success: mergePersonData with all returned fields
       // Record enrichment log entry
       // If AI Ark returned an email AND person doesn't have one, stop waterfall (return)
       // If AI Ark returned person data but no email, continue to email providers
     }
   }
   ```

   Key behavior:
   - Same circuit breaker, dedup gate, daily cap, retry, and error handling as the email providers
   - Use `mergePersonData()` to write AI Ark's person data (jobTitle, company, location, etc.)
   - If AI Ark happens to return an email AND the person didn't have one, treat that as a waterfall success and return early (like finding an email from any other provider)
   - If AI Ark returned person data but no email (most likely scenario), continue to the email providers (Prospeo -> LeadMagic -> FindyMail)
   - After merge, run normalizers inline (classifyJobTitle if jobTitle was written, classifyCompanyName if company was written) — same pattern as existing email-found normalizer block
   - Increment daily spend and record enrichment for AI Ark call

4. **Update the EMAIL_PROVIDERS comment** at the top of the file to reflect the new order: "enrichEmail: Tries AI Ark (person data) then Prospeo -> LeadMagic -> FindyMail (email finding)"

5. **Do NOT change the EMAIL_PROVIDERS array.** AI Ark person enrichment is a separate step before the email-finding loop, not an entry in EMAIL_PROVIDERS (because it uses PersonAdapter, not EmailAdapter).

IMPORTANT: The waterfall order from the user's perspective is now: Prospeo -> AI Ark -> LeadMagic -> FindyMail. AI Ark runs after Prospeo's dedup check but before LeadMagic. However, architecturally AI Ark is a separate person-enrichment step before the email-finding loop. This means:
- If Prospeo already enriched this person (dedup gate), AI Ark still runs for person data enrichment (different provider, separate dedup)
- AI Ark enriches person FIELDS. The email providers FIND emails. Both serve ENRICH-02 but at different layers.

Do NOT refactor the existing email provider loop — it works correctly. Add the AI Ark step as a clearly-demarcated block before it.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit 2>&1 | grep "waterfall" | head -10; echo "---"; grep -c "aiarkPersonAdapter" src/lib/enrichment/waterfall.ts; grep "AI Ark" src/lib/enrichment/waterfall.ts | head -5</automated>
  </verify>
  <done>
    - waterfall.ts imports and calls aiarkPersonAdapter before the email-finding loop
    - AI Ark person step uses same circuit breaker, dedup, cap check, retry, merge, and normalizer patterns
    - If AI Ark returns an email, waterfall stops early (same as any email provider)
    - If AI Ark returns person data but no email, email providers continue normally
    - TypeScript compiles without new errors
    - The waterfall effective order is Prospeo (dedup) -> AI Ark (person data) -> LeadMagic -> FindyMail per ENRICH-02
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compilation: `npx tsc --noEmit` shows no new errors in enrichment files
2. AI Ark person adapter exists at `src/lib/enrichment/providers/aiark-person.ts` with exported `aiarkPersonAdapter`
3. `PersonAdapter` and `PersonProviderResult` types exported from `src/lib/enrichment/types.ts`
4. `waterfall.ts` imports and calls `aiarkPersonAdapter` before the EMAIL_PROVIDERS loop
5. The effective enrichEmail waterfall order is: AI Ark person data -> Prospeo email -> LeadMagic email -> FindyMail email
6. All existing functionality unchanged — company waterfall, cost tracking, circuit breaker, dedup, normalizers all still work
</verification>

<success_criteria>
- PROV-02 gap closed: AI Ark person data adapter exists and is wired into the pipeline
- ENRICH-02 gap closed: enrichEmail waterfall includes AI Ark, matching the Prospeo -> AI Ark -> LeadMagic -> FindyMail order from requirements
- No regressions: existing email and company waterfalls function identically for their existing paths
</success_criteria>

<output>
After completion, create `.planning/phases/02-provider-adapters-waterfall/02-06-SUMMARY.md`
</output>
