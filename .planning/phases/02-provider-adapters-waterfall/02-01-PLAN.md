---
phase: 02-provider-adapters-waterfall
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/enrichment/types.ts
  - src/lib/enrichment/costs.ts
  - src/lib/enrichment/merge.ts
autonomous: true
requirements: [ENRICH-02, ENRICH-03, ENRICH-04]
user_setup:
  - service: enrichment-daily-cap
    why: "Cost controls for enrichment pipeline"
    env_vars:
      - name: ENRICHMENT_DAILY_CAP_USD
        source: "Set manually in Vercel env vars (default: 10.00 if not set)"

must_haves:
  truths:
    - "EnrichmentJob supports paused status with a resumeAt timestamp for daily cap enforcement"
    - "DailyCostTotal model tracks daily enrichment spend aggregated across all providers"
    - "EnrichmentLog stores workspaceSlug for per-workspace cost reporting"
    - "Provider adapter types define a clear contract for email and company enrichment"
    - "Merge functions only write to empty fields, never overwriting existing data"
    - "Cost config maps each provider to a fixed USD-per-call value"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "DailyCostTotal model, EnrichmentJob paused status + resumeAt, EnrichmentLog workspaceSlug"
      contains: "model DailyCostTotal"
    - path: "src/lib/enrichment/types.ts"
      provides: "EmailAdapter, CompanyAdapter, EmailProviderResult, CompanyProviderResult types"
      exports: ["EmailAdapter", "CompanyAdapter", "EmailProviderResult", "CompanyProviderResult"]
    - path: "src/lib/enrichment/costs.ts"
      provides: "PROVIDER_COSTS config, checkDailyCap, incrementDailySpend, todayUtc"
      exports: ["PROVIDER_COSTS", "checkDailyCap", "incrementDailySpend"]
    - path: "src/lib/enrichment/merge.ts"
      provides: "mergePersonData, mergeCompanyData — existing-data-wins merge logic"
      exports: ["mergePersonData", "mergeCompanyData"]
  key_links:
    - from: "src/lib/enrichment/costs.ts"
      to: "prisma.dailyCostTotal"
      via: "upsert on date key"
      pattern: "prisma\\.dailyCostTotal\\.upsert"
    - from: "src/lib/enrichment/merge.ts"
      to: "prisma.person / prisma.company"
      via: "read-then-write with empty field check"
      pattern: "prisma\\.(person|company)\\.(findUniqueOrThrow|update)"
---

<objective>
Schema migration, adapter type contracts, cost tracking config, and data merge logic — the foundation layer that all provider adapters and the waterfall orchestrator depend on.

Purpose: Establish the data contracts, cost controls, and merge rules before any provider adapter is written. This prevents schema drift, cost overruns, and data corruption in subsequent plans.
Output: Updated Prisma schema (pushed), extended types.ts with adapter interfaces, costs.ts with daily cap logic, merge.ts with existing-data-wins pattern.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-provider-adapters-waterfall/02-RESEARCH.md

@prisma/schema.prisma
@src/lib/enrichment/types.ts
@src/lib/enrichment/dedup.ts
@src/lib/enrichment/log.ts
@src/lib/enrichment/queue.ts
@src/lib/db.ts

<interfaces>
<!-- Existing Phase 1 types that this plan extends -->

From src/lib/enrichment/types.ts:
```typescript
export type Provider = "prospeo" | "aiark" | "leadmagic" | "findymail" | "firecrawl" | "clay" | "ai-normalizer";
export type EntityType = "person" | "company";
export type EnrichmentStatus = "success" | "error" | "skipped";
export interface EnrichmentResult {
  entityId: string; entityType: EntityType; provider: Provider;
  status: EnrichmentStatus; fieldsWritten: string[];
  costUsd?: number; errorMessage?: string;
}
```

From src/lib/enrichment/dedup.ts:
```typescript
export async function shouldEnrich(entityId: string, entityType: EntityType, provider: Provider): Promise<boolean>;
```

From src/lib/enrichment/log.ts:
```typescript
export async function recordEnrichment(params: {
  entityId: string; entityType: EntityType; provider: Provider;
  status?: EnrichmentStatus; fieldsWritten?: string[]; costUsd?: number;
  rawResponse?: unknown; errorMessage?: string;
}): Promise<void>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration — DailyCostTotal, EnrichmentJob paused, EnrichmentLog workspaceSlug</name>
  <files>prisma/schema.prisma</files>
  <action>
Add three schema changes to prisma/schema.prisma:

1. **New DailyCostTotal model** (after EnrichmentJob):
```prisma
model DailyCostTotal {
  id        String   @id @default(cuid())
  date      String   @unique // "YYYY-MM-DD" UTC
  totalUsd  Float    @default(0)
  breakdown String?  // JSON — per-provider breakdown { prospeo: 1.23, leadmagic: 0.45 }
  updatedAt DateTime @updatedAt
}
```

2. **EnrichmentJob** — add `resumeAt` field (nullable DateTime). The `status` field already accepts any string, so "paused" works without enum changes. Add `resumeAt` after `workspaceSlug`:
```prisma
  resumeAt      DateTime? // non-null when paused by daily cap; queue skips until this time
```

3. **EnrichmentLog** — add `workspaceSlug` field (nullable String) and a composite index for dashboard queries. Add after `errorMessage`:
```prisma
  workspaceSlug String?
  @@index([workspaceSlug, provider])
```

After editing the schema, run `npx prisma db push` (NOT migrate dev — project uses db push pattern, no migration history). Then run `npx prisma generate` to update the Prisma client.

Do NOT modify any existing fields or indexes. Only ADD new fields/models/indexes.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx prisma validate</automated>
  </verify>
  <done>DailyCostTotal model exists, EnrichmentJob has resumeAt field, EnrichmentLog has workspaceSlug field with index. Prisma client regenerated.</done>
</task>

<task type="auto">
  <name>Task 2: Extend types.ts with adapter interfaces + create costs.ts and merge.ts</name>
  <files>src/lib/enrichment/types.ts, src/lib/enrichment/costs.ts, src/lib/enrichment/merge.ts</files>
  <action>
**A) Extend `src/lib/enrichment/types.ts`** — add after the existing `EnrichmentResult` interface:

```typescript
/** Result from an email-finding provider adapter. */
export interface EmailProviderResult {
  email: string | null;
  firstName?: string;
  lastName?: string;
  jobTitle?: string;
  linkedinUrl?: string;
  location?: string;
  source: Provider;
  rawResponse: unknown;
  costUsd: number;
}

/** Result from a company data provider adapter. */
export interface CompanyProviderResult {
  name?: string;
  industry?: string;
  headcount?: number;
  description?: string;
  website?: string;
  location?: string;
  yearFounded?: number;
  source: Provider;
  rawResponse: unknown;
  costUsd: number;
}

/** Input for email-finding adapters. */
export interface EmailAdapterInput {
  linkedinUrl?: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  companyDomain?: string;
}

/** Email provider adapter — takes person info, returns email (or null). */
export type EmailAdapter = (input: EmailAdapterInput) => Promise<EmailProviderResult>;

/** Company provider adapter — takes domain, returns company data. */
export type CompanyAdapter = (domain: string) => Promise<CompanyProviderResult>;
```

Do NOT modify any existing types. Only add new ones.

**B) Create `src/lib/enrichment/costs.ts`**:

```typescript
/**
 * Cost tracking and daily cap enforcement for enrichment pipeline.
 * Provider costs are fixed values updated manually when pricing changes.
 */
import { prisma } from "@/lib/db";
import type { Provider } from "./types";

/** Fixed cost per API call by provider. Update when pricing changes. */
export const PROVIDER_COSTS: Record<string, number> = {
  prospeo: 0.002,
  leadmagic: 0.005,
  findymail: 0.001,
  aiark: 0.003,
  firecrawl: 0.001,
};

const DEFAULT_DAILY_CAP_USD = 10.0;

function getDailyCap(): number {
  return parseFloat(process.env.ENRICHMENT_DAILY_CAP_USD ?? String(DEFAULT_DAILY_CAP_USD));
}

/** Returns "YYYY-MM-DD" in UTC for today. */
export function todayUtc(): string {
  return new Date().toISOString().slice(0, 10);
}

/** Check if the daily enrichment spending cap has been reached. */
export async function checkDailyCap(): Promise<boolean> {
  const today = todayUtc();
  const record = await prisma.dailyCostTotal.findUnique({ where: { date: today } });
  return (record?.totalUsd ?? 0) >= getDailyCap();
}

/**
 * Increment today's spend by costUsd for the given provider.
 * Uses upsert — creates today's row if it doesn't exist.
 * Note: check + increment is NOT atomic. Accepts small overspend risk
 * (one chunk worth) rather than adding transaction overhead.
 */
export async function incrementDailySpend(provider: string, costUsd: number): Promise<void> {
  const today = todayUtc();

  // Upsert the daily total
  await prisma.dailyCostTotal.upsert({
    where: { date: today },
    update: { totalUsd: { increment: costUsd } },
    create: { date: today, totalUsd: costUsd },
  });
}
```

**C) Create `src/lib/enrichment/merge.ts`**:

```typescript
/**
 * "Existing data wins" merge strategy.
 * Only writes provider data to fields that are currently null/empty on the record.
 * Returns the list of field names that were actually written.
 */
import { prisma } from "@/lib/db";

/**
 * Merge provider data into a Person record.
 * Only fills null/empty fields — never overwrites existing data.
 */
export async function mergePersonData(
  personId: string,
  data: Partial<{
    email: string;
    firstName: string;
    lastName: string;
    jobTitle: string;
    linkedinUrl: string;
    location: string;
    phone: string;
    company: string;
    companyDomain: string;
  }>,
): Promise<string[]> {
  const person = await prisma.person.findUniqueOrThrow({ where: { id: personId } });

  const updates: Record<string, unknown> = {};
  const fieldsWritten: string[] = [];

  for (const [key, value] of Object.entries(data)) {
    if (value != null && value !== "" && (person as Record<string, unknown>)[key] == null) {
      updates[key] = value;
      fieldsWritten.push(key);
    }
  }

  if (Object.keys(updates).length > 0) {
    await prisma.person.update({ where: { id: personId }, data: updates });
  }

  return fieldsWritten;
}

/**
 * Merge provider data into a Company record.
 * Only fills null/empty fields — never overwrites existing data.
 */
export async function mergeCompanyData(
  domain: string,
  data: Partial<{
    name: string;
    industry: string;
    headcount: number;
    description: string;
    website: string;
    location: string;
    yearFounded: number;
    companyType: string;
  }>,
): Promise<string[]> {
  const company = await prisma.company.findUniqueOrThrow({ where: { domain } });

  const updates: Record<string, unknown> = {};
  const fieldsWritten: string[] = [];

  for (const [key, value] of Object.entries(data)) {
    if (value != null && value !== "" && (company as Record<string, unknown>)[key] == null) {
      updates[key] = value;
      fieldsWritten.push(key);
    }
  }

  if (Object.keys(updates).length > 0) {
    await prisma.company.update({ where: { domain }, data: updates });
  }

  return fieldsWritten;
}
```
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>types.ts exports EmailAdapter, CompanyAdapter, EmailProviderResult, CompanyProviderResult, EmailAdapterInput. costs.ts exports PROVIDER_COSTS, checkDailyCap, incrementDailySpend, todayUtc. merge.ts exports mergePersonData, mergeCompanyData. All compile without errors.</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes — schema is valid
2. `npx tsc --noEmit` — no type errors
3. DailyCostTotal model exists in schema with `date @unique` and `totalUsd Float`
4. EnrichmentJob has `resumeAt DateTime?` field
5. EnrichmentLog has `workspaceSlug String?` and `@@index([workspaceSlug, provider])`
6. types.ts has `EmailAdapter`, `CompanyAdapter`, `EmailProviderResult`, `CompanyProviderResult`, `EmailAdapterInput` exported
7. costs.ts has `PROVIDER_COSTS` object with all 5 provider costs, `checkDailyCap()`, `incrementDailySpend()`
8. merge.ts has `mergePersonData()` and `mergeCompanyData()` that only write null fields
</verification>

<success_criteria>
- Schema pushed successfully with DailyCostTotal model, EnrichmentJob.resumeAt, EnrichmentLog.workspaceSlug
- All new types compile and are exported
- PROVIDER_COSTS config is a simple object (easy to update when pricing changes)
- Merge functions check for null before writing (existing data wins)
</success_criteria>

<output>
After completion, create `.planning/phases/02-provider-adapters-waterfall/02-01-SUMMARY.md`
</output>
