---
phase: 07.1-leads-agent-integration-fixes
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/leads/operations.ts
  - src/lib/agents/orchestrator.ts
autonomous: true
requirements: [LEAD-04, LEAD-05]
gap_closure: true

must_haves:
  truths:
    - "Export to EmailBison returns actionable error when workspace exists but apiToken is null"
    - "delegateToLeads schema includes conversationContext and passes it through to runLeadsAgent"
    - "scoreList supports confirm=false dry-run that returns unscored count without calling Anthropic API"
  artifacts:
    - path: "src/lib/leads/operations.ts"
      provides: "apiToken null check in exportListToEmailBison, confirm gate in scoreList"
      contains: "Workspace.*not connected to EmailBison"
    - path: "src/lib/agents/orchestrator.ts"
      provides: "conversationContext field in delegateToLeads inputSchema"
      contains: "conversationContext"
  key_links:
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/leads.ts (runLeadsAgent)"
      via: "conversationContext param threaded through execute function"
      pattern: "runLeadsAgent.*conversationContext"
    - from: "src/lib/leads/operations.ts (scoreList)"
      to: "src/lib/icp/scorer.ts (scorePersonIcp)"
      via: "confirm gate — only calls scorer when confirm=true"
      pattern: "if.*!confirm"
---

<objective>
Three surgical fixes to close integration gaps from the v1.1 milestone audit: (1) actionable export error when apiToken is missing, (2) conversationContext wiring through the orchestrator, (3) score credit-gate with confirm parameter.

Purpose: Make the export flow trustworthy (LEAD-04), enable multi-turn conversational refinement, and add a code-level credit gate to scoreList that matches the MCP equivalent pattern. These fixes must land before Plan 02 (MCP migration) because the MCP score tool needs the confirm parameter in operations.scoreList.
Output: Updated operations.ts and orchestrator.ts with all three fixes.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/07.1-leads-agent-integration-fixes/07.1-RESEARCH.md

@src/lib/leads/operations.ts
@src/lib/agents/orchestrator.ts
@src/lib/agents/types.ts
@src/lib/agents/leads.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/agents/types.ts:
```typescript
export interface LeadsInput {
  workspaceSlug?: string;
  task: string;
  conversationContext?: string; // Prior search results or list context for refinement
}
```

From src/lib/leads/operations.ts:
```typescript
export interface ScoreListResult {
  scored: number;
  skipped: number;
  failed: number;
  results: ScoreResult[];
}

export interface ExportListResult {
  exported: number;
  alreadyExported: number;
  needsVerification: number;
  blocked: number;
  errors: string[];
}

export async function scoreList(
  listId: string,
  workspaceSlug: string,
): Promise<ScoreListResult>

export async function exportListToEmailBison(
  listId: string,
  workspaceSlug: string,
): Promise<ExportListResult>
```

From src/lib/agents/orchestrator.ts (delegateToLeads, lines 59-87):
```typescript
const delegateToLeads = tool({
  description: "Delegate a task to the Leads Agent...",
  inputSchema: z.object({
    workspaceSlug: z.string().optional().describe("Workspace slug..."),
    task: z.string().describe("What you want the Leads Agent to do..."),
  }),
  execute: async ({ workspaceSlug, task }) => {
    try {
      const result = await runLeadsAgent({ workspaceSlug, task });
      // ...
```

From src/lib/agents/leads.ts (current scoreList and export wrappers):
```typescript
// scoreList calls operations.scoreList(listId, workspaceSlug) — no confirm param
// exportListToEmailBison calls operations.exportListToEmailBison(listId, workspaceSlug)
```

From src/lib/workspaces.ts (the bug):
```typescript
// getWorkspaceBySlug returns undefined when dbWs.apiToken is null (line 80)
// getClientForWorkspace then throws "Workspace not found: ${slug}" — misleading
export async function getClientForWorkspace(slug: string): Promise<EmailBisonClient> {
  const workspace = await getWorkspaceBySlug(slug);
  if (!workspace) throw new Error(`Workspace not found: ${slug}`);
  return new EmailBisonClient(workspace.apiToken);
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add apiToken null check to exportListToEmailBison</name>
  <files>src/lib/leads/operations.ts</files>
  <action>
In `exportListToEmailBison()`, BEFORE the `const client = await getClientForWorkspace(workspaceSlug)` call (line 595), add a workspace lookup that checks for apiToken separately:

```typescript
// Check workspace exists and has API token configured
const wsRecord = await prisma.workspace.findUnique({
  where: { slug: workspaceSlug },
  select: { apiToken: true },
});
if (!wsRecord) {
  throw new Error(`Workspace not found: '${workspaceSlug}'`);
}
if (!wsRecord.apiToken) {
  throw new Error(
    `Workspace '${workspaceSlug}' is not connected to EmailBison. ` +
    `Set the API token in workspace settings to enable export.`
  );
}
```

Place this block after the readiness checks (after the `if (readiness.readyCount === 0)` early return) and before the `getClientForWorkspace` call. The `getClientForWorkspace` call stays — it will now always succeed because we pre-validated apiToken existence.

Do NOT modify `getClientForWorkspace` in `src/lib/workspaces.ts` — fix at the call site only.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | head -20</automated>
  </verify>
  <done>When workspace exists but apiToken is null, exportListToEmailBison throws "Workspace '{slug}' is not connected to EmailBison. Set the API token in workspace settings to enable export." instead of the misleading "Workspace not found".</done>
</task>

<task type="auto">
  <name>Task 2: Wire conversationContext through delegateToLeads</name>
  <files>src/lib/agents/orchestrator.ts</files>
  <action>
In the `delegateToLeads` tool definition (starts around line 59):

1. Add `conversationContext` to the Zod `inputSchema` object, after the `task` field:
```typescript
conversationContext: z
  .string()
  .optional()
  .describe(
    "Previous search results, list state, or conversation context. " +
    "Pass when the user is refining a prior result (e.g. 'narrow to London only'). " +
    "The Leads Agent uses this to avoid restarting from scratch."
  ),
```

2. Update the `execute` function signature to destructure `conversationContext`:
```typescript
execute: async ({ workspaceSlug, task, conversationContext }) => {
```

3. Pass `conversationContext` through to `runLeadsAgent`:
```typescript
const result = await runLeadsAgent({ workspaceSlug, task, conversationContext });
```

This is a 3-line change. `LeadsInput.conversationContext` is already declared in types.ts (line 69) and handled in `buildLeadsMessage()` in leads.ts (line 219). The only gap was the orchestrator not exposing or threading it.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | head -20</automated>
  </verify>
  <done>Orchestrator's delegateToLeads tool schema includes conversationContext field, and the execute function threads it to runLeadsAgent. Multi-turn refinement like "narrow to London" will now pass prior context instead of starting fresh.</done>
</task>

<task type="auto">
  <name>Task 3: Add confirm gate to scoreList in operations.ts</name>
  <files>src/lib/leads/operations.ts</files>
  <action>
Two changes in `src/lib/leads/operations.ts`:

1. **Add `unscoredCount` to `ScoreListResult` interface** (around line 103):
```typescript
export interface ScoreListResult {
  scored: number;
  skipped: number;
  failed: number;
  results: ScoreResult[];
  unscoredCount?: number; // Present when confirm=false (dry-run preview)
}
```

2. **Add `confirm` parameter to `scoreList` function** (around line 464):

Change the signature from:
```typescript
export async function scoreList(
  listId: string,
  workspaceSlug: string,
): Promise<ScoreListResult> {
```
to:
```typescript
export async function scoreList(
  listId: string,
  workspaceSlug: string,
  confirm: boolean = true,
): Promise<ScoreListResult> {
```

Default is `true` so existing callers (leads.ts agent wrapper at line 129: `operations.scoreList(listId, workspaceSlug)`) continue scoring immediately without any change.

3. **Add the dry-run early return** — after the `unscored` array and `skipped` counter are computed (after the `for (const member of members)` loop, around line 512), add:

```typescript
// Credit-gate: return count without scoring when confirm=false
if (!confirm) {
  return {
    scored: 0,
    skipped,
    failed: 0,
    results: [],
    unscoredCount: unscored.length,
  };
}
```

This goes BEFORE the `const CHUNK_SIZE = 5` line (the actual scoring loop). The scoring loop runs only when `confirm=true`.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | head -20</automated>
  </verify>
  <done>scoreList(listId, workspaceSlug, false) returns { scored: 0, skipped, failed: 0, results: [], unscoredCount: N } without calling scorePersonIcp. scoreList(listId, workspaceSlug) (no third arg) still scores immediately due to default true. MCP batch_score_list migration in Plan 02 can now call operations.scoreList with confirm=false for its dry-run path.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -n "not connected to EmailBison" src/lib/leads/operations.ts` returns the new error message
3. `grep -n "conversationContext" src/lib/agents/orchestrator.ts` shows the field in inputSchema and execute function
4. `grep -n "confirm" src/lib/leads/operations.ts` shows the parameter in scoreList signature and the dry-run early return
5. `grep -n "unscoredCount" src/lib/leads/operations.ts` shows the field in ScoreListResult and the dry-run return
</verification>

<success_criteria>
- TypeScript compiles cleanly
- exportListToEmailBison surfaces "not connected to EmailBison" error when apiToken is null
- delegateToLeads Zod schema includes conversationContext, threaded to runLeadsAgent
- scoreList accepts optional confirm parameter (default true), returns unscoredCount when confirm=false
- No changes to leads.ts agent wrapper (backward-compatible defaults)
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-leads-agent-integration-fixes/07.1-01-SUMMARY.md`
</output>
