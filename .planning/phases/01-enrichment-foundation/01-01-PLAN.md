---
phase: 01-enrichment-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/enrichment/types.ts
  - src/lib/enrichment/dedup.ts
  - src/lib/enrichment/log.ts
  - src/__tests__/enrichment-dedup.test.ts
autonomous: true
requirements: [ENRICH-01, ENRICH-06]
must_haves:
  truths:
    - "shouldEnrich returns false when a provider has already successfully enriched an entity, preventing duplicate paid API calls"
    - "shouldEnrich returns true when the only logs for an entity are errors, allowing retry"
    - "recordEnrichment writes a provenance row capturing provider, entityType, fieldsWritten, costUsd, and timestamp"
    - "EnrichmentLog and EnrichmentJob models exist in the database after migration"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "EnrichmentLog and EnrichmentJob models"
      contains: "model EnrichmentLog"
    - path: "src/lib/enrichment/types.ts"
      provides: "Provider, EntityType, EnrichmentResult types"
      exports: ["Provider", "EntityType", "EnrichmentResult"]
    - path: "src/lib/enrichment/dedup.ts"
      provides: "shouldEnrich function"
      exports: ["shouldEnrich"]
    - path: "src/lib/enrichment/log.ts"
      provides: "recordEnrichment function"
      exports: ["recordEnrichment"]
    - path: "src/__tests__/enrichment-dedup.test.ts"
      provides: "Unit tests for dedup and provenance"
      min_lines: 40
  key_links:
    - from: "src/lib/enrichment/dedup.ts"
      to: "prisma.enrichmentLog"
      via: "findFirst query on entityId+entityType+provider+status:success"
      pattern: "prisma\\.enrichmentLog\\.findFirst"
    - from: "src/lib/enrichment/log.ts"
      to: "prisma.enrichmentLog"
      via: "create call to write provenance row"
      pattern: "prisma\\.enrichmentLog\\.create"
---

<objective>
Create the enrichment schema foundation — two new Prisma models (EnrichmentLog, EnrichmentJob), shared type definitions, the dedup gate (`shouldEnrich`), and provenance recording (`recordEnrichment`) with unit tests.

Purpose: Every subsequent enrichment operation depends on these contracts. The dedup gate prevents duplicate paid API calls (ENRICH-01). The provenance log records who enriched what, when, and at what cost (ENRICH-06). The EnrichmentJob model is the schema for the async queue (used by Plan 03).

Output: Migrated database schema, type file, two library modules, one test file.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-enrichment-foundation/01-RESEARCH.md
@prisma/schema.prisma
@src/lib/db.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/db.ts:
```typescript
export const prisma = globalForPrisma.prisma || new PrismaClient();
```

From vitest.config.ts:
```typescript
// Tests live in src/__tests__/, use @/ alias, globals: true (describe/it/expect are global)
// Setup file: src/__tests__/setup.ts (mocks @/lib/db with vi.mock)
```

From existing test setup pattern (src/__tests__/setup.ts):
```typescript
vi.mock("@/lib/db", () => ({
  prisma: {
    // Add model mocks here
  },
}));
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration + type definitions</name>
  <files>prisma/schema.prisma, src/lib/enrichment/types.ts</files>
  <action>
1. Add two new models to `prisma/schema.prisma` at the bottom (before the closing comments, after EmailDraft):

```prisma
model EnrichmentLog {
  id           String   @id @default(cuid())
  entityId     String
  entityType   String   // "person" | "company"
  provider     String   // "prospeo" | "aiark" | "leadmagic" | "findymail" | "firecrawl" | "clay" | "ai-normalizer"
  status       String   @default("success") // "success" | "error" | "skipped"
  fieldsWritten String? // JSON array of field names written, e.g. ["email", "linkedinUrl"]
  costUsd      Float?   // provider cost in USD (null for free/AI calls)
  rawResponse  String?  // JSON — debug only, not indexed
  errorMessage String?  // populated when status = "error"
  runAt        DateTime @default(now())

  @@index([entityId, entityType])
  @@index([provider, status])
  @@index([runAt])
}

model EnrichmentJob {
  id             String   @id @default(cuid())
  entityType     String   // "person" | "company"
  provider       String   // provider to run
  status         String   @default("pending") // "pending" | "running" | "complete" | "failed"
  totalCount     Int
  processedCount Int      @default(0)
  chunkSize      Int      @default(50)
  entityIds      String   // JSON array of entity IDs to process
  errorLog       String?  // JSON array of { entityId, error } for failures
  workspaceSlug  String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([status])
}
```

2. Run the migration:
```bash
npx prisma migrate dev --name enrichment-foundation
```

3. Create `src/lib/enrichment/types.ts` with:

```typescript
/**
 * Enrichment pipeline type definitions.
 * Central source of truth for provider names, entity types, and enrichment results.
 */

/** Supported enrichment providers. "clay" is the legacy provider (existing webhook). */
export type Provider =
  | "prospeo"
  | "aiark"
  | "leadmagic"
  | "findymail"
  | "firecrawl"
  | "clay"
  | "ai-normalizer";

/** Entity types that can be enriched. */
export type EntityType = "person" | "company";

/** Status of an enrichment run. */
export type EnrichmentStatus = "success" | "error" | "skipped";

/** Result returned after recording an enrichment run. */
export interface EnrichmentResult {
  entityId: string;
  entityType: EntityType;
  provider: Provider;
  status: EnrichmentStatus;
  fieldsWritten: string[];
  costUsd?: number;
  errorMessage?: string;
}
```

Ensure the `src/lib/enrichment/` directory is created. Use `@/` absolute imports throughout.
  </action>
  <verify>
    <automated>npx prisma migrate status && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>EnrichmentLog and EnrichmentJob models exist in the database. types.ts exports Provider, EntityType, EnrichmentStatus, and EnrichmentResult. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Dedup gate, provenance logger, and unit tests</name>
  <files>src/lib/enrichment/dedup.ts, src/lib/enrichment/log.ts, src/__tests__/enrichment-dedup.test.ts, src/__tests__/setup.ts</files>
  <action>
1. Create `src/lib/enrichment/dedup.ts`:

```typescript
/**
 * Dedup gate — prevents duplicate paid API calls.
 * Returns true if the entity should be enriched (no prior successful run by this provider).
 */
import { prisma } from "@/lib/db";
import type { EntityType, Provider } from "./types";

export async function shouldEnrich(
  entityId: string,
  entityType: EntityType,
  provider: Provider,
): Promise<boolean> {
  const successfulRun = await prisma.enrichmentLog.findFirst({
    where: { entityId, entityType, provider, status: "success" },
    select: { id: true },
  });
  return successfulRun === null;
}
```

2. Create `src/lib/enrichment/log.ts`:

```typescript
/**
 * Provenance recording — writes an audit trail of every enrichment run.
 * Each call creates a new row (not upsert) to maintain full history.
 */
import { prisma } from "@/lib/db";
import type { EntityType, Provider, EnrichmentStatus } from "./types";

export async function recordEnrichment(params: {
  entityId: string;
  entityType: EntityType;
  provider: Provider;
  status?: EnrichmentStatus;
  fieldsWritten?: string[];
  costUsd?: number;
  rawResponse?: unknown;
  errorMessage?: string;
}): Promise<void> {
  await prisma.enrichmentLog.create({
    data: {
      entityId: params.entityId,
      entityType: params.entityType,
      provider: params.provider,
      status: params.status ?? "success",
      fieldsWritten: params.fieldsWritten
        ? JSON.stringify(params.fieldsWritten)
        : null,
      costUsd: params.costUsd ?? null,
      rawResponse: params.rawResponse
        ? JSON.stringify(params.rawResponse)
        : null,
      errorMessage: params.errorMessage ?? null,
    },
  });
}
```

3. Update `src/__tests__/setup.ts` to add the `enrichmentLog` mock model. Add these entries to the existing `prisma` mock object:

```typescript
enrichmentLog: {
  findFirst: vi.fn(),
  create: vi.fn(),
  findMany: vi.fn(),
  count: vi.fn(),
},
enrichmentJob: {
  findFirst: vi.fn(),
  create: vi.fn(),
  update: vi.fn(),
  findMany: vi.fn(),
},
```

4. Create `src/__tests__/enrichment-dedup.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { prisma } from "@/lib/db";
import { shouldEnrich } from "@/lib/enrichment/dedup";
import { recordEnrichment } from "@/lib/enrichment/log";

describe("shouldEnrich", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("returns true when no successful log exists for this provider", async () => {
    (prisma.enrichmentLog.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(null);
    const result = await shouldEnrich("person-1", "person", "prospeo");
    expect(result).toBe(true);
    expect(prisma.enrichmentLog.findFirst).toHaveBeenCalledWith({
      where: { entityId: "person-1", entityType: "person", provider: "prospeo", status: "success" },
      select: { id: true },
    });
  });

  it("returns false when a successful log exists for this provider", async () => {
    (prisma.enrichmentLog.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue({ id: "log-1" });
    const result = await shouldEnrich("person-1", "person", "prospeo");
    expect(result).toBe(false);
  });

  it("returns true when only error logs exist (eligible for retry)", async () => {
    // findFirst with status: "success" returns null because only error logs exist
    (prisma.enrichmentLog.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(null);
    const result = await shouldEnrich("person-1", "person", "prospeo");
    expect(result).toBe(true);
  });

  it("checks the correct entity type (company vs person)", async () => {
    (prisma.enrichmentLog.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(null);
    await shouldEnrich("company-1", "company", "firecrawl");
    expect(prisma.enrichmentLog.findFirst).toHaveBeenCalledWith({
      where: { entityId: "company-1", entityType: "company", provider: "firecrawl", status: "success" },
      select: { id: true },
    });
  });
});

describe("recordEnrichment", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("writes a success log with fieldsWritten as JSON", async () => {
    (prisma.enrichmentLog.create as ReturnType<typeof vi.fn>).mockResolvedValue({ id: "log-new" });
    await recordEnrichment({
      entityId: "person-1",
      entityType: "person",
      provider: "prospeo",
      fieldsWritten: ["email", "linkedinUrl"],
      costUsd: 0.002,
    });
    expect(prisma.enrichmentLog.create).toHaveBeenCalledWith({
      data: expect.objectContaining({
        entityId: "person-1",
        entityType: "person",
        provider: "prospeo",
        status: "success",
        fieldsWritten: JSON.stringify(["email", "linkedinUrl"]),
        costUsd: 0.002,
        rawResponse: null,
        errorMessage: null,
      }),
    });
  });

  it("writes an error log with errorMessage", async () => {
    (prisma.enrichmentLog.create as ReturnType<typeof vi.fn>).mockResolvedValue({ id: "log-err" });
    await recordEnrichment({
      entityId: "person-2",
      entityType: "person",
      provider: "leadmagic",
      status: "error",
      errorMessage: "API returned 429",
    });
    expect(prisma.enrichmentLog.create).toHaveBeenCalledWith({
      data: expect.objectContaining({
        status: "error",
        errorMessage: "API returned 429",
        fieldsWritten: null,
        costUsd: null,
      }),
    });
  });

  it("serializes rawResponse as JSON when provided", async () => {
    (prisma.enrichmentLog.create as ReturnType<typeof vi.fn>).mockResolvedValue({ id: "log-raw" });
    await recordEnrichment({
      entityId: "company-1",
      entityType: "company",
      provider: "firecrawl",
      rawResponse: { html: "<p>data</p>", crawledAt: "2026-02-26" },
    });
    expect(prisma.enrichmentLog.create).toHaveBeenCalledWith({
      data: expect.objectContaining({
        rawResponse: JSON.stringify({ html: "<p>data</p>", crawledAt: "2026-02-26" }),
      }),
    });
  });
});
```

IMPORTANT: Follow existing test patterns — use `vi.clearAllMocks()` in `beforeEach`, cast mock fns with `as ReturnType<typeof vi.fn>`, use `expect.objectContaining` for partial assertions.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx vitest run src/__tests__/enrichment-dedup.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>All 7 tests pass. shouldEnrich returns true when no success log exists and false when one does. recordEnrichment writes provenance rows with serialized fieldsWritten and rawResponse. Error-only entities are eligible for retry.</done>
</task>

</tasks>

<verification>
1. `npx prisma migrate status` shows no pending migrations
2. `npx tsc --noEmit` passes with zero errors
3. `npx vitest run src/__tests__/enrichment-dedup.test.ts` — all tests pass
4. `src/lib/enrichment/types.ts` exports Provider, EntityType, EnrichmentStatus, EnrichmentResult
5. `src/lib/enrichment/dedup.ts` exports shouldEnrich
6. `src/lib/enrichment/log.ts` exports recordEnrichment
</verification>

<success_criteria>
- EnrichmentLog and EnrichmentJob models exist in the Prisma schema and database
- shouldEnrich(entityId, entityType, provider) queries the EnrichmentLog for successful runs and returns a boolean
- recordEnrichment() creates a provenance row with provider, fields, cost, and timestamp
- All unit tests pass, covering success/error/retry scenarios
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-enrichment-foundation/01-01-SUMMARY.md`
</output>
