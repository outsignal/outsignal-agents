---
phase: 06-mcp-list-migration-csv-button
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/leads-agent/tools/lists.ts
  - src/components/search/list-detail-page.tsx
autonomous: true
requirements: [LIST-02, EXPORT-03]
gap_closure: true

must_haves:
  truths:
    - "MCP create_list creates a TargetList row and returns list_id, name, workspace, creation date"
    - "MCP add_to_list accepts email addresses (not person_ids), resolves each to a Person record, and creates TargetListPerson junction rows"
    - "MCP add_to_list reports not-found emails without aborting the operation"
    - "MCP view_list returns enrichment summary, export readiness (exportReady + unverifiedCount), and paginated member list with verification status"
    - "CSV download button in list detail page uses fetch (not window.open), triggers programmatic download on success, and shows inline error on 400"
  artifacts:
    - path: "src/mcp/leads-agent/tools/lists.ts"
      provides: "MCP list tools using TargetList model with email-based add_to_list and enrichment-aware view_list"
      contains: "emails.*z.array"
    - path: "src/components/search/list-detail-page.tsx"
      provides: "CSV export button with fetch + blob download + error state"
      contains: "handleExportCsv"
  key_links:
    - from: "src/mcp/leads-agent/tools/lists.ts"
      to: "prisma.person.findUnique"
      via: "email-to-personId resolution in add_to_list"
      pattern: "prisma\\.person\\.findUnique.*email"
    - from: "src/mcp/leads-agent/tools/lists.ts"
      to: "getListExportReadiness"
      via: "import from verification-gate.ts in view_list"
      pattern: "getListExportReadiness"
    - from: "src/components/search/list-detail-page.tsx"
      to: "/api/lists/[id]/export"
      via: "fetch call in handleExportCsv"
      pattern: "fetch.*api/lists.*export"
---

<objective>
Rewrite MCP list tools from person_ids to email-based interface and upgrade view_list with enrichment summary + export readiness. Fix CSV download button to use fetch + programmatic download with error handling.

Purpose: Close the MCP build-list-then-export workflow gap (agent can now create_list -> add_to_list by email -> view_list readiness -> export) and make CSV export show proper error feedback in the UI.

Output: Updated lists.ts (3 tools rewritten) and list-detail-page.tsx (CSV button fixed).
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/mcp/leads-agent/tools/lists.ts
@src/components/search/list-detail-page.tsx
@src/lib/export/verification-gate.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From src/lib/export/verification-gate.ts:
```typescript
export interface ExportPerson {
  id: string;
  email: string;
  firstName: string | null;
  lastName: string | null;
  jobTitle: string | null;
  company: string | null;
  companyDomain: string | null;
  linkedinUrl: string | null;
  phone: string | null;
  location: string | null;
  vertical: string | null;
  enrichmentData: string | null;
}

export interface ExportReadiness {
  totalCount: number;
  readyCount: number;
  needsVerificationCount: number;
  blockedCount: number;
  verifiedEmailPct: string;
  verticalBreakdown: Record<string, number>;
  enrichmentCoverage: {
    companyDataPct: string;
    linkedinPct: string;
    jobTitlePct: string;
  };
  readyPeople: ExportPerson[];
  needsVerificationPeople: ExportPerson[];
  blockedPeople: ExportPerson[];
}

export async function getListExportReadiness(listId: string): Promise<ExportReadiness>;
```

From src/lib/enrichment/status.ts:
```typescript
export type EnrichmentStatus = "full" | "partial" | "missing";
export function getEnrichmentStatus(person: {
  email: string | null;
  linkedinUrl: string | null;
  companyDomain: string | null;
}): EnrichmentStatus;
```

From src/lib/db.ts:
```typescript
export const prisma: PrismaClient;
```

Prisma models (from schema.prisma):
```prisma
model TargetList {
  id            String              @id @default(cuid())
  name          String
  workspaceSlug String
  description   String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  workspace     Workspace           @relation(fields: [workspaceSlug], references: [slug])
  people        TargetListPerson[]
}

model TargetListPerson {
  id        String     @id @default(cuid())
  listId    String
  personId  String
  addedAt   DateTime   @default(now())
  list      TargetList @relation(fields: [listId], references: [id], onDelete: Cascade)
  person    Person     @relation(fields: [personId], references: [id], onDelete: Cascade)
  @@unique([listId, personId])
  @@map("TargetListPerson")
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite MCP list tools (create_list, add_to_list, view_list)</name>
  <files>src/mcp/leads-agent/tools/lists.ts</files>
  <action>
Rewrite all three MCP tools in `src/mcp/leads-agent/tools/lists.ts`. Delete all existing tool implementations and replace with the following. Keep the same file structure (imports, registerListTools function, three server.tool calls).

**Add import** at top of file (alongside existing imports):
```typescript
import { getListExportReadiness } from "@/lib/export/verification-gate";
```

**create_list changes:**
1. Replace `findUniqueOrThrow` with `findUnique` + null check returning friendly MCP error:
   ```typescript
   const ws = await prisma.workspace.findUnique({ where: { slug: workspace } });
   if (!ws) {
     return { content: [{ type: "text" as const, text: `Error: Workspace '${workspace}' not found. Use a valid workspace slug.` }] };
   }
   ```
2. Update response text to include creation date:
   ```typescript
   const text = [
     `List created successfully.`,
     ``,
     `ID: ${list.id}`,
     `Name: ${list.name}`,
     `Workspace: ${workspace}`,
     `Created: ${list.createdAt.toISOString()}`,
     ``,
     `Use add_to_list with list_id='${list.id}' to add people.`,
   ].join("\n");
   ```

**add_to_list changes (full rewrite):**
1. Replace `person_ids: z.array(z.string())` parameter with `emails: z.array(z.string().email()).describe("Email addresses of people to add")`.
2. Update tool description to: `"Add people to a TargetList by email address. Resolves each email to a Person record and creates the list membership. Reports any emails not found in the database."`
3. Replace the sequential create loop with:
   a. Resolve all emails to person IDs in parallel:
      ```typescript
      const resolved = await Promise.all(
        emails.map(async (email) => {
          const person = await prisma.person.findUnique({
            where: { email },
            select: { id: true },
          });
          return { email, personId: person?.id ?? null };
        })
      );
      const found = resolved.filter((r): r is { email: string; personId: string } => r.personId !== null);
      const notFoundEmails = resolved.filter((r) => r.personId === null).map((r) => r.email);
      ```
   b. Bulk insert with skipDuplicates:
      ```typescript
      const result = await prisma.targetListPerson.createMany({
        data: found.map(({ personId }) => ({ listId: list_id, personId })),
        skipDuplicates: true,
      });
      ```
   c. Calculate skipped count: `const skippedCount = found.length - result.count;`
   d. Build response text including added count, skipped (already in list), and not-found emails:
      ```typescript
      let text = `Added ${result.count} people to list '${list.name}'.`;
      if (skippedCount > 0) text += ` ${skippedCount} already in list.`;
      if (notFoundEmails.length > 0) {
        text += `\n\nNot found in database (${notFoundEmails.length}):\n${notFoundEmails.join("\n")}`;
      }
      ```

**view_list changes (full rewrite):**
1. Add `offset: z.number().default(0).describe("Offset for pagination")` parameter.
2. Update tool description to: `"View a TargetList with enrichment summary, export readiness, and paginated member list. Use offset to paginate through large lists."`
3. Replace the manual query + ICP lookup with:
   a. Fetch export readiness using the existing helper:
      ```typescript
      const readiness = await getListExportReadiness(list_id);
      ```
   b. Derive export readiness:
      ```typescript
      const exportReady = readiness.needsVerificationCount === 0 && readiness.blockedCount === 0;
      const unverifiedCount = readiness.needsVerificationCount;
      ```
   c. Build verification status map from readiness arrays:
      ```typescript
      const statusMap = new Map<string, "ready" | "unverified" | "blocked">();
      for (const p of readiness.readyPeople) statusMap.set(p.id, "ready");
      for (const p of readiness.needsVerificationPeople) statusMap.set(p.id, "unverified");
      for (const p of readiness.blockedPeople) statusMap.set(p.id, "blocked");
      ```
   d. Combine all people, apply offset/limit pagination:
      ```typescript
      const allPeople = [...readiness.readyPeople, ...readiness.needsVerificationPeople, ...readiness.blockedPeople];
      const page = allPeople.slice(offset, offset + limit);
      ```
   e. Build response with summary header, then member table:
      - Summary section:
        ```
        List: {name} ({workspace})
        Total: {totalCount} people
        Export Ready: {exportReady ? "Yes" : "No — " + unverifiedCount + " unverified"}

        Enrichment Coverage:
        - Company data: {companyDataPct}%
        - LinkedIn: {linkedinPct}%
        - Job title: {jobTitlePct}%

        Verification:
        - Ready: {readyCount}
        - Needs verification: {needsVerificationCount}
        - Blocked: {blockedCount}
        ```
      - Member table with columns: Name, Email, Company, Enrichment, Verification
      - Each member's verification status from `statusMap.get(person.id) ?? "unverified"`
      - Each member's enrichment status derived inline: check `linkedinUrl` + `companyDomain` presence -> "full"/"partial"/"missing"
      - Pagination footer: `Showing {offset+1}-{offset+page.length} of {totalCount}` (only if not showing all)
   f. Handle empty list case: `"0 people in list '{name}'. Use add_to_list to add people."`

**CRITICAL: Keep `console.error` for error logging (stdout reserved for JSON-RPC). Do NOT use console.log.**
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/mcp/leads-agent/tools/lists.ts 2>&1 | head -30</automated>
  </verify>
  <done>
    - create_list validates workspace with findUnique (not findUniqueOrThrow) and returns rich response with creation date
    - add_to_list accepts emails array, resolves to person IDs, uses createMany with skipDuplicates, reports not-found emails
    - view_list uses getListExportReadiness for enrichment summary + verification status, returns exportReady/unverifiedCount, supports offset pagination
    - All three tools return TargetList-backed data (no PersonWorkspace.tags references)
    - File compiles with zero TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix CSV download button with fetch + error handling</name>
  <files>src/components/search/list-detail-page.tsx</files>
  <action>
Update the CSV export button in `src/components/search/list-detail-page.tsx` to use `fetch()` instead of `window.open()`, with programmatic download on success and inline error display on failure.

**Add state variables** inside `ListDetailPage` component (after existing state declarations around line 134):
```typescript
const [exportLoading, setExportLoading] = useState(false);
const [exportError, setExportError] = useState<string | null>(null);
```

**Add handler function** inside the component (after `handleRemovePerson`):
```typescript
async function handleExportCsv() {
  setExportLoading(true);
  setExportError(null);
  try {
    const res = await fetch(`/api/lists/${listId}/export`);
    if (!res.ok) {
      const json = await res.json().catch(() => ({ error: "Export failed" }));
      setExportError(json.error ?? "Export failed");
      return;
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const filename =
      res.headers.get("Content-Disposition")?.match(/filename="(.+?)"/)?.[1] ??
      "export.csv";
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } finally {
    setExportLoading(false);
  }
}
```

**Replace the Export CSV button** (currently lines 254-264) — change the Button's `onClick` from `window.open(...)` to `handleExportCsv`, add loading state, and add `exportLoading` to disabled check:
```tsx
<Button
  variant="outline"
  size="sm"
  className="border-zinc-700 text-zinc-300 hover:text-white hover:bg-zinc-800"
  onClick={handleExportCsv}
  disabled={exportLoading || (loading && !list)}
>
  {exportLoading ? "Exporting..." : "Export CSV"}
</Button>
```

**Add inline error display** immediately after the closing `</div>` of the button group (`<div className="flex items-center gap-2">...</div>`) — wrap the header area so the error appears below the action buttons. Add this right after the button group div closes:
```tsx
{exportError && (
  <p className="text-xs text-red-400 mt-1 text-right">{exportError}</p>
)}
```

Place this error `<p>` inside the header flex container, after the button group div, so it renders below the buttons on the right side. The cleanest approach: wrap the button group and error in a small div:
```tsx
<div className="flex flex-col items-end gap-1">
  <div className="flex items-center gap-2">
    {/* ...existing Export CSV and Delete List buttons... */}
  </div>
  {exportError && (
    <p className="text-xs text-red-400">{exportError}</p>
  )}
</div>
```

This means the header structure becomes:
```tsx
<div className="flex items-start justify-between">
  <div className="space-y-1">
    {/* ...back link, title, description... */}
  </div>
  <div className="flex flex-col items-end gap-1">
    <div className="flex items-center gap-2">
      <Button onClick={handleExportCsv} ...>Export CSV</Button>
      <Button onClick={() => setShowDeleteList(true)} ...>Delete List</Button>
    </div>
    {exportError && (
      <p className="text-xs text-red-400">{exportError}</p>
    )}
  </div>
</div>
```
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/components/search/list-detail-page.tsx 2>&1 | head -30</automated>
  </verify>
  <done>
    - Export CSV button calls handleExportCsv (not window.open)
    - On success: triggers programmatic download via blob URL with filename from Content-Disposition header
    - On 400: parses JSON error and shows inline red error text below the button
    - Button shows "Exporting..." during loading and is disabled
    - No new dependencies added (no toast library)
    - File compiles with zero TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit` — zero errors in modified files
2. MCP server starts: `cd /Users/jjay/programs/outsignal-agents && timeout 5 npx tsx src/mcp/leads-agent/index.ts 2>&1 || true` — no import errors
3. Code inspection: `grep -n "window.open" src/components/search/list-detail-page.tsx` — returns NO matches (old pattern removed)
4. Code inspection: `grep -n "person_ids" src/mcp/leads-agent/tools/lists.ts` — returns NO matches (old parameter removed)
5. Code inspection: `grep -n "getListExportReadiness" src/mcp/leads-agent/tools/lists.ts` — returns a match (new import wired)
6. Code inspection: `grep -n "emails.*z.array" src/mcp/leads-agent/tools/lists.ts` — returns a match (email parameter added)
7. Code inspection: `grep -n "handleExportCsv" src/components/search/list-detail-page.tsx` — returns matches (new handler wired)
</verification>

<success_criteria>
- MCP `create_list` creates TargetList row, returns list_id + name + workspace + createdAt, handles invalid workspace with friendly error
- MCP `add_to_list` accepts email array, resolves to person IDs, bulk inserts with skipDuplicates, reports not-found emails
- MCP `view_list` returns enrichment summary + exportReady/unverifiedCount + paginated member table with per-person verification status
- CSV button uses fetch + programmatic blob download, shows inline error on blocked export, no window.open calls remain
- Full agent workflow works: create_list -> add_to_list (by email) -> view_list (check readiness) -> export_to_emailbison/export_csv
</success_criteria>

<output>
After completion, create `.planning/phases/06-mcp-list-migration-csv-button/06-01-SUMMARY.md`
</output>
