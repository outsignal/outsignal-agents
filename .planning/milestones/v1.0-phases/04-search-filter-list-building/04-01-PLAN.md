---
phase: 04-search-filter-list-building
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/enrichment/status.ts
  - src/app/(admin)/layout.tsx
  - package.json
autonomous: true
requirements:
  - LIST-01
  - SEARCH-04

must_haves:
  truths:
    - "TargetList and TargetListPerson models exist in the database and can be queried via Prisma"
    - "Enrichment status (full/partial/missing) can be derived from any person record without a stored column"
    - "nuqs and use-debounce are installed and available for import"
    - "NuqsAdapter wraps the admin layout so all child pages can use nuqs hooks"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "TargetList + TargetListPerson models with indexes and relations"
      contains: "model TargetList"
    - path: "src/lib/enrichment/status.ts"
      provides: "Enrichment status utility (getEnrichmentStatus, getCompanyEnrichmentStatus, ENRICHMENT_COLORS)"
      exports: ["getEnrichmentStatus", "getCompanyEnrichmentStatus", "EnrichmentStatus", "ENRICHMENT_COLORS"]
    - path: "src/app/(admin)/layout.tsx"
      provides: "NuqsAdapter context provider wrapping admin pages"
      contains: "NuqsAdapter"
    - path: "package.json"
      provides: "nuqs and use-debounce dependencies"
      contains: "nuqs"
  key_links:
    - from: "prisma/schema.prisma"
      to: "Person model"
      via: "TargetListPerson.personId relation"
      pattern: "person.*Person.*@relation"
    - from: "src/app/(admin)/layout.tsx"
      to: "nuqs/adapters/next/app"
      via: "NuqsAdapter import"
      pattern: "NuqsAdapter"
---

<objective>
Create the schema, dependency, and utility foundation for Phase 4 search/filter/list-building features.

Purpose: All subsequent plans in this phase depend on the TargetList schema, nuqs URL state library, and enrichment status utility. This plan installs those foundations so Plans 02-05 can run without setup work.

Output: TargetList + TargetListPerson Prisma models pushed to production DB, enrichment status utility, nuqs installed and wired into admin layout.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-filter-list-building/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From prisma/schema.prisma (Person model — TargetListPerson will reference this):
```prisma
model Person {
  id             String   @id @default(cuid())
  email          String   @unique
  firstName      String?
  lastName       String?
  company        String?
  companyDomain  String?
  jobTitle       String?
  linkedinUrl    String?
  vertical       String?
  source         String
  status         String   @default("new")
  workspaces     PersonWorkspace[]
  @@map("Lead")
}
```

From src/app/(admin)/layout.tsx (current admin layout to add NuqsAdapter to):
```typescript
export const dynamic = "force-dynamic";
import { TooltipProvider } from "@/components/ui/tooltip";
import { AppShell } from "@/components/layout/app-shell";

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  return (
    <TooltipProvider>
      <AppShell>{children}</AppShell>
    </TooltipProvider>
  );
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies + Schema migration + Enrichment status utility</name>
  <files>package.json, prisma/schema.prisma, src/lib/enrichment/status.ts</files>
  <action>
1. Install nuqs and use-debounce:
   ```bash
   npm install nuqs use-debounce
   ```

2. Add TargetList and TargetListPerson models to prisma/schema.prisma AFTER the DailyCostTotal model:

```prisma
model TargetList {
  id            String   @id @default(cuid())
  name          String
  workspaceSlug String
  description   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  people TargetListPerson[]

  @@index([workspaceSlug])
}

model TargetListPerson {
  id       String   @id @default(cuid())
  listId   String
  personId String
  addedAt  DateTime @default(now())

  list   TargetList @relation(fields: [listId], references: [id], onDelete: Cascade)
  person Person     @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([listId, personId])
  @@index([listId])
  @@index([personId])
}
```

3. Add the reverse relation to the Person model — add `lists TargetListPerson[]` to Person's relation fields (alongside the existing `workspaces PersonWorkspace[]` line).

4. Push schema to production DB using db push (NOT migrate dev — no migration history, established pattern [01-01]):
   ```bash
   npx prisma db push
   ```
   Note: If DATABASE_URL not in shell, source from .env.local or pass explicitly.

5. Create `src/lib/enrichment/status.ts` with:

```typescript
export type EnrichmentStatus = "full" | "partial" | "missing";

/**
 * Derive enrichment status from a person record's field presence.
 * - full: has email + linkedinUrl + companyDomain
 * - partial: has at least one but not all three
 * - missing: has none of the three key enrichment fields
 *
 * Note: Person.email is String @unique (never null), so "missing" means
 * no linkedinUrl AND no companyDomain. In practice, everyone has email.
 */
export function getEnrichmentStatus(person: {
  email: string | null;
  linkedinUrl: string | null;
  companyDomain: string | null;
}): EnrichmentStatus {
  const has = [!!person.email, !!person.linkedinUrl, !!person.companyDomain].filter(Boolean).length;
  if (has === 3) return "full";
  if (has >= 1) return "partial";
  return "missing";
}

/**
 * Derive enrichment status for a company record.
 * - full: has industry + headcount + description
 * - partial: has at least one but not all three
 * - missing: none present
 */
export function getCompanyEnrichmentStatus(company: {
  industry: string | null;
  headcount: number | null;
  description: string | null;
}): EnrichmentStatus {
  const has = [!!company.industry, company.headcount != null, !!company.description].filter(Boolean).length;
  if (has === 3) return "full";
  if (has >= 1) return "partial";
  return "missing";
}

/** Color mapping for enrichment status indicators (green/yellow/red intent per user decision) */
export const ENRICHMENT_COLORS: Record<EnrichmentStatus, string> = {
  full: "#4ECDC4",    // teal-green
  partial: "#F0FF7A", // brand yellow
  missing: "#FF6B6B", // red
};

/** Human-readable labels */
export const ENRICHMENT_LABELS: Record<EnrichmentStatus, string> = {
  full: "Enriched",
  partial: "Partial",
  missing: "Missing",
};
```
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/lib/enrichment/status.ts 2>&1 | head -20</automated>
  </verify>
  <done>TargetList + TargetListPerson models exist in production DB. nuqs and use-debounce are in package.json. Enrichment status utility compiles and exports getEnrichmentStatus, getCompanyEnrichmentStatus, ENRICHMENT_COLORS, ENRICHMENT_LABELS.</done>
</task>

<task type="auto">
  <name>Task 2: Wire NuqsAdapter into admin layout</name>
  <files>src/app/(admin)/layout.tsx</files>
  <action>
Update `src/app/(admin)/layout.tsx` to wrap children in NuqsAdapter from `nuqs/adapters/next/app`. The NuqsAdapter provides the React context that all nuqs hooks (useQueryState, useQueryStates) require.

Place NuqsAdapter INSIDE TooltipProvider, wrapping AppShell. This scopes nuqs to admin routes only (not customer/portal routes which don't use search/filter).

Updated layout:
```typescript
export const dynamic = "force-dynamic";

import { NuqsAdapter } from "nuqs/adapters/next/app";
import { TooltipProvider } from "@/components/ui/tooltip";
import { AppShell } from "@/components/layout/app-shell";

export default function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <TooltipProvider>
      <NuqsAdapter>
        <AppShell>{children}</AppShell>
      </NuqsAdapter>
    </TooltipProvider>
  );
}
```

**Why inside TooltipProvider:** NuqsAdapter is a pure React context provider — ordering with TooltipProvider doesn't matter functionally, but this keeps NuqsAdapter closest to the components that use it.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/app/\(admin\)/layout.tsx 2>&1 | head -20</automated>
  </verify>
  <done>Admin layout wraps children in NuqsAdapter. Any page under (admin)/ can use useQueryStates without "No NuqsAdapter found" errors.</done>
</task>

</tasks>

<verification>
1. `npx prisma db push` completes without errors (schema synced to production DB)
2. `npx tsc --noEmit src/lib/enrichment/status.ts` — no TypeScript errors
3. `npx tsc --noEmit src/app/\(admin\)/layout.tsx` — no TypeScript errors
4. `npm ls nuqs use-debounce` shows both packages installed
</verification>

<success_criteria>
- TargetList and TargetListPerson models exist in Prisma schema and production database
- Person model has `lists TargetListPerson[]` reverse relation
- `src/lib/enrichment/status.ts` exports getEnrichmentStatus, getCompanyEnrichmentStatus, ENRICHMENT_COLORS, ENRICHMENT_LABELS
- nuqs and use-debounce are in package.json dependencies
- NuqsAdapter wraps admin layout children
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-filter-list-building/04-01-SUMMARY.md`
</output>
