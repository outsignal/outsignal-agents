---
phase: 04-search-filter-list-building
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/people/search/route.ts
  - src/app/(admin)/people/page.tsx
  - src/components/search/people-search-page.tsx
  - src/components/search/filter-sidebar.tsx
  - src/components/search/enrichment-badge.tsx
autonomous: true
requirements:
  - SEARCH-01
  - SEARCH-02
  - SEARCH-04
  - SEARCH-05

must_haves:
  truths:
    - "User can type a name, email, company, or job title and see matching people records in under 2 seconds"
    - "User can filter people by vertical, enrichment status, workspace, and company"
    - "Filtered result count updates live as filters are toggled without a page reload"
    - "Active filters displayed as removable chips above the results table"
    - "Each person row shows a green/yellow/red enrichment status indicator"
    - "User can paginate through the full 14k+ dataset with 50 results per page"
  artifacts:
    - path: "src/app/api/people/search/route.ts"
      provides: "GET /api/people/search with multi-field text search, compound filters, pagination"
      exports: ["GET"]
    - path: "src/app/(admin)/people/page.tsx"
      provides: "Thin server page wrapper that renders the client search component"
      min_lines: 5
    - path: "src/components/search/people-search-page.tsx"
      provides: "Client component: full people search experience with debounced input, filter sidebar, results table"
      min_lines: 100
    - path: "src/components/search/filter-sidebar.tsx"
      provides: "Left sidebar filter panel with vertical, enrichment, workspace, company filters"
      min_lines: 50
    - path: "src/components/search/enrichment-badge.tsx"
      provides: "Small colored indicator (green/yellow/red) for enrichment status"
      exports: ["EnrichmentBadge"]
  key_links:
    - from: "src/components/search/people-search-page.tsx"
      to: "/api/people/search"
      via: "fetch in useEffect triggered by nuqs URL state changes"
      pattern: "fetch.*api/people/search"
    - from: "src/components/search/people-search-page.tsx"
      to: "src/components/search/filter-sidebar.tsx"
      via: "import and render as left panel"
      pattern: "FilterSidebar"
    - from: "src/components/search/enrichment-badge.tsx"
      to: "src/lib/enrichment/status.ts"
      via: "imports getEnrichmentStatus and ENRICHMENT_COLORS"
      pattern: "getEnrichmentStatus"
---

<objective>
Build the people search experience — API route with multi-field search and compound filters, plus a client-driven search page with instant debounced search, left sidebar filters, enrichment indicators, and pagination.

Purpose: This is the primary data exploration surface. With 14k+ people, users need fast text search across name/email/company/title plus filtering by vertical, enrichment status, workspace, and company — all without page reloads.

Output: GET /api/people/search route, client search page replacing the existing server-rendered people page, filter sidebar component, enrichment badge component.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-filter-list-building/04-RESEARCH.md
@.planning/phases/04-search-filter-list-building/04-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 that this plan uses -->

From src/lib/enrichment/status.ts (created in Plan 01):
```typescript
export type EnrichmentStatus = "full" | "partial" | "missing";
export function getEnrichmentStatus(person: {
  email: string | null;
  linkedinUrl: string | null;
  companyDomain: string | null;
}): EnrichmentStatus;
export const ENRICHMENT_COLORS: Record<EnrichmentStatus, string>;
export const ENRICHMENT_LABELS: Record<EnrichmentStatus, string>;
```

From prisma/schema.prisma (Person model fields for search):
```prisma
model Person {
  id, email (String @unique), firstName?, lastName?, company?, companyDomain?,
  jobTitle?, linkedinUrl?, vertical?, source, status, workspaces PersonWorkspace[]
}
model PersonWorkspace {
  personId, workspace, vertical?, icpScore?, icpReasoning?, icpConfidence?
}
```

From src/app/(admin)/enrichment-costs/page.tsx (reference pattern for client page):
- "use client" directive
- useState/useEffect/useCallback for data fetching
- Skeleton loading states
- Error state with retry button
- Dark theme with bg-gray-950/bg-gray-900

From src/components/ui/ (available shadcn components):
- badge.tsx, button.tsx, card.tsx, checkbox.tsx, dialog.tsx, dropdown-menu.tsx
- input.tsx, label.tsx, table.tsx, skeleton.tsx, separator.tsx
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: People search API route</name>
  <files>src/app/api/people/search/route.ts</files>
  <action>
Create `src/app/api/people/search/route.ts` — a GET endpoint that accepts URL query params and returns paginated, filtered people.

**URL params:**
- `q` (string) — free-text search across email, firstName, lastName, company, jobTitle (OR across fields, case-insensitive)
- `vertical` (multi-value via getAll) — filter by vertical (OR within: e.g. vertical=Recruitment&vertical=Merchandise)
- `workspace` (string) — filter by workspace via PersonWorkspace join
- `enrichment` (string: "full" | "partial" | "missing") — filter by derived enrichment status
- `company` (string) — sub-filter on company name (contains, case-insensitive)
- `page` (number, default 1) — pagination offset
- Page size: 50 (constant)

**WHERE clause construction:**
Use `AND: [...]` array approach to avoid overwriting `where.OR` (Pitfall 2 from research). Build an `andConditions` array, push each active filter, then set `where.AND = andConditions`.

For text search `q`: push `{ OR: [{ email: { contains: q, mode: 'insensitive' } }, { firstName: ... }, { lastName: ... }, { company: ... }, { jobTitle: ... }] }`

For vertical filter: push `{ vertical: { in: verticals } }`

For workspace filter: push `{ workspaces: { some: { workspace } } }`

For company sub-filter: push `{ company: { contains: company, mode: 'insensitive' } }`

For enrichment status — this is trickier since it's derived:
- "full": push `{ AND: [{ linkedinUrl: { not: null } }, { companyDomain: { not: null } }] }` (email is always present since String @unique)
- "partial": push `{ OR: [{ linkedinUrl: null }, { companyDomain: null }] }` but also require at least one non-null: use `{ AND: [{ NOT: { AND: [{ linkedinUrl: null }, { companyDomain: null }] } }, { OR: [{ linkedinUrl: null }, { companyDomain: null }] }] }`
  Actually simpler: since email is always present (String @unique, never null), "partial" means NOT full AND NOT missing. Full = linkedinUrl AND companyDomain both not null. Missing = linkedinUrl AND companyDomain both null. So partial = exactly one of linkedinUrl/companyDomain is null.
  Push: `{ OR: [{ linkedinUrl: { not: null }, companyDomain: null }, { linkedinUrl: null, companyDomain: { not: null } }] }`
- "missing": push `{ linkedinUrl: null, companyDomain: null }`

**Response shape:**
```typescript
{
  people: Array<{
    id: string;
    email: string;
    firstName: string | null;
    lastName: string | null;
    company: string | null;
    jobTitle: string | null;
    vertical: string | null;
    linkedinUrl: string | null;
    companyDomain: string | null;
    workspaces: Array<{ workspace: string; vertical: string | null }>;
  }>;
  total: number;
  page: number;
  pageSize: number;
}
```

**Implementation details:**
- Use Promise.all([prisma.person.findMany(...), prisma.person.count({ where })]) — batch count with data query
- Select only needed fields (no enrichmentData, no full PersonWorkspace)
- OrderBy: { createdAt: 'desc' }
- Skip: (page - 1) * PAGE_SIZE, take: PAGE_SIZE
- Return NextResponse.json with the response shape above
- Wrap in try/catch, return 500 on error

**Also fetch filter options (distinct verticals and workspaces)** — add a separate endpoint or include in response. Recommendation: include `filterOptions` in the response as a static query. Run `prisma.person.groupBy({ by: ['vertical'], where: { vertical: { not: null } } })` and `prisma.personWorkspace.groupBy({ by: ['workspace'] })` in the same Promise.all. Return:
```typescript
filterOptions: {
  verticals: string[];   // distinct non-null verticals
  workspaces: string[];  // distinct workspace slugs
}
```

This avoids a separate API call and the filter sidebar can populate from the first response.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/app/api/people/search/route.ts 2>&1 | head -20</automated>
  </verify>
  <done>GET /api/people/search returns paginated people with text search across 5 fields, compound filters (vertical, workspace, enrichment, company), and filter options (verticals, workspaces). Count and data fetched in single Promise.all.</done>
</task>

<task type="auto">
  <name>Task 2: People search page with filter sidebar and enrichment badges</name>
  <files>src/app/(admin)/people/page.tsx, src/components/search/people-search-page.tsx, src/components/search/filter-sidebar.tsx, src/components/search/enrichment-badge.tsx</files>
  <action>
**1. Create `src/components/search/enrichment-badge.tsx`:**

Small reusable component that renders a colored dot + label for enrichment status. Accepts a person-shaped object, calls `getEnrichmentStatus` from `@/lib/enrichment/status`, renders a small badge with the appropriate color (green/yellow/red).

```typescript
"use client";
import { getEnrichmentStatus, ENRICHMENT_COLORS, ENRICHMENT_LABELS } from "@/lib/enrichment/status";

interface EnrichmentBadgeProps {
  person: { email: string | null; linkedinUrl: string | null; companyDomain: string | null };
}

export function EnrichmentBadge({ person }: EnrichmentBadgeProps) {
  const status = getEnrichmentStatus(person);
  return (
    <span className="inline-flex items-center gap-1.5 text-xs">
      <span className="inline-block w-2 h-2 rounded-full" style={{ backgroundColor: ENRICHMENT_COLORS[status] }} />
      {ENRICHMENT_LABELS[status]}
    </span>
  );
}
```

**2. Create `src/components/search/filter-sidebar.tsx`:**

Left sidebar filter panel (persistent, always visible). Receives current filter values and setter function from parent. Renders:

- **Vertical filter:** Checkboxes for each distinct vertical (populated from filterOptions). Checking/unchecking toggles the vertical in the array. OR logic within (multi-select).
- **Enrichment status filter:** Three radio-style options: All, Enriched, Partial, Missing. Single-select.
- **Workspace filter:** Dropdown or checkboxes for each distinct workspace (populated from filterOptions). Single-select.
- **Company filter:** Text input that filters on company name (sub-search within results). Debounce 300ms.

Each filter change calls the setter which updates nuqs URL state, resetting page to 1.

Active filters shown as removable chips/tags above the results (rendered by the parent `people-search-page.tsx`, not inside sidebar).

Style: dark theme consistent with existing pages (bg-gray-900, border-gray-800, text-gray-400 labels, text-sm).

Props interface:
```typescript
interface FilterSidebarProps {
  verticals: string[];      // available options
  workspaces: string[];     // available options
  selectedVerticals: string[];
  selectedEnrichment: string;
  selectedWorkspace: string;
  companyFilter: string;
  onVerticalToggle: (vertical: string) => void;
  onEnrichmentChange: (value: string) => void;
  onWorkspaceChange: (value: string) => void;
  onCompanyChange: (value: string) => void;
}
```

**3. Create `src/components/search/people-search-page.tsx`:**

"use client" component that owns the entire people search experience. This is the main page content.

**URL state (nuqs):**
Use `useQueryStates` from nuqs with:
```typescript
const [params, setParams] = useQueryStates({
  q: parseAsString.withDefault(''),
  vertical: parseAsArrayOf(parseAsString).withDefault([]),
  enrichment: parseAsString.withDefault(''),
  workspace: parseAsString.withDefault(''),
  company: parseAsString.withDefault(''),
  page: parseAsInteger.withDefault(1),
})
```

**Data fetching:**
- Build URLSearchParams from nuqs params
- Fetch from `/api/people/search?${searchParams}` on param change (useEffect)
- Store results in useState: `data`, `loading`, `error`
- On first load, also extract `filterOptions` from response and cache in state (don't re-query on every filter change — they're static-ish)

**Search input:**
- At top of page, full-width input with search icon (lucide-react Search icon)
- Use `useDebouncedCallback` from `use-debounce` with 300ms delay
- `defaultValue` from params.q, onChange calls debounced setter that updates `q` param and resets page to 1

**Layout:**
```
┌───────────────────────────────────────────┐
│ Header: "People" + total count            │
├──────────┬────────────────────────────────┤
│ Filter   │ [Search input................] │
│ Sidebar  │ [Active filter chips]          │
│ (240px)  │ ┌────────────────────────────┐ │
│          │ │ Results table (dense rows) │ │
│ Vertical │ │ Name | Email | Company |   │ │
│ ☐ Merch  │ │ Title | Vertical | Status │ │
│ ☐ Recruit│ │ ...50 rows per page...    │ │
│          │ └────────────────────────────┘ │
│ Enrich   │ Page 1 of 293 [Prev] [Next]   │
│ ○ All    │                                │
│ ○ Full   ├────────────────────────────────┤
│ ○ Partial│                                │
│ ○ Missing│                                │
│          │                                │
│ Workspace│                                │
│ [select] │                                │
│          │                                │
│ Company  │                                │
│ [input]  │                                │
└──────────┴────────────────────────────────┘
```

**Active filter chips:**
Above the table, render removable chips for each active filter. Clicking X on a chip clears that filter and resets page to 1. Example: `Vertical: Recruitment ✕ | Enrichment: Full ✕ | Workspace: rise ✕`

**Results table:**
Use the shadcn Table components. Columns: Name (firstName + lastName), Email, Company, Title, Vertical, Enrichment Status (EnrichmentBadge). Dense rows (py-2, text-sm). No card wrapper — table renders directly.

**Pagination:**
Below the table: "Showing X-Y of Z results" on the left, Previous/Next buttons on the right. Previous disabled on page 1, Next disabled on last page. Clicking updates page param.

**Loading state:**
Show skeleton rows (8 rows with animated placeholder bars) while loading. Same pattern as enrichment-costs page.

**Empty state:**
"No people found matching your search" centered in table area.

**Error state:**
Red banner with error message + Retry button, same pattern as enrichment-costs page.

**Styling:**
Match the dark theme of enrichment-costs page: bg-gray-950 base, bg-gray-900 for cards/panels, border-gray-800, text-white for headings, text-gray-400 for secondary text. The header section should match the existing pattern with h1 + description.

**4. Replace `src/app/(admin)/people/page.tsx`:**

Replace the entire existing server component with a thin wrapper that renders the client component:

```typescript
import { PeopleSearchPage } from "@/components/search/people-search-page";

export const dynamic = "force-dynamic";

export default function PeoplePage() {
  return <PeopleSearchPage />;
}
```

The existing page uses server-side searchParams + HTML form submission — this is being replaced wholesale per the research recommendation (anti-pattern: Server Component for dynamic search).
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/app/\(admin\)/people/page.tsx src/components/search/people-search-page.tsx src/components/search/filter-sidebar.tsx src/components/search/enrichment-badge.tsx 2>&1 | head -30</automated>
  </verify>
  <done>People search page loads at /people, shows instant debounced search across name/email/company/title, left sidebar filters for vertical/enrichment/workspace/company, removable filter chips, dense table with enrichment badges, and pagination. All state lives in the URL via nuqs (bookmarkable).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no TypeScript errors in any new/modified files
2. GET /api/people/search returns JSON with people array, total count, and filterOptions
3. GET /api/people/search?q=john returns people matching "john" across name/email/company/title
4. GET /api/people/search?vertical=Recruitment&enrichment=full returns filtered results
5. /people page renders client search component with filter sidebar and results table
6. Search input debounces 300ms before updating URL and triggering fetch
7. Pagination works: page=2 shows next 50 results
</verification>

<success_criteria>
- Text search across name, email, company, job title returns results in under 2 seconds
- Filter sidebar shows distinct verticals and workspaces populated from database
- Filters combine with AND logic across types, OR within verticals
- Active filters display as removable chips above results
- Each person row shows green/yellow/red enrichment badge
- Pagination works across the full 14k+ dataset with 50 per page
- All state is URL-driven (bookmarkable, survives refresh)
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-filter-list-building/04-02-SUMMARY.md`
</output>
