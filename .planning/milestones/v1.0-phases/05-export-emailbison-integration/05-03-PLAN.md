---
phase: 05-export-emailbison-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/mcp/leads-agent/tools/export.ts
autonomous: true
requirements:
  - EXPORT-01
  - EXPORT-02
  - EXPORT-03

must_haves:
  truths:
    - "User can push a list to an EmailBison campaign via direct API with a pre-export summary"
    - "Any export attempt is blocked if any person has an unverified email"
    - "User can export a list as CSV via MCP tool"
    - "Pre-export summary shows lead count, verified email %, vertical breakdown, campaign details, enrichment coverage"
    - "Agent creates new campaign (never adds to existing) per CONTEXT.md decision"
    - "Invalid/undeliverable emails are automatically excluded after verification"
    - "Campaign naming follows workspace_list_date convention"
    - "TargetList model used (not tags)"
    - "Agent creates workspace when it does not exist (per CONTEXT.md locked decision)"
  artifacts:
    - path: "src/mcp/leads-agent/tools/export.ts"
      provides: "MCP tools for EmailBison campaign push and CSV export"
      exports: ["registerExportTools"]
      min_lines: 180
  key_links:
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "src/lib/export/verification-gate.ts"
      via: "import getListExportReadiness, verifyAndFilter"
      pattern: "import.*from.*export/verification-gate"
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "src/lib/export/csv.ts"
      via: "import generateListCsv"
      pattern: "import.*from.*export/csv"
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "src/lib/emailbison/client.ts"
      via: "import EmailBisonClient"
      pattern: "import.*EmailBisonClient.*from.*emailbison/client"
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "prisma.workspace"
      via: "fetch or create workspace for EmailBison auth"
      pattern: "prisma\\.workspace\\.(findUnique|create)"
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "prisma.targetList"
      via: "fetch list metadata"
      pattern: "prisma\\.targetList\\.findUnique"
---

<objective>
Rewrite the MCP `export_to_emailbison` tool to use the Phase 4 `TargetList` model (replacing the old tag-based list query), wire in the EmailBison campaign creation + lead push from Plan 02, add a `export_csv` tool, and build the rich pre-export summary required by CONTEXT.md. This is the agent's primary interface for exporting lists.

Purpose: Provides the agent-driven workflow for pushing verified lists to EmailBison campaigns or exporting as CSV, with workspace auto-creation per locked decisions.

Output: Rewritten export.ts with two MCP tools: export_to_emailbison and export_csv.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-export-emailbison-integration/05-RESEARCH.md
@.planning/phases/05-export-emailbison-integration/05-01-SUMMARY.md
@.planning/phases/05-export-emailbison-integration/05-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/export/verification-gate.ts (Plan 01 output):
```typescript
export interface ExportReadiness {
  totalCount: number;
  readyCount: number;
  needsVerificationCount: number;
  blockedCount: number;
  verifiedEmailPct: string;
  verticalBreakdown: Record<string, number>;
  enrichmentCoverage: { companyDataPct: string; linkedinPct: string; jobTitlePct: string };
  readyPeople: Person[];     // includes phone, location fields
  needsVerificationPeople: Person[];
  blockedPeople: Person[];
}
export function getListExportReadiness(listId: string): Promise<ExportReadiness>;
export function verifyAndFilter(people: {id: string, email: string}[]): Promise<{verified: VerificationResult[], excluded: VerificationResult[]}>;
```

From src/lib/export/csv.ts (Plan 01 output):
```typescript
export function generateListCsv(listId: string): Promise<{ csv: string; filename: string; count: number }>;
```

From src/lib/emailbison/client.ts (Plan 02 output):
```typescript
export class EmailBisonClient {
  constructor(token: string);
  createCampaign(params: CreateCampaignParams): Promise<CampaignCreateResult>;
  duplicateCampaign(templateCampaignId: number): Promise<CampaignCreateResult>;
  createLead(params: CreateLeadParams): Promise<CreateLeadResult>;
  ensureCustomVariables(names: string[]): Promise<void>;
}
```

From prisma/schema.prisma (Workspace model):
```prisma
model Workspace {
  slug            String   @id
  name            String
  apiToken        String?
  slackChannelId  String?
  people          PersonWorkspace[]
  targetLists     TargetList[]
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite export.ts with TargetList-based export_to_emailbison + export_csv tools</name>
  <files>src/mcp/leads-agent/tools/export.ts</files>
  <action>
Completely rewrite `src/mcp/leads-agent/tools/export.ts`. The file exports a single function `registerExportTools(server: McpServer): void` that registers two MCP tools. Preserve the file header comment and CRITICAL stdout warning.

**Tool 1: `export_to_emailbison`** (rewritten)

Schema params:
- `list_id` (string, required) — TargetList ID (replaces old `list_name`)
- `workspace` (string, required) — Workspace slug
- `template_campaign_id` (number, optional) — If provided, duplicate this campaign (inherits email sequence). If omitted, create new campaign with auto-generated name.
- `confirm` (boolean, default false) — Set true to execute the push after reviewing summary.
- `verify_unverified` (boolean, default false) — Set true to trigger email verification for unverified people before export.

Logic flow:

**Step 1 (confirm=false, verify_unverified=false): Pre-export summary**
- Look up `TargetList` by `list_id` via `prisma.targetList.findUnique`. If not found, return error.
- Look up `Workspace` by slug via `prisma.workspace.findUnique`. **If not found, create it** via `prisma.workspace.create({ data: { slug: workspace, name: workspace } })` and inform the user: "Workspace '{workspace}' created. Note: You need to configure its apiToken before pushing leads to EmailBison."
  - **CRITICAL: This is a locked CONTEXT.md decision** — "Agent checks if a workspace exists for the client; if not, creates the workspace first." Do NOT return an error when workspace is missing.
- If workspace exists but `workspace.apiToken` is null/empty, return informational message: "Workspace '{workspace.name}' has no EmailBison API token configured. Set the apiToken in the database before pushing leads."
- Call `getListExportReadiness(list_id)` from `@/lib/export/verification-gate`
- Generate campaign name: `{workspace.name}_{list.name}_{YYYY-MM-DD}` where date is UTC today (replace spaces with underscores in workspace name and list name)
- Build summary text:
  ```
  ## Pre-Export Summary

  **List:** {list.name} ({totalCount} people)
  **Workspace:** {workspace.name} ({workspace.slug})
  **Campaign:** {campaignName} {template_campaign_id ? "(duplicated from #" + template_campaign_id + " — inherits email sequence)" : "(new — no email sequence)"}

  ### Email Verification
  - Ready (verified valid): {readyCount} ({verifiedEmailPct}%)
  - Needs verification: {needsVerificationCount}
  - Blocked (invalid/catch-all): {blockedCount}

  ### Enrichment Coverage
  - Company data: {companyDataPct}%
  - LinkedIn profiles: {linkedinPct}%
  - Job titles: {jobTitlePct}%

  ### Vertical Breakdown
  {verticalBreakdown formatted as "- {vertical}: {count}" lines}

  ### Estimated Verification Cost
  ~${needsVerificationCount * 0.05} ({needsVerificationCount} emails x $0.05/each)

  ---
  {if needsVerificationCount > 0: "⚠ Some emails are unverified. Set verify_unverified=true to verify them first, or set confirm=true to export only the {readyCount} verified leads (excluding {blockedCount + needsVerificationCount} unready)."}
  {if needsVerificationCount === 0 && blockedCount > 0: "ℹ {blockedCount} leads will be auto-excluded (invalid/catch-all emails). {readyCount} leads will be pushed."}
  {if needsVerificationCount === 0 && blockedCount === 0: "✓ All emails verified. Set confirm=true to push."}
  ```
- Return this summary text.

**Step 2 (verify_unverified=true): Trigger verification**
- Call `getListExportReadiness(list_id)` to get `needsVerificationPeople`
- If `needsVerificationCount === 0`, return "No unverified emails. Set confirm=true to export."
- Call `verifyAndFilter(needsVerificationPeople.map(p => ({id: p.id, email: p.email})))` from `@/lib/export/verification-gate`
- Build post-verification summary:
  ```
  ## Verification Complete

  - Verified as valid: {verified.length}
  - Excluded (invalid/catch-all): {excluded.length}
  {excluded list: "  - {email}: {status}" for each}

  Updated export count: {readyCount + verified.length} people
  Set confirm=true to push.
  ```
- Return this text.

**Step 3 (confirm=true): Execute push**
- Call `getListExportReadiness(list_id)` again (fresh read after potential verification)
- If `needsVerificationCount > 0`, BLOCK: return "Export blocked: {needsVerificationCount} emails still unverified. Set verify_unverified=true first."
- Exportable set = `readyPeople` (auto-excludes blocked)
- If exportable set is empty, return error "No exportable leads in this list."
- Fetch workspace to get `apiToken`: `prisma.workspace.findUnique({ where: { slug: workspace } })`
- If no `apiToken`, return error "Workspace has no EmailBison API token. Configure it before pushing."
- Create `EmailBisonClient` instance: `new EmailBisonClient(workspace.apiToken)`
- Import `EmailBisonClient` from `@/lib/emailbison/client`
- Create campaign:
  - If `template_campaign_id` provided: `client.duplicateCampaign(template_campaign_id)` — note name will be "Copy of {original}"
  - Else: `client.createCampaign({ name: campaignName })` where campaignName = `{workspace.name}_{list.name}_{YYYY-MM-DD}`
- Ensure custom variables exist: `client.ensureCustomVariables(['linkedin_url'])` — only add linkedin_url for now (we pass it as custom variable)
- Push each lead: iterate over exportable people, call `client.createLead(...)` for each. Map Person fields:
  - `firstName` → `firstName`
  - `lastName` → `lastName`
  - `email` → `email`
  - `jobTitle` → `jobTitle`
  - `company` → `company`
  - `phone` → `phone` (included in verification-gate query select)
  - `customVariables` → `[{ name: 'linkedin_url', value: person.linkedinUrl }]` (only if linkedinUrl exists)
- Track success/failure counts. Wrap each `createLead` in try/catch — log errors via `console.error`, continue with next lead.
- Build result text:
  ```
  ## Export Complete

  **Campaign:** {campaign.name} (ID: {campaign.id})
  **Leads pushed:** {successCount}/{totalExportable}
  {if failCount > 0: "**Failed:** {failCount} (see server logs)"}

  ### Next Steps
  1. Go to EmailBison: https://app.outsignal.ai
  2. Open campaign "{campaign.name}"
  3. Import the {successCount} leads from the workspace lead pool into this campaign
  4. Configure email sequence (if new campaign) or verify sequence (if duplicated)
  5. Activate campaign when ready

  {if template_campaign_id: "Note: Campaign was duplicated from #{template_campaign_id} — email sequence inherited." : "Note: Campaign was created fresh — you need to set up the email sequence."}
  ```
- Return this text.

**Tool 2: `export_csv`** (new)

Schema params:
- `list_id` (string, required) — TargetList ID
- `save_to_disk` (boolean, default false) — If true, also write CSV to filesystem at `./exports/{filename}`

Logic:
- Call `generateListCsv(list_id)` from `@/lib/export/csv`
- If `save_to_disk`:
  - `import { writeFileSync, mkdirSync } from 'fs'`
  - `import { join } from 'path'`
  - Create `./exports/` dir if it doesn't exist: `mkdirSync(join(process.cwd(), 'exports'), { recursive: true })`
  - Write file: `writeFileSync(join(process.cwd(), 'exports', filename), csv, 'utf-8')`
  - Return: `"CSV exported: ./exports/{filename} ({count} people, {csv.length} bytes)\n\nAlso available via API: GET /api/lists/{list_id}/export"`
- If not `save_to_disk`:
  - Return: `"CSV generated: {filename} ({count} people)\n\nDownload via API: GET /api/lists/{list_id}/export\n\nOr set save_to_disk=true to write to ./exports/{filename}"`
- On error (verification gate block), return the error message directly.

**Imports needed at top of file:**
```typescript
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { prisma } from "@/lib/db";
import { getListExportReadiness, verifyAndFilter } from "@/lib/export/verification-gate";
import { generateListCsv } from "@/lib/export/csv";
import { EmailBisonClient } from "@/lib/emailbison/client";
import { writeFileSync, mkdirSync } from "fs";
import { join } from "path";
```

Remove all old imports (`verifyEmail`, `getVerificationStatus` — now accessed via verification-gate module). Remove the `parseTags` helper function — no longer needed.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/mcp/leads-agent/tools/export.ts 2>&1 | head -20</automated>
  </verify>
  <done>
- `export_to_emailbison` tool accepts `list_id` (not `list_name`) and uses TargetList model
- Workspace auto-created when not found (per CONTEXT.md locked decision) — not an error
- Pre-export summary includes all CONTEXT.md required fields: lead count, verified email %, vertical breakdown, campaign details, enrichment coverage
- Verification trigger flow works: verify_unverified=true → verifyAndFilter → updated summary
- Confirm flow: creates campaign (new or duplicated), pushes leads individually, reports results with next steps
- Verification gate enforced: blocks on unverified emails, auto-excludes invalid/catch-all
- `export_csv` tool generates CSV and optionally writes to disk
- No console.log usage — only console.error for logging
- No tag-based queries — only TargetListPerson
  </done>
</task>

</tasks>

<verification>
After task completion:
1. TypeScript compiles without errors
2. `registerExportTools` registers exactly 2 tools: `export_to_emailbison` and `export_csv`
3. No references to `PersonWorkspace.tags` or `parseTags` remain in the file
4. `export_to_emailbison` uses `list_id` param (not `list_name`)
5. `EmailBisonClient` is instantiated with `workspace.apiToken` from the database
6. Workspace not found → creates workspace (not error)
</verification>

<success_criteria>
- User can push a list to EmailBison with pre-export summary showing all required fields (EXPORT-01)
- Export is blocked when any person has an unverified email (EXPORT-02)
- User can export a list as CSV via MCP tool (EXPORT-03)
- Agent creates workspace when it does not exist (CONTEXT.md locked decision)
- Agent workflow: summary → optional verification → confirm → push/export
- Campaign created via API (new or duplicated for sequence inheritance)
- Leads pushed individually to workspace pool with standard + custom fields
- Clear next-steps instructions provided (user must add leads to campaign in UI)
</success_criteria>

<output>
After completion, create `.planning/phases/05-export-emailbison-integration/05-03-SUMMARY.md`
</output>
