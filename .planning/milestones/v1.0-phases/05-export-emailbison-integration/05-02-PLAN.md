---
phase: 05-export-emailbison-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/emailbison/client.ts
  - src/lib/emailbison/types.ts
autonomous: true
requirements:
  - EXPORT-01

must_haves:
  truths:
    - "EmailBisonClient can create a new campaign via POST /campaigns"
    - "EmailBisonClient can duplicate a campaign to inherit its email sequence"
    - "EmailBisonClient can push individual leads to the workspace lead pool via POST /leads"
    - "Custom variables are ensured to exist before being used in lead creation"
    - "No endpoint assigns leads to campaigns — this limitation is accepted"
  artifacts:
    - path: "src/lib/emailbison/types.ts"
      provides: "Type definitions for campaign creation, lead creation, custom variables"
      exports: ["CreateCampaignParams", "CreateLeadParams", "CustomVariable", "CreateLeadResult", "CampaignCreateResult"]
      min_lines: 160
    - path: "src/lib/emailbison/client.ts"
      provides: "EmailBison HTTP client with campaign, lead, and custom variable management"
      exports: ["EmailBisonClient"]
      min_lines: 160
  key_links:
    - from: "src/lib/emailbison/client.ts"
      to: "src/lib/emailbison/types.ts"
      via: "import interfaces"
      pattern: "import.*from.*types"
---

<objective>
Extend the existing `EmailBisonClient` with methods for campaign creation, campaign duplication, lead creation, and custom variable management. These are the building blocks that the MCP export tool (Plan 03) will use to push verified leads to EmailBison.

Purpose: Provides the programmatic interface to EmailBison's API for automated campaign + lead management.

Output: Extended types.ts with new interfaces, extended client.ts with 7 new methods.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-export-emailbison-integration/05-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/emailbison/client.ts (existing class structure):
```typescript
export class EmailBisonClient {
  private baseUrl: string;
  private token: string;
  constructor(token: string);
  private request<T>(path: string, options?: RequestInit & { revalidate?: number }): Promise<T>;
  private getAllPages<T>(path: string): Promise<T[]>;
  // ... existing methods: getCampaigns, getLeads, getReplies, etc.
}
```

From src/lib/emailbison/types.ts (existing interfaces — append AFTER existing, BEFORE WebhookPayload):
```typescript
export interface Campaign { id: number; uuid: string; name: string; status: string; ... }
export interface Lead { id: number; email: string; first_name: string; ... }
// ... other existing interfaces
export interface WebhookPayload { ... } // <-- new interfaces go BEFORE this
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type interfaces for campaign creation, lead creation, custom variables</name>
  <files>src/lib/emailbison/types.ts</files>
  <action>
Add the following interfaces to `src/lib/emailbison/types.ts` (append after existing interfaces, before `WebhookPayload`):

```typescript
export interface CreateCampaignParams {
  name: string;
  type?: 'outbound' | 'inbound';
  maxEmailsPerDay?: number;
  maxNewLeadsPerDay?: number;
  plainText?: boolean;
}

export interface CreateLeadParams {
  firstName?: string;
  lastName?: string;
  email: string;
  jobTitle?: string;
  company?: string;
  phone?: string;
  customVariables?: { name: string; value: string }[];
}

export interface CustomVariable {
  id: number;
  name: string;
  created_at: string;
}

export interface CreateLeadResult {
  id: number;
  email: string;
  status: string;
}

export interface CampaignCreateResult {
  id: number;
  uuid: string;
  name: string;
  status: string;
  sequence_id: number | null;
}
```

These types use camelCase for params (TypeScript convention) but the client methods will map to snake_case for the API body.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/lib/emailbison/types.ts 2>&1 | head -10</automated>
  </verify>
  <done>
- `CreateCampaignParams`, `CreateLeadParams`, `CustomVariable`, `CreateLeadResult`, `CampaignCreateResult` interfaces exist in types.ts
- All interfaces exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Add campaign, lead, and custom variable methods to EmailBisonClient</name>
  <files>src/lib/emailbison/client.ts</files>
  <action>
Add the following methods to the `EmailBisonClient` class in `src/lib/emailbison/client.ts`:

1. **Import new types** — update the import at the top to include:
   `CreateCampaignParams, CreateLeadParams, CustomVariable, CreateLeadResult, CampaignCreateResult`

2. **`createCampaign(params: CreateCampaignParams): Promise<CampaignCreateResult>`**
   ```typescript
   async createCampaign(params: CreateCampaignParams): Promise<CampaignCreateResult> {
     const res = await this.request<{ data: CampaignCreateResult }>('/campaigns', {
       method: 'POST',
       body: JSON.stringify({
         name: params.name,
         type: params.type ?? 'outbound',
         max_emails_per_day: params.maxEmailsPerDay ?? 1000,
         max_new_leads_per_day: params.maxNewLeadsPerDay ?? 100,
         plain_text: params.plainText ?? true,
       }),
       revalidate: 0,
     });
     return res.data;
   }
   ```

3. **`duplicateCampaign(templateCampaignId: number): Promise<CampaignCreateResult>`**
   ```typescript
   async duplicateCampaign(templateCampaignId: number): Promise<CampaignCreateResult> {
     const res = await this.request<{ data: CampaignCreateResult }>(
       `/campaigns/${templateCampaignId}/duplicate`,
       { method: 'POST', body: JSON.stringify({}), revalidate: 0 }
     );
     return res.data;
   }
   ```
   Note: name param is IGNORED by API — always produces "Copy of {original}".

4. **`createLead(params: CreateLeadParams): Promise<CreateLeadResult>`**
   ```typescript
   async createLead(params: CreateLeadParams): Promise<CreateLeadResult> {
     const body: Record<string, unknown> = {
       email: params.email,
     };
     if (params.firstName) body.first_name = params.firstName;
     if (params.lastName) body.last_name = params.lastName;
     if (params.jobTitle) body.title = params.jobTitle;
     if (params.company) body.company = params.company;
     if (params.phone) body.phone = params.phone;
     if (params.customVariables?.length) {
       body.custom_variables = params.customVariables;
     }
     const res = await this.request<{ data: CreateLeadResult }>('/leads', {
       method: 'POST',
       body: JSON.stringify(body),
       revalidate: 0,
     });
     return res.data;
   }
   ```

5. **`getCustomVariables(): Promise<CustomVariable[]>`**
   ```typescript
   async getCustomVariables(): Promise<CustomVariable[]> {
     return this.getAllPages<CustomVariable>('/custom-variables');
   }
   ```

6. **`createCustomVariable(name: string): Promise<CustomVariable>`**
   ```typescript
   async createCustomVariable(name: string): Promise<CustomVariable> {
     const res = await this.request<{ data: CustomVariable }>('/custom-variables', {
       method: 'POST',
       body: JSON.stringify({ name }),
       revalidate: 0,
     });
     return res.data;
   }
   ```

7. **`ensureCustomVariables(names: string[]): Promise<void>`** — idempotent helper that checks existing custom vars and creates any that are missing:
   ```typescript
   async ensureCustomVariables(names: string[]): Promise<void> {
     const existing = await this.getCustomVariables();
     const existingNames = new Set(existing.map(v => v.name));
     for (const name of names) {
       if (!existingNames.has(name)) {
         await this.createCustomVariable(name);
       }
     }
   }
   ```

All methods use `revalidate: 0` to disable caching on write operations. The `request` method is already `private` on the class — these new methods are public and call it.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/lib/emailbison/client.ts 2>&1 | head -10</automated>
  </verify>
  <done>
- `createCampaign` method exists and maps camelCase params to snake_case API body
- `duplicateCampaign` method exists with note about name limitation
- `createLead` method exists with conditional field inclusion and custom_variables support
- `getCustomVariables` and `createCustomVariable` methods exist
- `ensureCustomVariables` idempotent helper exists
- All methods compile cleanly against existing types
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. TypeScript compiles without errors for both files
2. `EmailBisonClient` has 7 new methods: `createCampaign`, `duplicateCampaign`, `createLead`, `getCustomVariables`, `createCustomVariable`, `ensureCustomVariables`
3. All new type interfaces are exported from `types.ts`
4. No changes to existing methods (getCampaigns, getLeads, getReplies, etc.)
</verification>

<success_criteria>
- EmailBison client can create campaigns with custom names
- EmailBison client can duplicate campaigns (inheriting email sequences)
- EmailBison client can push leads to workspace pool with standard + custom fields
- Custom variables are auto-created if missing before lead push
</success_criteria>

<output>
After completion, create `.planning/phases/05-export-emailbison-integration/05-02-SUMMARY.md`
</output>
