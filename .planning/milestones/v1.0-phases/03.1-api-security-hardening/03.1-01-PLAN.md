---
phase: 03.1-api-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/cron-auth.ts
  - src/app/api/enrichment/run/route.ts
  - src/app/api/enrichment/jobs/process/route.ts
  - .mcp.json
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "POST /api/enrichment/run rejects requests without valid Authorization: Bearer <CRON_SECRET> header with 401"
    - "POST /api/enrichment/jobs/process rejects requests without valid Authorization: Bearer <CRON_SECRET> header with 401"
    - "Both routes continue to work normally when correct CRON_SECRET is provided"
    - "MCP server receives FIRECRAWL_API_KEY, ANTHROPIC_API_KEY, and LEADMAGIC_API_KEY via env forwarding"
  artifacts:
    - path: "src/lib/cron-auth.ts"
      provides: "validateCronSecret helper using crypto.timingSafeEqual"
      exports: ["validateCronSecret"]
    - path: ".mcp.json"
      provides: "MCP server env var forwarding for all required API keys"
      contains: "FIRECRAWL_API_KEY"
  key_links:
    - from: "src/app/api/enrichment/run/route.ts"
      to: "src/lib/cron-auth.ts"
      via: "import validateCronSecret"
      pattern: "validateCronSecret"
    - from: "src/app/api/enrichment/jobs/process/route.ts"
      to: "src/lib/cron-auth.ts"
      via: "import validateCronSecret"
      pattern: "validateCronSecret"
---

<objective>
Protect enrichment API routes from unauthorized access and fix MCP env var forwarding.

Purpose: Close INT-01 gap — the two enrichment trigger routes (`/api/enrichment/run` and `/api/enrichment/jobs/process`) currently accept unauthenticated POST requests. Anyone with the URL can trigger paid API calls. Also, the MCP server is missing three API key env vars needed for enrichment, ICP scoring, and email verification.

Output: `src/lib/cron-auth.ts` auth helper, hardened route handlers, updated `.mcp.json`
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-api-security-hardening/03.1-RESEARCH.md

@src/app/api/enrichment/run/route.ts
@src/app/api/enrichment/jobs/process/route.ts
@.mcp.json
</context>

<interfaces>
<!-- Key types the executor needs -->

From src/lib/enrichment/queue.ts:
```typescript
export interface ChunkResult {
  jobId: string;
  processed: number;
  total: number;
  done: boolean;
  status: string;
}
export function enqueueJob(params: EnqueueJobParams): Promise<string>;
export function processNextChunk(onProcess?: Function): Promise<ChunkResult | null>;
```

From next/server (already imported in run/route.ts):
```typescript
import { NextResponse, type NextRequest } from "next/server";
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create validateCronSecret helper and harden both route handlers</name>
  <files>
    src/lib/cron-auth.ts
    src/app/api/enrichment/run/route.ts
    src/app/api/enrichment/jobs/process/route.ts
  </files>
  <action>
**Create `src/lib/cron-auth.ts`:**

```typescript
import { timingSafeEqual } from "crypto";

export function validateCronSecret(req: Request): boolean {
  const secret = process.env.CRON_SECRET;
  if (!secret) {
    console.warn("[cron-auth] CRON_SECRET not configured — rejecting request");
    return false;
  }

  const authHeader = req.headers.get("authorization") ?? "";
  const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";

  if (!token) return false;

  try {
    const secretBuf = Buffer.from(secret);
    const tokenBuf = Buffer.from(token);
    if (secretBuf.length !== tokenBuf.length) return false;
    return timingSafeEqual(secretBuf, tokenBuf);
  } catch {
    return false;
  }
}
```

Key decisions (per CONTEXT.md — locked):
- Accept `Request` (not `NextRequest`) — minimal interface, only needs `.headers.get()`
- `crypto.timingSafeEqual()` for constant-time comparison — prevents timing attacks
- Fail closed when CRON_SECRET is not configured (return false)
- Check buffer lengths before `timingSafeEqual` to prevent ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH throw
- Log warning to console when CRON_SECRET not configured — visible in Vercel logs

**Modify `src/app/api/enrichment/run/route.ts`:**

Add import at top:
```typescript
import { validateCronSecret } from "@/lib/cron-auth";
```

Add auth check as the FIRST lines inside the POST handler, before `const body = await request.json()`:
```typescript
if (!validateCronSecret(request)) {
  console.log(`[${new Date().toISOString()}] Unauthorized: POST /api/enrichment/run`);
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}
```

Per CONTEXT.md: Return generic 401 with `{"error": "Unauthorized"}` — no details about auth mechanism. Log failed attempts to console only (timestamp + route).

**Modify `src/app/api/enrichment/jobs/process/route.ts`:**

The current signature is `export async function POST()` (no request parameter). Update to accept request:
```typescript
export async function POST(request: Request) {
```

Add import at top:
```typescript
import { validateCronSecret } from "@/lib/cron-auth";
```

Add auth check as the FIRST lines inside the POST handler, before `const breaker = createCircuitBreaker()`:
```typescript
if (!validateCronSecret(request)) {
  console.log(`[${new Date().toISOString()}] Unauthorized: POST /api/enrichment/jobs/process`);
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}
```

Use `Request` (not `NextRequest`) for the parameter type since the handler doesn't use any NextRequest-specific features.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | grep -E "cron-auth|enrichment/run|jobs/process" | head -20; echo "---"; grep -n "validateCronSecret" src/lib/cron-auth.ts src/app/api/enrichment/run/route.ts src/app/api/enrichment/jobs/process/route.ts</automated>
  </verify>
  <done>
    - `validateCronSecret` helper exists at `src/lib/cron-auth.ts` and compiles cleanly
    - `/api/enrichment/run` POST handler calls `validateCronSecret(request)` before any business logic
    - `/api/enrichment/jobs/process` POST handler accepts `request: Request` parameter and calls `validateCronSecret(request)` before any business logic
    - Both routes return `{"error": "Unauthorized"}` with status 401 when auth fails
    - Both routes log unauthorized attempts with timestamp and route path
  </done>
</task>

<task type="auto">
  <name>Task 2: Add missing env vars to .mcp.json</name>
  <files>.mcp.json</files>
  <action>
Update `.mcp.json` to forward three additional env vars to the MCP server. Add to the `env` object inside `mcpServers.outsignal-leads`:

```json
{
  "mcpServers": {
    "outsignal-leads": {
      "command": "npx",
      "args": ["tsx", "src/mcp/leads-agent/index.ts"],
      "env": {
        "DATABASE_URL": "${DATABASE_URL}",
        "FIRECRAWL_API_KEY": "${FIRECRAWL_API_KEY}",
        "ANTHROPIC_API_KEY": "${ANTHROPIC_API_KEY}",
        "LEADMAGIC_API_KEY": "${LEADMAGIC_API_KEY}"
      }
    }
  }
}
```

Use `${VAR}` syntax (with braces) — this is the MCP spec format, NOT shell expansion. The existing `DATABASE_URL` entry shows the correct pattern.

Why these three:
- `FIRECRAWL_API_KEY`: Used by `firecrawl-company.ts` for ICP website crawling
- `ANTHROPIC_API_KEY`: Used by `@ai-sdk/anthropic` (normalizer, ICP scorer, leads agent runner)
- `LEADMAGIC_API_KEY`: Used by `leadmagic.ts` for email verification
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && node -e "const j = require('./.mcp.json'); const env = j.mcpServers['outsignal-leads'].env; const expected = ['DATABASE_URL','FIRECRAWL_API_KEY','ANTHROPIC_API_KEY','LEADMAGIC_API_KEY']; const missing = expected.filter(k => !env[k]); if (missing.length) { console.error('MISSING:', missing); process.exit(1); } console.log('All env vars present:', Object.keys(env));"</automated>
  </verify>
  <done>
    - `.mcp.json` contains `FIRECRAWL_API_KEY`, `ANTHROPIC_API_KEY`, and `LEADMAGIC_API_KEY` in the env block
    - All use `${VAR}` syntax matching the existing `DATABASE_URL` pattern
    - JSON is valid and parseable
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors in modified files
2. `grep -n "validateCronSecret" src/lib/cron-auth.ts src/app/api/enrichment/run/route.ts src/app/api/enrichment/jobs/process/route.ts` shows the helper is defined and imported in both routes
3. `node -e "const j = require('./.mcp.json'); console.log(Object.keys(j.mcpServers['outsignal-leads'].env))"` outputs all 4 env vars
4. `grep "timingSafeEqual" src/lib/cron-auth.ts` confirms constant-time comparison is used
</verification>

<success_criteria>
- Unauthenticated POST to `/api/enrichment/run` returns 401 `{"error": "Unauthorized"}`
- Unauthenticated POST to `/api/enrichment/jobs/process` returns 401 `{"error": "Unauthorized"}`
- Authenticated POST (with correct `Authorization: Bearer <CRON_SECRET>`) passes through to existing handler logic
- `.mcp.json` forwards all 4 required env vars to the MCP server
- No new TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-api-security-hardening/03.1-01-SUMMARY.md`
</output>
