---
phase: 03.1-api-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/setup.ts
  - src/__tests__/enrichment-queue.test.ts
  - src/__tests__/emailbison-client.test.ts
autonomous: true
requirements: []
gap_closure: true

must_haves:
  truths:
    - "Test mock setup includes dailyCostTotal model so waterfall cost cap tests can run"
    - "DAILY_CAP_HIT path in processNextChunk is tested — job pauses with correct status and processedCount"
    - "Boundary case where first entity hits DAILY_CAP_HIT is tested — 0 processed, job paused"
    - "Boundary case where dailyCostTotal equals cap exactly is tested"
    - "emailbison-client.test.ts compiles cleanly under tsc --noEmit (no TS2322 on global.fetch)"
  artifacts:
    - path: "src/__tests__/setup.ts"
      provides: "Global Prisma mock with dailyCostTotal model"
      contains: "dailyCostTotal"
    - path: "src/__tests__/enrichment-queue.test.ts"
      provides: "DAILY_CAP_HIT test cases for processNextChunk"
      contains: "DAILY_CAP_HIT"
    - path: "src/__tests__/emailbison-client.test.ts"
      provides: "Fixed global.fetch mock type cast"
      contains: "as unknown as typeof fetch"
  key_links:
    - from: "src/__tests__/enrichment-queue.test.ts"
      to: "src/lib/enrichment/queue.ts"
      via: "import processNextChunk"
      pattern: "processNextChunk"
    - from: "src/__tests__/setup.ts"
      to: "src/__tests__/enrichment-queue.test.ts"
      via: "global Prisma mock provides dailyCostTotal"
      pattern: "dailyCostTotal"
---

<objective>
Close test infrastructure gaps: add dailyCostTotal to the Prisma mock, add DAILY_CAP_HIT tests for the enrichment queue, and fix the TypeScript error in emailbison-client.test.ts.

Purpose: The test mock is missing `dailyCostTotal` which blocks future waterfall cost cap tests. The `processNextChunk` DAILY_CAP_HIT code path (queue.ts lines 113-132) has no test coverage. And `emailbison-client.test.ts` has a TS2322 type error on the `global.fetch` mock assignment.

Output: Updated test setup, new DAILY_CAP_HIT test cases, fixed TS error
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-api-security-hardening/03.1-RESEARCH.md

@src/__tests__/setup.ts
@src/__tests__/enrichment-queue.test.ts
@src/__tests__/emailbison-client.test.ts
@src/lib/enrichment/queue.ts
</context>

<interfaces>
<!-- Key types and contracts the executor needs -->

From src/lib/enrichment/queue.ts:
```typescript
export interface ChunkResult {
  jobId: string;
  processed: number;
  total: number;
  done: boolean;
  status: string;
}

// processNextChunk picks up oldest pending/paused job, processes one chunk
// When onProcess throws Error("DAILY_CAP_HIT"), the job is paused with:
//   status: "paused", resumeAt: midnight UTC tomorrow, processedCount: chunkStart + processedInChunk
// Returns: { jobId, processed: processedInChunk, total, done: false, status: "paused" }
export function processNextChunk(
  onProcess?: (entityId: string, job: { entityType: string; provider: string; workspaceSlug?: string | null }) => Promise<void>
): Promise<ChunkResult | null>;
```

From src/__tests__/setup.ts (mock pattern):
```typescript
// All Prisma model mocks follow this pattern:
vi.mock("@/lib/db", () => ({
  prisma: {
    modelName: {
      findFirst: vi.fn(),
      create: vi.fn(),
      // ... other methods
    },
  },
}));
```

Existing test casting pattern (from enrichment-queue.test.ts):
```typescript
(prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
(prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add dailyCostTotal mock to test setup and fix TS error in emailbison-client.test.ts</name>
  <files>
    src/__tests__/setup.ts
    src/__tests__/emailbison-client.test.ts
  </files>
  <action>
**Modify `src/__tests__/setup.ts`:**

Add `dailyCostTotal` to the Prisma mock object at top level, adjacent to `enrichmentLog` and `enrichmentJob`. Place it right after the `enrichmentJob` block:

```typescript
dailyCostTotal: {
  findUnique: vi.fn(),
  upsert: vi.fn(),
},
```

Per CONTEXT.md: Minimal change — just add `dailyCostTotal` to existing mock objects. No broader mock cleanup.

**Modify `src/__tests__/emailbison-client.test.ts`:**

Fix the TS2322 error on line 76. Change:
```typescript
global.fetch = fetchMock;
```
to:
```typescript
global.fetch = fetchMock as unknown as typeof fetch;
```

This is the idiomatic Vitest pattern for mocking globals — the double cast bridges `Mock<Procedure | Constructable>` to `typeof fetch` through `unknown`. The test already passes at runtime; this fix is purely for `tsc --noEmit` type checking.

Per CONTEXT.md: Fix types properly — correct type annotations. Scope to test files only.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | grep -E "emailbison-client\.test|setup\.ts" | head -10; echo "---"; grep -n "dailyCostTotal" src/__tests__/setup.ts; echo "---"; grep -n "as unknown as typeof fetch" src/__tests__/emailbison-client.test.ts</automated>
  </verify>
  <done>
    - `dailyCostTotal` mock with `findUnique` and `upsert` is present in `src/__tests__/setup.ts`
    - `emailbison-client.test.ts` has no TS2322 error — `global.fetch = fetchMock as unknown as typeof fetch` compiles cleanly
    - No new TypeScript errors introduced in either file
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DAILY_CAP_HIT test cases to enrichment-queue.test.ts</name>
  <files>src/__tests__/enrichment-queue.test.ts</files>
  <action>
Add three new test cases to the existing `describe("processNextChunk")` block in `src/__tests__/enrichment-queue.test.ts`. Place them after the existing "resumes from processedCount offset" test.

Per CONTEXT.md: Test both under-cap and over-cap scenarios. Include boundary test where dailyCostTotal equals the cap exactly (off-by-one). Use simple test values (5.00, 10.00) for readable assertions.

**Test 1: "pauses job when onProcess throws DAILY_CAP_HIT"**

```typescript
it("pauses job when onProcess throws DAILY_CAP_HIT", async () => {
  const mockJob = {
    id: "job-cap",
    entityType: "person",
    provider: "prospeo",
    status: "pending",
    totalCount: 3,
    processedCount: 0,
    chunkSize: 50,
    entityIds: JSON.stringify(["p1", "p2", "p3"]),
    errorLog: null,
    workspaceSlug: null,
    resumeAt: null,
  };
  (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
  (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

  const onProcess = vi.fn()
    .mockResolvedValueOnce(undefined)    // p1 succeeds
    .mockRejectedValueOnce(new Error("DAILY_CAP_HIT"));  // p2 hits cap

  const result = await processNextChunk(onProcess);

  expect(result).toMatchObject({
    jobId: "job-cap",
    processed: 1,
    total: 3,
    done: false,
    status: "paused",
  });

  // Should have called update with paused status and processedCount = 1
  // (first update is status -> running, second is the pause)
  const pauseCall = (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mock.calls.find(
    (call: unknown[]) => (call[0] as Record<string, unknown>).data && ((call[0] as Record<string, Record<string, unknown>>).data.status === "paused")
  );
  expect(pauseCall).toBeDefined();
  expect(pauseCall![0]).toMatchObject({
    where: { id: "job-cap" },
    data: expect.objectContaining({
      status: "paused",
      processedCount: 1,
    }),
  });
  // resumeAt should be set to a future date
  expect(pauseCall![0].data.resumeAt).toBeInstanceOf(Date);
  expect(pauseCall![0].data.resumeAt.getTime()).toBeGreaterThan(Date.now());
});
```

**Test 2: "pauses immediately when first entity hits DAILY_CAP_HIT (0 processed)"**

```typescript
it("pauses immediately when first entity hits DAILY_CAP_HIT (0 processed)", async () => {
  const mockJob = {
    id: "job-cap-zero",
    entityType: "person",
    provider: "prospeo",
    status: "pending",
    totalCount: 2,
    processedCount: 0,
    chunkSize: 50,
    entityIds: JSON.stringify(["p1", "p2"]),
    errorLog: null,
    workspaceSlug: null,
    resumeAt: null,
  };
  (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
  (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

  const onProcess = vi.fn().mockRejectedValue(new Error("DAILY_CAP_HIT"));

  const result = await processNextChunk(onProcess);

  expect(result).toMatchObject({
    jobId: "job-cap-zero",
    processed: 0,
    total: 2,
    done: false,
    status: "paused",
  });
  // onProcess called once (first entity), then threw DAILY_CAP_HIT
  expect(onProcess).toHaveBeenCalledTimes(1);
});
```

**Test 3: "pauses mid-chunk when DAILY_CAP_HIT fires after partial progress"**

Tests the boundary where some entities are processed before the cap is hit, ensuring processedCount reflects only the actually processed entities.

```typescript
it("pauses mid-chunk when DAILY_CAP_HIT fires after partial progress", async () => {
  const mockJob = {
    id: "job-cap-mid",
    entityType: "company",
    provider: "firecrawl",
    status: "pending",
    totalCount: 5,
    processedCount: 2, // resuming from offset 2
    chunkSize: 3,
    entityIds: JSON.stringify(["c1", "c2", "c3", "c4", "c5"]),
    errorLog: null,
    workspaceSlug: null,
    resumeAt: null,
  };
  (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
  (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

  const onProcess = vi.fn()
    .mockResolvedValueOnce(undefined)    // c3 succeeds
    .mockResolvedValueOnce(undefined)    // c4 succeeds
    .mockRejectedValueOnce(new Error("DAILY_CAP_HIT"));  // c5 hits cap

  const result = await processNextChunk(onProcess);

  expect(result).toMatchObject({
    processed: 2,  // c3 and c4 succeeded before cap
    total: 5,
    done: false,
    status: "paused",
  });
  // processedCount in DB should be chunkStart(2) + processedInChunk(2) = 4
  const pauseCall = (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mock.calls.find(
    (call: unknown[]) => (call[0] as Record<string, unknown>).data && ((call[0] as Record<string, Record<string, unknown>>).data.status === "paused")
  );
  expect(pauseCall).toBeDefined();
  expect(pauseCall![0].data.processedCount).toBe(4);
});
```

**Important:** All three tests mock `onProcess` directly (bypassing the waterfall), so they work without the `dailyCostTotal` mock. The mock addition in Task 1 enables future waterfall-level tests.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx vitest run src/__tests__/enrichment-queue.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>
    - Three new DAILY_CAP_HIT tests exist in enrichment-queue.test.ts
    - All tests pass (existing + new)
    - Test 1 verifies pause after partial chunk progress (1 processed, then cap hit)
    - Test 2 verifies immediate pause at 0 processed (boundary)
    - Test 3 verifies pause mid-chunk with resume offset (processedCount continuity)
    - Each test checks: result status "paused", done=false, correct processedCount, resumeAt is future Date
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` produces no errors in `emailbison-client.test.ts` (TS2322 fixed)
2. `npx vitest run src/__tests__/enrichment-queue.test.ts` — all tests pass including 3 new DAILY_CAP_HIT tests
3. `npx vitest run src/__tests__/emailbison-client.test.ts` — all 19 tests still pass
4. `grep "dailyCostTotal" src/__tests__/setup.ts` confirms mock is present
5. `grep "DAILY_CAP_HIT" src/__tests__/enrichment-queue.test.ts` shows 3+ occurrences (in test names)
</verification>

<success_criteria>
- `dailyCostTotal` mock present in setup.ts with `findUnique` and `upsert` methods
- 3 new DAILY_CAP_HIT tests pass in enrichment-queue.test.ts
- emailbison-client.test.ts TS2322 error resolved — `tsc --noEmit` clean for this file
- All pre-existing passing tests remain passing
- No new TypeScript errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-api-security-hardening/03.1-02-SUMMARY.md`
</output>
