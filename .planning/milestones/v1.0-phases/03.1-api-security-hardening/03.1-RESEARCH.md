# Phase 3.1: API Security + Hardening - Research

**Researched:** 2026-02-26
**Domain:** Next.js Route Auth, Node.js crypto, MCP env forwarding, TypeScript test fixes
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Auth error responses
- Return generic 401 with `{"error": "Unauthorized"}` — no details about auth mechanism
- Log failed auth attempts to console only (timestamp + route) — visible in Vercel logs
- No Slack alerts or active notification on failed attempts
- Bare 401 response — no rate-limiting headers (rate limiting is a separate concern)
- Auth check applies to POST requests only — GET requests stay open

#### Auth boundary pattern
- Shared helper function `validateCronSecret(req)` that each route calls at the top — explicit, per-route
- No Next.js middleware — keep auth visible in route handlers
- Read CRON_SECRET from `Authorization: Bearer <CRON_SECRET>` header — standard pattern for Vercel cron
- Use `crypto.timingSafeEqual()` for secret comparison — prevent timing attacks
- Protect only the two specified routes: `/api/enrichment/run` and `/api/enrichment/jobs/process` — don't audit other routes

#### TypeScript error fixes
- Fix types properly — correct type annotations, fix mismatched types, update interfaces
- Update source types if needed — if a shared type/interface is wrong, fix at the source
- Fix under current tsconfig settings — don't tighten strictness as part of this phase
- Scope to test files only — don't fix unrelated TS errors elsewhere in the codebase

#### Test mock strategy
- Minimal change — just add `dailyCostTotal` to existing mock objects
- Use simple test values (e.g., 5.00, 10.00) for readable assertions
- Test both under-cap and over-cap scenarios for waterfall cost cap
- Include boundary test where `dailyCostTotal` equals the cap exactly — catch off-by-one issues
- No broader mock cleanup — keep the diff small

### Claude's Discretion
- Exact placement and signature of `validateCronSecret` helper function
- Which test files have TypeScript errors and how to fix each
- Mock object structure details beyond adding `dailyCostTotal`

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

## Summary

This phase closes three concrete gaps identified in the v1.0 milestone audit: (1) missing auth guard on two enrichment API routes, (2) missing env var forwarding in `.mcp.json`, and (3) test infrastructure gaps (missing `dailyCostTotal` mock, one pre-existing TypeScript error). No new features are introduced — this is pure hardening.

The auth implementation is well-defined: a `validateCronSecret(req)` helper using Node.js built-in `crypto.timingSafeEqual()` placed in `src/lib/auth.ts` (or similar), called at the top of the two route handlers. The `.mcp.json` fix is a one-line-per-key change. The test fixes are surgical.

The two pre-existing test failures in `api-routes.test.ts` and `resend-notifications.test.ts` are **not** TypeScript errors and are **not** in scope — the CONTEXT.md scopes TypeScript fixes to test files, and these failures are runtime assertion failures caused by `request.nextUrl.searchParams` not existing on the `Request` mock. The **single** TypeScript error that is in scope is in `emailbison-client.test.ts` line 76 (`global.fetch` mock type mismatch).

**Primary recommendation:** Implement in three discrete tasks: (1) `validateCronSecret` helper + route hardening, (2) `.mcp.json` env var fix, (3) `dailyCostTotal` mock + waterfall cost cap tests + TS error fix in emailbison-client.test.ts.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `crypto` (Node.js built-in) | Node 18+ | `timingSafeEqual()` for constant-time comparison | Built-in, no dep, prevents timing attacks |
| `next/server` `NextRequest` | 16.1.6 | Request type with `.headers.get()` | Already used in both routes |
| `vitest` | 4.0.18 | Test framework | Already configured, all tests use it |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `Buffer` (Node.js built-in) | Node 18+ | Convert strings to buffers for `timingSafeEqual` | Required — `timingSafeEqual` needs `Uint8Array` |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `crypto.timingSafeEqual` | Simple `===` comparison | `===` is vulnerable to timing attacks — rejected by user decision |
| Next.js middleware | Per-route helper | Middleware approach rejected by user — auth must be explicit in route handler |
| `x-vercel-cron` header | `Authorization: Bearer` | Vercel injects `x-vercel-cron` for actual cron jobs but `Bearer` is standard for triggered calls — user chose `Bearer` |

**Installation:** No new packages required — all tools are already in the project.

---

## Architecture Patterns

### Recommended Project Structure

The helper belongs alongside other lib utilities. The project already has `src/lib/crypto.ts`, `src/lib/tokens.ts`, `src/lib/portal-auth.ts`. A new `src/lib/cron-auth.ts` or `src/lib/auth.ts` file is the right place.

```
src/
├── lib/
│   └── cron-auth.ts     # NEW: validateCronSecret helper
├── app/api/enrichment/
│   ├── run/route.ts     # MODIFY: add auth check
│   └── jobs/process/route.ts  # MODIFY: add auth check
├── __tests__/
│   ├── setup.ts         # MODIFY: add dailyCostTotal mock
│   └── enrichment-queue.test.ts  # MODIFY: add cost cap tests
.mcp.json                # MODIFY: add 3 env var entries
```

### Pattern 1: `validateCronSecret` Helper

**What:** Reads `Authorization: Bearer <token>` header from the request, compares to `CRON_SECRET` env var using `crypto.timingSafeEqual()`.

**When to use:** Called at the top of each protected POST handler before any other logic.

**Example:**
```typescript
// src/lib/cron-auth.ts
import { timingSafeEqual } from "crypto";

export function validateCronSecret(req: Request): boolean {
  const secret = process.env.CRON_SECRET;
  if (!secret) {
    // No secret configured — fail closed (deny all)
    console.warn("[cron-auth] CRON_SECRET not configured — rejecting request");
    return false;
  }

  const authHeader = req.headers.get("authorization") ?? "";
  const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";

  if (!token) return false;

  try {
    const secretBuf = Buffer.from(secret);
    const tokenBuf = Buffer.from(token);
    // timingSafeEqual requires equal-length buffers
    if (secretBuf.length !== tokenBuf.length) return false;
    return timingSafeEqual(secretBuf, tokenBuf);
  } catch {
    return false;
  }
}
```

### Pattern 2: Route Usage

**What:** Call `validateCronSecret` at the top of the POST handler, before any DB or business logic.

**Example:**
```typescript
// In POST handler — placed FIRST, before any other logic
import { validateCronSecret } from "@/lib/cron-auth";

export async function POST(request: NextRequest) {
  if (!validateCronSecret(request)) {
    console.log(`[${new Date().toISOString()}] Unauthorized request to /api/enrichment/run`);
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  // ... existing handler logic unchanged ...
}
```

### Pattern 3: `.mcp.json` Env Var Forwarding

**What:** Claude Desktop / Claude Code reads `.mcp.json` to launch MCP servers. The `env` block explicitly forwards env vars using `${VAR}` syntax. Currently only `DATABASE_URL` is forwarded — the three API key vars must be added.

**Current state:**
```json
{
  "mcpServers": {
    "outsignal-leads": {
      "command": "npx",
      "args": ["tsx", "src/mcp/leads-agent/index.ts"],
      "env": {
        "DATABASE_URL": "${DATABASE_URL}"
      }
    }
  }
}
```

**Fixed state:**
```json
{
  "mcpServers": {
    "outsignal-leads": {
      "command": "npx",
      "args": ["tsx", "src/mcp/leads-agent/index.ts"],
      "env": {
        "DATABASE_URL": "${DATABASE_URL}",
        "FIRECRAWL_API_KEY": "${FIRECRAWL_API_KEY}",
        "ANTHROPIC_API_KEY": "${ANTHROPIC_API_KEY}",
        "LEADMAGIC_API_KEY": "${LEADMAGIC_API_KEY}"
      }
    }
  }
}
```

**Why these three:** `FIRECRAWL_API_KEY` is used by `firecrawl-company.ts`, `ANTHROPIC_API_KEY` is used by `@ai-sdk/anthropic` (normalizer, ICP scorer, leads agent runner), and `LEADMAGIC_API_KEY` is used by `leadmagic.ts`. All three are called via MCP tools in the leads agent.

### Pattern 4: `dailyCostTotal` Mock Addition

**What:** `src/__tests__/setup.ts` currently mocks the Prisma client globally but omits `dailyCostTotal`. This prevents tests from exercising the cost cap path in `waterfall.ts` (which calls `prisma.dailyCostTotal.findUnique` inside `checkDailyCap()`).

**Current setup.ts** (relevant excerpt — no `dailyCostTotal` mock):
```typescript
vi.mock("@/lib/db", () => ({
  prisma: {
    enrichmentJob: { findFirst: vi.fn(), create: vi.fn(), update: vi.fn(), findMany: vi.fn() },
    // ... other models
    // dailyCostTotal is MISSING
  },
}));
```

**Fix — add to the mock object:**
```typescript
dailyCostTotal: {
  findUnique: vi.fn(),
  upsert: vi.fn(),
},
```

### Pattern 5: Waterfall Cost Cap Tests

**What:** The `enrichment-queue.test.ts` file tests `processNextChunk` but has no test exercising the DAILY_CAP_HIT path. This path exists in `queue.ts` lines 113-132 — when `onProcess` throws `new Error("DAILY_CAP_HIT")`, the job is paused until midnight UTC.

**Tests to add in `enrichment-queue.test.ts`:**
```typescript
it("pauses job when onProcess throws DAILY_CAP_HIT", async () => {
  const mockJob = {
    id: "job-cap",
    entityType: "person",
    provider: "prospeo",
    status: "pending",
    totalCount: 3,
    processedCount: 0,
    chunkSize: 50,
    entityIds: JSON.stringify(["p1", "p2", "p3"]),
    errorLog: null,
  };
  (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
  (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

  const onProcess = vi.fn()
    .mockResolvedValueOnce(undefined)    // p1 succeeds
    .mockRejectedValueOnce(new Error("DAILY_CAP_HIT"));  // p2 hits cap

  const result = await processNextChunk(onProcess);

  expect(result).toMatchObject({ jobId: "job-cap", done: false, status: "paused" });
  expect(prisma.enrichmentJob.update).toHaveBeenCalledWith(
    expect.objectContaining({
      data: expect.objectContaining({ status: "paused", processedCount: 1 }),
    }),
  );
});

it("pauses immediately when first entity hits DAILY_CAP_HIT (boundary: 0 processed)", async () => {
  const mockJob = {
    id: "job-cap-boundary",
    entityType: "person",
    provider: "prospeo",
    status: "pending",
    totalCount: 2,
    processedCount: 0,
    chunkSize: 50,
    entityIds: JSON.stringify(["p1", "p2"]),
    errorLog: null,
  };
  (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
  (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

  const onProcess = vi.fn().mockRejectedValue(new Error("DAILY_CAP_HIT"));

  const result = await processNextChunk(onProcess);

  expect(result).toMatchObject({ done: false, status: "paused", processed: 0 });
});
```

Note: The cost cap logic in `waterfall.ts` uses `checkDailyCap()` which calls `prisma.dailyCostTotal.findUnique`. To write tests that exercise the full path (waterfall → queue), `dailyCostTotal` must be in the mock. The `enrichment-queue.test.ts` tests mock `onProcess` directly (bypassing the waterfall), so they work without `dailyCostTotal`. The mock addition is needed for any future waterfall-level tests.

### Pattern 6: TypeScript Error Fix in `emailbison-client.test.ts`

**The error (line 76):**
```
src/__tests__/emailbison-client.test.ts(76,5): error TS2322: Type 'Mock<Procedure | Constructable>' is not assignable to type '{ (input: URL | RequestInfo, init?: RequestInit | undefined): Promise<Response>; ... }'
```

**Root cause:** `global.fetch = fetchMock` — TypeScript complains because `vi.fn()` return type (`Mock<Procedure | Constructable>`) doesn't match `typeof fetch` signature in the global scope.

**Fix — cast with `as unknown as typeof fetch`:**
```typescript
// Before (line 76):
global.fetch = fetchMock;

// After:
global.fetch = fetchMock as unknown as typeof fetch;
```

This is the idiomatic Vitest pattern for mocking globals — the double cast goes through `unknown` to bridge type systems without modifying `vi.fn()` typing.

**Important note:** The test **passes at runtime** (vitest run shows 19/19 pass for emailbison-client). This is a static TypeScript type error only — `tsc --noEmit` catches it but `vitest run` does not. The fix is purely type-level.

### Anti-Patterns to Avoid
- **Middleware-based auth:** User explicitly rejected this — auth must be visible in route handlers.
- **`===` string comparison for secrets:** Vulnerable to timing attacks — `timingSafeEqual` is mandatory.
- **Mismatched buffer lengths:** `timingSafeEqual` throws if buffers differ in length — must check length first (or catch the exception).
- **Adding `dailyCostTotal` via spread without type guard:** The Prisma mock object uses `vi.fn()` directly — don't add `dailyCostTotal: prisma.dailyCostTotal` (circular); add fresh `vi.fn()` calls.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Timing-safe comparison | Custom bit-loop comparison | `crypto.timingSafeEqual()` | Node built-in, correct, standard |
| Fetch mock typing | Custom fetch mock type shim | `as unknown as typeof fetch` cast | Idiomatic Vitest pattern, zero boilerplate |

**Key insight:** For auth helpers in Next.js API routes, `crypto.timingSafeEqual` is available in Node.js 18+ (the runtime used by Vercel). No extra packages needed.

---

## Common Pitfalls

### Pitfall 1: Unequal Buffer Lengths Throw in timingSafeEqual
**What goes wrong:** `crypto.timingSafeEqual(a, b)` throws `ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH` when buffers have different lengths.
**Why it happens:** The function requires equal-length inputs to prevent length-based timing attacks.
**How to avoid:** Check `secretBuf.length !== tokenBuf.length` and return `false` before calling `timingSafeEqual`. Alternatively wrap in try/catch.
**Warning signs:** Test with a short token will throw instead of returning false.

### Pitfall 2: CRON_SECRET Not Set Returns Different Error Than Wrong Secret
**What goes wrong:** If `CRON_SECRET` is undefined/empty and you use `Buffer.from("")`, you could accidentally match empty `Authorization` headers.
**Why it happens:** `timingSafeEqual(Buffer.from(""), Buffer.from(""))` returns `true`.
**How to avoid:** Check `if (!secret)` before any comparison logic — fail closed when secret is not configured.

### Pitfall 3: `.mcp.json` `${VAR}` Syntax Is Not Shell Expansion
**What goes wrong:** Developer assumes `.mcp.json` env values use shell syntax and tests with `$VAR` (no braces) — this is rejected by the MCP client.
**Why it happens:** The MCP spec uses `${VAR}` (with braces), not `$VAR`.
**How to avoid:** Always use `"${VAR_NAME}"` syntax in `.mcp.json` env blocks. The existing `DATABASE_URL` entry shows the correct pattern.

### Pitfall 4: `dailyCostTotal` Mock Placement
**What goes wrong:** Adding `dailyCostTotal` inside the wrong model nesting in `setup.ts` — the mock has deeply nested models.
**Why it happens:** `setup.ts` is a large flat object — easy to misplace a new model.
**How to avoid:** Add at top level of the `prisma` object, adjacent to `enrichmentLog`, `enrichmentJob`. Check the actual Prisma schema: `DailyCostTotal` is a top-level model.

### Pitfall 5: Pre-existing Test Failures Are Out of Scope
**What goes wrong:** Trying to fix the 9 failing tests in `api-routes.test.ts` and `resend-notifications.test.ts`.
**Why it happens:** These are runtime assertion failures (not TypeScript errors) caused by `request.nextUrl.searchParams` being undefined in the test mock (mocking `NextRequest` as `class extends Request {}` loses `.nextUrl`). These are pre-existing issues from before phase 1.
**How to avoid:** Phase 3.1 CONTEXT.md scopes TS fixes to test files and the single TS2322 error. The 9 runtime failures are separate and explicitly not in scope.

---

## Code Examples

Verified patterns from the existing codebase and Node.js stdlib:

### `crypto.timingSafeEqual` — Correct Usage Pattern
```typescript
// src/lib/cron-auth.ts
import { timingSafeEqual } from "crypto";

export function validateCronSecret(req: Request): boolean {
  const secret = process.env.CRON_SECRET;
  if (!secret) return false;  // fail closed — no secret = no access

  const authHeader = req.headers.get("authorization") ?? "";
  const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : "";

  if (!token) return false;

  try {
    const secretBuf = Buffer.from(secret);
    const tokenBuf = Buffer.from(token);
    if (secretBuf.length !== tokenBuf.length) return false;
    return timingSafeEqual(secretBuf, tokenBuf);
  } catch {
    return false;
  }
}
```

### Route Handler — Auth Check Placement
```typescript
// FIRST lines of POST handler, before all other logic:
if (!validateCronSecret(request)) {
  console.log(`[${new Date().toISOString()}] Unauthorized: POST /api/enrichment/run`);
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}
```

### Vitest Global Mock Type Fix
```typescript
// emailbison-client.test.ts line 76
// Before:
global.fetch = fetchMock;
// After:
global.fetch = fetchMock as unknown as typeof fetch;
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Vercel `x-vercel-cron` header validation | `Authorization: Bearer <CRON_SECRET>` | N/A — both are valid | `Bearer` is more general; works for both cron and manual trigger |
| `===` string comparison | `crypto.timingSafeEqual()` | Node 6.6.0 | Prevents timing oracle attacks on secrets |

**Deprecated/outdated:**
- Direct string comparison for secrets: Every modern security guide recommends `timingSafeEqual` for secret comparison in Node.js.

---

## Open Questions

1. **Should `validateCronSecret` accept `NextRequest` or `Request`?**
   - What we know: `POST /api/enrichment/run` uses `NextRequest` (has `.nextUrl`, etc.); `POST /api/enrichment/jobs/process` uses no request param at all (current signature is `async function POST()`).
   - What's unclear: The process route doesn't accept a request parameter — it needs to be updated to accept one to read headers, OR the auth check can be placed differently.
   - Recommendation: Update the `POST()` signature in `jobs/process/route.ts` to `POST(request: NextRequest)` to match standard Next.js pattern — this is a one-word change and enables the same auth pattern. Accept `Request` (not `NextRequest`) in the helper since that's the minimal interface needed (just `.headers.get()`).

2. **Will `CRON_SECRET` be set in Vercel production env?**
   - What we know: The env var is read from `process.env.CRON_SECRET` — it must be set on Vercel before these routes are protected.
   - What's unclear: Whether it's already set in the Vercel project.
   - Recommendation: Document in the plan that the implementer must also add `CRON_SECRET` to Vercel env vars via `printf` + `vercel env add`. This is an operational step, not a code step.

---

## Sources

### Primary (HIGH confidence)
- Node.js official docs — `crypto.timingSafeEqual` — https://nodejs.org/api/crypto.html#cryptotimingsafeequala-b
- Direct code inspection of `/Users/jjay/programs/outsignal-agents/src/app/api/enrichment/run/route.ts` — confirmed no auth
- Direct code inspection of `/Users/jjay/programs/outsignal-agents/src/app/api/enrichment/jobs/process/route.ts` — confirmed no auth, confirmed signature is `POST()` (no request param)
- Direct code inspection of `/Users/jjay/programs/outsignal-agents/.mcp.json` — confirmed only `DATABASE_URL` forwarded
- Direct code inspection of `/Users/jjay/programs/outsignal-agents/src/__tests__/setup.ts` — confirmed `dailyCostTotal` absent
- `tsc --noEmit` output — confirmed single TS error in test files: `emailbison-client.test.ts:76 TS2322`
- `vitest run` output — confirmed 9 failing tests are runtime assertion failures (not TS errors), pre-existing, out of scope
- Direct code inspection of `queue.ts` lines 113-132 — DAILY_CAP_HIT path confirmed
- `v1.0-MILESTONE-AUDIT.md` — INT-01 gap description confirmed

### Secondary (MEDIUM confidence)
- `@ai-sdk/anthropic` usage found at `src/lib/agents/runner.ts`, `src/lib/icp/scorer.ts`, `src/lib/normalizer/job-title.ts` — confirms `ANTHROPIC_API_KEY` needed by MCP server

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — Node built-ins, no external dependencies, all verified in codebase
- Architecture: HIGH — patterns derived from direct code inspection of existing project files
- Pitfalls: HIGH — `timingSafeEqual` length requirement is documented in Node.js official docs; other pitfalls observed from code

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (stable — Node crypto API, `.mcp.json` format, vitest mock patterns are all stable)
