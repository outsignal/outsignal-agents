---
phase: 01-enrichment-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/enrichment/queue.ts
  - src/app/api/enrichment/jobs/process/route.ts
  - src/__tests__/enrichment-queue.test.ts
autonomous: true
requirements: [ENRICH-07]
must_haves:
  truths:
    - "enqueueJob creates an EnrichmentJob row with status 'pending' and JSON-serialized entity IDs"
    - "processNextChunk picks up the oldest pending job, processes one chunk, and updates progress"
    - "A job transitions from pending -> running -> pending (more chunks) -> complete when all chunks processed"
    - "A job with no remaining chunks transitions to 'complete' status"
    - "The /api/enrichment/jobs/process POST endpoint returns job progress as JSON"
  artifacts:
    - path: "src/lib/enrichment/queue.ts"
      provides: "enqueueJob and processNextChunk functions"
      exports: ["enqueueJob", "processNextChunk"]
    - path: "src/app/api/enrichment/jobs/process/route.ts"
      provides: "POST handler for processing next job chunk"
      exports: ["POST"]
    - path: "src/__tests__/enrichment-queue.test.ts"
      provides: "Unit tests for queue logic"
      min_lines: 50
  key_links:
    - from: "src/lib/enrichment/queue.ts"
      to: "prisma.enrichmentJob"
      via: "create for enqueue, findFirst+update for process"
      pattern: "prisma\\.enrichmentJob\\.(create|findFirst|update)"
    - from: "src/app/api/enrichment/jobs/process/route.ts"
      to: "src/lib/enrichment/queue.ts"
      via: "imports processNextChunk"
      pattern: "import.*processNextChunk.*from.*queue"
---

<objective>
Build the async job queue for batch enrichment — a DB-backed queue that processes entity IDs in chunks to avoid Vercel's 30-second timeout.

Purpose: Batch operations (enriching 100+ records) cannot run in a single request. The queue stores work as `EnrichmentJob` rows, and a process endpoint picks up one chunk at a time. This supports Vercel Cron, manual trigger from admin UI, or any HTTP client calling POST repeatedly until the job is complete (ENRICH-07).

Output: Queue library module, API route handler, and unit tests.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-enrichment-foundation/01-RESEARCH.md
@.planning/phases/01-enrichment-foundation/01-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 — types and database models this plan depends on. -->

From src/lib/enrichment/types.ts (created in Plan 01):
```typescript
export type Provider = "prospeo" | "aiark" | "leadmagic" | "findymail" | "firecrawl" | "clay" | "ai-normalizer";
export type EntityType = "person" | "company";
export type EnrichmentStatus = "success" | "error" | "skipped";
```

From prisma/schema.prisma (created in Plan 01):
```prisma
model EnrichmentJob {
  id             String   @id @default(cuid())
  entityType     String   // "person" | "company"
  provider       String   // provider to run
  status         String   @default("pending") // "pending" | "running" | "complete" | "failed"
  totalCount     Int
  processedCount Int      @default(0)
  chunkSize      Int      @default(50)
  entityIds      String   // JSON array of entity IDs to process
  errorLog       String?  // JSON array of { entityId, error } for failures
  workspaceSlug  String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  @@index([status])
}
```

From src/lib/db.ts:
```typescript
export const prisma = globalForPrisma.prisma || new PrismaClient();
```

From test setup (src/__tests__/setup.ts — updated in Plan 01):
```typescript
enrichmentJob: {
  findFirst: vi.fn(),
  create: vi.fn(),
  update: vi.fn(),
  findMany: vi.fn(),
},
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Queue library — enqueueJob and processNextChunk</name>
  <files>src/lib/enrichment/queue.ts</files>
  <action>
Create `src/lib/enrichment/queue.ts`:

```typescript
/**
 * DB-backed async job queue for batch enrichment.
 * Jobs are processed in chunks to stay within Vercel's 30-second timeout.
 *
 * Usage:
 *   const jobId = await enqueueJob({ entityType: "person", provider: "prospeo", entityIds: [...] });
 *   // Then call processNextChunk() repeatedly (via cron or manual trigger) until complete
 */
import { prisma } from "@/lib/db";
import type { EntityType, Provider } from "./types";

export interface EnqueueJobParams {
  entityType: EntityType;
  provider: Provider;
  entityIds: string[];
  chunkSize?: number;
  workspaceSlug?: string;
}

export interface ChunkResult {
  jobId: string;
  processed: number;
  total: number;
  done: boolean;
  status: string;
}

/**
 * Create a new enrichment job. Returns the job ID.
 * The job starts in "pending" status and will be picked up by processNextChunk.
 */
export async function enqueueJob(params: EnqueueJobParams): Promise<string> {
  const { entityType, provider, entityIds, chunkSize = 50, workspaceSlug } = params;

  if (entityIds.length === 0) {
    throw new Error("Cannot enqueue job with empty entityIds");
  }

  const job = await prisma.enrichmentJob.create({
    data: {
      entityType,
      provider,
      status: "pending",
      totalCount: entityIds.length,
      processedCount: 0,
      chunkSize,
      entityIds: JSON.stringify(entityIds),
      workspaceSlug: workspaceSlug ?? null,
    },
  });

  return job.id;
}

/**
 * Pick up the oldest pending job and process its next chunk.
 * Returns null if no pending jobs exist.
 *
 * The actual enrichment logic is a no-op in Phase 1 — the chunk processor
 * just increments processedCount. Phase 2 will wire in provider adapters
 * via the onProcess callback.
 *
 * @param onProcess - Optional callback to process each entity ID in the chunk.
 *   If not provided, the chunk is marked as processed without doing any work.
 *   This allows Phase 1 to test the queue mechanics independently of provider logic.
 */
export async function processNextChunk(
  onProcess?: (entityId: string, job: { entityType: string; provider: string }) => Promise<void>,
): Promise<ChunkResult | null> {
  // Pick up the oldest pending job
  const job = await prisma.enrichmentJob.findFirst({
    where: { status: "pending" },
    orderBy: { createdAt: "asc" },
  });

  if (!job) return null;

  // Mark as running (prevents other workers from picking it up)
  await prisma.enrichmentJob.update({
    where: { id: job.id },
    data: { status: "running" },
  });

  try {
    // Parse entity IDs and slice the next chunk
    const allIds: string[] = JSON.parse(job.entityIds);
    const chunkStart = job.processedCount;
    const chunk = allIds.slice(chunkStart, chunkStart + job.chunkSize);

    // Process each entity in the chunk
    const errors: Array<{ entityId: string; error: string }> = [];

    for (const entityId of chunk) {
      if (onProcess) {
        try {
          await onProcess(entityId, {
            entityType: job.entityType,
            provider: job.provider,
          });
        } catch (err) {
          errors.push({
            entityId,
            error: err instanceof Error ? err.message : String(err),
          });
        }
      }
    }

    // Update progress
    const newProcessedCount = chunkStart + chunk.length;
    const done = newProcessedCount >= job.totalCount;

    // Merge errors into existing error log
    let existingErrors: Array<{ entityId: string; error: string }> = [];
    if (job.errorLog) {
      try {
        existingErrors = JSON.parse(job.errorLog);
      } catch {
        // ignore malformed errorLog
      }
    }
    const allErrors = [...existingErrors, ...errors];

    await prisma.enrichmentJob.update({
      where: { id: job.id },
      data: {
        processedCount: newProcessedCount,
        status: done ? "complete" : "pending",
        errorLog: allErrors.length > 0 ? JSON.stringify(allErrors) : null,
      },
    });

    return {
      jobId: job.id,
      processed: chunk.length,
      total: job.totalCount,
      done,
      status: done ? "complete" : "pending",
    };
  } catch (error) {
    // If chunk processing fails entirely, mark job as failed
    await prisma.enrichmentJob.update({
      where: { id: job.id },
      data: {
        status: "failed",
        errorLog: JSON.stringify([
          { entityId: "system", error: error instanceof Error ? error.message : String(error) },
        ]),
      },
    });

    throw error;
  }
}
```

Key design decisions:
- `onProcess` callback makes the queue testable without actual provider logic (Phase 1 = no-op; Phase 2 wires in providers)
- Failed individual entities are logged in errorLog but don't fail the whole job
- Catastrophic errors (JSON parse failure, DB error) mark the entire job as "failed"
- Job goes back to "pending" after each chunk so it gets picked up again
- Errors from previous chunks are preserved via merge with existing errorLog
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit --pretty 2>&1 | head -20</automated>
  </verify>
  <done>queue.ts exports enqueueJob and processNextChunk. TypeScript compiles cleanly. Functions handle the full lifecycle: pending -> running -> pending (more chunks) -> complete.</done>
</task>

<task type="auto">
  <name>Task 2: Process API route and unit tests</name>
  <files>src/app/api/enrichment/jobs/process/route.ts, src/__tests__/enrichment-queue.test.ts</files>
  <action>
1. Create the directory structure and route handler at `src/app/api/enrichment/jobs/process/route.ts`:

```typescript
/**
 * POST /api/enrichment/jobs/process
 *
 * Picks up the next pending enrichment job and processes one chunk.
 * Call repeatedly (via Vercel Cron or manual trigger) until all jobs are complete.
 *
 * Response:
 *   - 200 { jobId, processed, total, done, status } — chunk processed
 *   - 200 { message: "no pending jobs" } — nothing to do
 *   - 500 { error: string } — processing failed
 */
import { NextResponse } from "next/server";
import { processNextChunk } from "@/lib/enrichment/queue";

export async function POST() {
  try {
    const result = await processNextChunk();

    if (!result) {
      return NextResponse.json({ message: "no pending jobs" });
    }

    return NextResponse.json(result);
  } catch (error) {
    console.error("Job processing error:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Job processing failed" },
      { status: 500 },
    );
  }
}
```

2. Create `src/__tests__/enrichment-queue.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { prisma } from "@/lib/db";
import { enqueueJob, processNextChunk } from "@/lib/enrichment/queue";

describe("enqueueJob", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("creates a pending job with serialized entity IDs", async () => {
    (prisma.enrichmentJob.create as ReturnType<typeof vi.fn>).mockResolvedValue({
      id: "job-1",
    });

    const id = await enqueueJob({
      entityType: "person",
      provider: "prospeo",
      entityIds: ["p1", "p2", "p3"],
      chunkSize: 2,
    });

    expect(id).toBe("job-1");
    expect(prisma.enrichmentJob.create).toHaveBeenCalledWith({
      data: {
        entityType: "person",
        provider: "prospeo",
        status: "pending",
        totalCount: 3,
        processedCount: 0,
        chunkSize: 2,
        entityIds: JSON.stringify(["p1", "p2", "p3"]),
        workspaceSlug: null,
      },
    });
  });

  it("throws on empty entityIds", async () => {
    await expect(
      enqueueJob({
        entityType: "person",
        provider: "prospeo",
        entityIds: [],
      }),
    ).rejects.toThrow("Cannot enqueue job with empty entityIds");
  });

  it("uses default chunkSize of 50", async () => {
    (prisma.enrichmentJob.create as ReturnType<typeof vi.fn>).mockResolvedValue({
      id: "job-2",
    });

    await enqueueJob({
      entityType: "company",
      provider: "firecrawl",
      entityIds: ["c1"],
    });

    expect(prisma.enrichmentJob.create).toHaveBeenCalledWith({
      data: expect.objectContaining({ chunkSize: 50 }),
    });
  });
});

describe("processNextChunk", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("returns null when no pending jobs exist", async () => {
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(null);
    const result = await processNextChunk();
    expect(result).toBeNull();
  });

  it("processes a chunk and transitions to complete when done", async () => {
    const mockJob = {
      id: "job-1",
      entityType: "person",
      provider: "prospeo",
      status: "pending",
      totalCount: 2,
      processedCount: 0,
      chunkSize: 50,
      entityIds: JSON.stringify(["p1", "p2"]),
      errorLog: null,
    };
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
    (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

    const result = await processNextChunk();

    expect(result).toEqual({
      jobId: "job-1",
      processed: 2,
      total: 2,
      done: true,
      status: "complete",
    });

    // First update: status -> running
    expect(prisma.enrichmentJob.update).toHaveBeenNthCalledWith(1, {
      where: { id: "job-1" },
      data: { status: "running" },
    });

    // Second update: processedCount + status -> complete
    expect(prisma.enrichmentJob.update).toHaveBeenNthCalledWith(2, {
      where: { id: "job-1" },
      data: {
        processedCount: 2,
        status: "complete",
        errorLog: null,
      },
    });
  });

  it("processes a partial chunk and returns to pending", async () => {
    const mockJob = {
      id: "job-2",
      entityType: "person",
      provider: "leadmagic",
      status: "pending",
      totalCount: 5,
      processedCount: 0,
      chunkSize: 2,
      entityIds: JSON.stringify(["p1", "p2", "p3", "p4", "p5"]),
      errorLog: null,
    };
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
    (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

    const result = await processNextChunk();

    expect(result).toEqual({
      jobId: "job-2",
      processed: 2,
      total: 5,
      done: false,
      status: "pending",
    });
  });

  it("calls onProcess callback for each entity in chunk", async () => {
    const mockJob = {
      id: "job-3",
      entityType: "company",
      provider: "firecrawl",
      status: "pending",
      totalCount: 2,
      processedCount: 0,
      chunkSize: 50,
      entityIds: JSON.stringify(["c1", "c2"]),
      errorLog: null,
    };
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
    (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

    const onProcess = vi.fn().mockResolvedValue(undefined);
    await processNextChunk(onProcess);

    expect(onProcess).toHaveBeenCalledTimes(2);
    expect(onProcess).toHaveBeenCalledWith("c1", { entityType: "company", provider: "firecrawl" });
    expect(onProcess).toHaveBeenCalledWith("c2", { entityType: "company", provider: "firecrawl" });
  });

  it("records individual entity errors without failing the job", async () => {
    const mockJob = {
      id: "job-4",
      entityType: "person",
      provider: "prospeo",
      status: "pending",
      totalCount: 2,
      processedCount: 0,
      chunkSize: 50,
      entityIds: JSON.stringify(["p1", "p2"]),
      errorLog: null,
    };
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
    (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

    const onProcess = vi.fn()
      .mockResolvedValueOnce(undefined)
      .mockRejectedValueOnce(new Error("API 404"));

    const result = await processNextChunk(onProcess);

    expect(result!.done).toBe(true);
    // Second update should include error log
    expect(prisma.enrichmentJob.update).toHaveBeenNthCalledWith(2, {
      where: { id: "job-4" },
      data: expect.objectContaining({
        errorLog: JSON.stringify([{ entityId: "p2", error: "API 404" }]),
      }),
    });
  });

  it("resumes from processedCount offset on subsequent chunks", async () => {
    const mockJob = {
      id: "job-5",
      entityType: "person",
      provider: "prospeo",
      status: "pending",
      totalCount: 4,
      processedCount: 2, // Already processed first 2
      chunkSize: 2,
      entityIds: JSON.stringify(["p1", "p2", "p3", "p4"]),
      errorLog: null,
    };
    (prisma.enrichmentJob.findFirst as ReturnType<typeof vi.fn>).mockResolvedValue(mockJob);
    (prisma.enrichmentJob.update as ReturnType<typeof vi.fn>).mockResolvedValue({});

    const onProcess = vi.fn().mockResolvedValue(undefined);
    const result = await processNextChunk(onProcess);

    // Should process p3 and p4 (offset from processedCount)
    expect(onProcess).toHaveBeenCalledTimes(2);
    expect(onProcess).toHaveBeenCalledWith("p3", expect.anything());
    expect(onProcess).toHaveBeenCalledWith("p4", expect.anything());
    expect(result!.done).toBe(true);
  });
});
```

IMPORTANT: Follow existing test patterns — `vi.clearAllMocks()` in `beforeEach`, cast mock fns with `as ReturnType<typeof vi.fn>`. Tests do NOT call the API route directly — they test the queue library functions. The route handler is a thin wrapper around `processNextChunk()`.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx vitest run src/__tests__/enrichment-queue.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>All queue tests pass. enqueueJob creates pending jobs with serialized IDs. processNextChunk handles full lifecycle: no jobs (returns null), partial chunk (back to pending), complete chunk (done), error handling (errors logged per entity), and offset resume. API route exists at /api/enrichment/jobs/process.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run src/__tests__/enrichment-queue.test.ts` — all tests pass
3. `src/lib/enrichment/queue.ts` exports enqueueJob and processNextChunk
4. `src/app/api/enrichment/jobs/process/route.ts` exports POST handler
5. Job lifecycle works: enqueue -> process chunk -> repeat -> complete
6. Individual entity errors are captured in errorLog without failing the job
</verification>

<success_criteria>
- enqueueJob creates a pending job with JSON-serialized entity IDs and configurable chunk size
- processNextChunk picks the oldest pending job, processes one chunk, and updates progress
- Jobs transition through pending -> running -> pending -> complete lifecycle
- Individual entity processing errors are logged but don't fail the overall job
- POST /api/enrichment/jobs/process endpoint wraps processNextChunk
- All unit tests pass
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-enrichment-foundation/01-03-SUMMARY.md`
</output>
