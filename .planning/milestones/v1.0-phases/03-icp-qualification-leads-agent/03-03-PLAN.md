---
phase: 03-icp-qualification-leads-agent
plan: 03
type: execute
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - src/mcp/leads-agent/index.ts
  - src/mcp/leads-agent/tools/search.ts
  - src/mcp/leads-agent/tools/enrich.ts
  - src/mcp/leads-agent/tools/score.ts
  - src/mcp/leads-agent/tools/lists.ts
  - src/mcp/leads-agent/tools/export.ts
  - src/mcp/leads-agent/tools/status.ts
  - src/mcp/leads-agent/tools/workspace.ts
autonomous: true
requirements: [AI-04, AI-05, ENRICH-05]

must_haves:
  truths:
    - "search_people tool accepts query + optional workspace filter and returns paginated results as markdown table"
    - "enrich_person tool triggers the enrichment waterfall for a person and returns enrichment results"
    - "score_person tool runs ICP scoring for a person in a workspace and returns score/reasoning/confidence"
    - "batch_score_list tool scores all unscored people in a workspace and reports progress"
    - "create_list, add_to_list, view_list tools manage named workspace-scoped lists using PersonWorkspace.tags"
    - "export_to_emailbison tool verifies all emails before export and blocks on any non-valid email"
    - "update_lead_status tool changes a person's status (interested, replied, bounced, etc.)"
    - "set_workspace_prompt and get_workspace_prompts tools manage the three AI prompt override fields"
    - "enrich_person and score_person confirm before executing (return cost estimate + confirmation prompt)"
  artifacts:
    - path: "src/mcp/leads-agent/index.ts"
      provides: "MCP server with all tools registered"
      min_lines: 30
    - path: "src/mcp/leads-agent/tools/search.ts"
      provides: "search_people tool"
      exports: ["registerSearchTools"]
    - path: "src/mcp/leads-agent/tools/enrich.ts"
      provides: "enrich_person tool"
      exports: ["registerEnrichTools"]
    - path: "src/mcp/leads-agent/tools/score.ts"
      provides: "score_person + batch_score_list tools"
      exports: ["registerScoreTools"]
    - path: "src/mcp/leads-agent/tools/lists.ts"
      provides: "create_list, add_to_list, view_list tools"
      exports: ["registerListTools"]
    - path: "src/mcp/leads-agent/tools/export.ts"
      provides: "export_to_emailbison tool with verification gate"
      exports: ["registerExportTools"]
    - path: "src/mcp/leads-agent/tools/status.ts"
      provides: "update_lead_status tool"
      exports: ["registerStatusTools"]
    - path: "src/mcp/leads-agent/tools/workspace.ts"
      provides: "set_workspace_prompt + get_workspace_prompts tools"
      exports: ["registerWorkspaceTools"]
  key_links:
    - from: "src/mcp/leads-agent/index.ts"
      to: "src/mcp/leads-agent/tools/*.ts"
      via: "register*Tools(server) calls"
      pattern: "register.*Tools"
    - from: "src/mcp/leads-agent/tools/score.ts"
      to: "src/lib/icp/scorer.ts"
      via: "scorePersonIcp import"
      pattern: "scorePersonIcp"
    - from: "src/mcp/leads-agent/tools/export.ts"
      to: "src/lib/verification/leadmagic.ts"
      via: "verifyEmail + getVerificationStatus imports"
      pattern: "verifyEmail|getVerificationStatus"
    - from: "src/mcp/leads-agent/tools/enrich.ts"
      to: "src/lib/enrichment/waterfall.ts"
      via: "enrichEmail + enrichCompany imports"
      pattern: "enrichEmail|enrichCompany"
---

<objective>
Wire all MCP tools into the Leads Agent server — search, enrich, score, list management, export, status updates, and workspace prompt configuration.

Purpose: This is the user-facing surface of Phase 3. The MCP tools expose all pipeline capabilities to Claude Code, allowing the project owner to manage leads, score prospects, build lists, and export to EmailBison via natural language commands. Each tool module registers its tools on the shared McpServer instance.

Output: Fully functional MCP server with all 6 capabilities (plus workspace prompt management) accessible from Claude Code.
</objective>

<execution_context>
@/Users/jjay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jjay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-icp-qualification-leads-agent/03-CONTEXT.md
@.planning/phases/03-icp-qualification-leads-agent/03-RESEARCH.md
@.planning/phases/03-icp-qualification-leads-agent/03-01-SUMMARY.md
@.planning/phases/03-icp-qualification-leads-agent/03-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/mcp/leads-agent/index.ts (created in 03-01):
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
const server = new McpServer({ name: "outsignal-leads", version: "1.0.0" });
// Tools registered via: server.tool("name", "description", zodSchema, handler)
// Handler returns: { content: [{ type: "text", text: "..." }] }
```

From src/lib/icp/scorer.ts (created in 03-02):
```typescript
export interface IcpScoreResult {
  score: number;       // 0-100
  reasoning: string;
  confidence: "high" | "medium" | "low";
}
export async function scorePersonIcp(personId: string, workspaceSlug: string, forceRecrawl?: boolean): Promise<IcpScoreResult>;
```

From src/lib/icp/crawl-cache.ts (created in 03-02):
```typescript
export async function getCrawlMarkdown(domain: string, forceRecrawl?: boolean): Promise<string | null>;
```

From src/lib/verification/leadmagic.ts (created in 03-02):
```typescript
export interface VerificationResult {
  email: string;
  status: "valid" | "invalid" | "valid_catch_all" | "catch_all" | "unknown";
  isExportable: boolean;
  costUsd: number;
}
export async function verifyEmail(email: string, personId?: string): Promise<VerificationResult>;
export async function getVerificationStatus(personId: string): Promise<{ status: string; isExportable: boolean } | null>;
```

From src/lib/enrichment/waterfall.ts:
```typescript
export async function enrichEmail(personId: string, input: EmailAdapterInput, breaker: CircuitBreaker, workspaceSlug?: string): Promise<void>;
export async function enrichCompany(domain: string, breaker: CircuitBreaker, workspaceSlug?: string): Promise<void>;
export function createCircuitBreaker(): CircuitBreaker;
```

From src/lib/enrichment/types.ts:
```typescript
export interface EmailAdapterInput {
  linkedinUrl?: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  companyDomain?: string;
}
```

Prisma models (Person, PersonWorkspace, Workspace, Company):
```prisma
model Person {
  id email firstName lastName company companyDomain jobTitle phone linkedinUrl location vertical source status enrichmentData
  workspaces PersonWorkspace[]
}
model PersonWorkspace {
  id personId workspace sourceId status vertical tags icpScore icpReasoning icpConfidence icpScoredAt
  @@unique([personId, workspace])
}
model Workspace {
  id slug name vertical icpCriteriaPrompt normalizationPrompt outreachTonePrompt
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search + enrich + score MCP tools</name>
  <files>
    src/mcp/leads-agent/tools/search.ts
    src/mcp/leads-agent/tools/enrich.ts
    src/mcp/leads-agent/tools/score.ts
  </files>
  <action>
Each tool module exports a `register*Tools(server: McpServer)` function that registers tools on the server. All modules import `prisma` from `@/lib/db` and `z` from `zod`.

**CRITICAL:** No `console.log` anywhere — the MCP server runs over stdio. Use `console.error` only.

**Pattern for all tool modules:**
```typescript
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { prisma } from "@/lib/db";

export function registerSearchTools(server: McpServer): void {
  server.tool("tool_name", "description", { /* zod schema */ }, async (params) => {
    // ... implementation ...
    return { content: [{ type: "text" as const, text: result }] };
  });
}
```

**1. `src/mcp/leads-agent/tools/search.ts` — `registerSearchTools`:**

Register `search_people`:
- Schema: `{ query: z.string(), workspace: z.string().optional(), vertical: z.string().optional(), status: z.string().optional(), limit: z.number().default(25), offset: z.number().default(0) }`
- Description: "Search people by name, email, company, or job title. Returns paginated table with enrichment status."
- Implementation:
  - Build Prisma `where` clause with `OR` across `email`, `firstName`, `lastName`, `company`, `jobTitle` using `contains` + `mode: "insensitive"`
  - If `workspace` provided, add `workspaces: { some: { workspace } }` filter
  - If `vertical` provided, add `vertical` filter
  - If `status` provided, add `status` filter
  - Use `prisma.$transaction` to get both `findMany` (with `take: limit, skip: offset, orderBy: { updatedAt: "desc" }`) and `count`
  - Format results as a markdown table with columns: Name | Email | Company | Title | Status | Vertical
  - Return `"{total} results (showing {offset+1}-{offset+results.length})\n\n{table}"`

Helper function `formatPeopleTable(people)` to format as markdown table.

**2. `src/mcp/leads-agent/tools/enrich.ts` — `registerEnrichTools`:**

Register `enrich_person`:
- Schema: `{ person_id: z.string().describe("Person ID to enrich"), workspace: z.string().optional().describe("Workspace slug for cost tracking"), confirm: z.boolean().default(false).describe("Set to true to proceed with enrichment. First call without confirm to see cost estimate.") }`
- Description: "Trigger the enrichment waterfall for a person (AI Ark → Prospeo → LeadMagic → FindyMail for email; AI Ark → Firecrawl for company). Call first without confirm=true to see what will happen."
- Implementation:
  - Fetch person by ID: `prisma.person.findUniqueOrThrow({ where: { id: person_id } })`
  - If `confirm` is false:
    - Check what enrichment has already been done (query EnrichmentLog for this person)
    - Return a summary: "Person: {name} ({email})\nExisting enrichments: {list}\nMissing: {what waterfall would do}\n\nEstimated cost: ~$0.01-0.05\nSet confirm=true to proceed."
  - If `confirm` is true:
    - Create a circuit breaker: `createCircuitBreaker()`
    - Build `EmailAdapterInput` from person fields
    - Run `enrichEmail(personId, input, breaker, workspace)`
    - If `person.companyDomain`, also run `enrichCompany(person.companyDomain, breaker, workspace)`
    - Re-fetch person after enrichment to show updated data
    - Return enrichment results as formatted text

**3. `src/mcp/leads-agent/tools/score.ts` — `registerScoreTools`:**

Register `score_person`:
- Schema: `{ person_id: z.string(), workspace: z.string(), force_recrawl: z.boolean().default(false).describe("Force re-crawl of company website") }`
- Description: "Score a person's ICP fit for a workspace (0-100). Requires workspace to have icpCriteriaPrompt configured."
- Implementation:
  - Call `scorePersonIcp(person_id, workspace, force_recrawl)` from `@/lib/icp/scorer`
  - Return formatted result: "ICP Score: {score}/100\nConfidence: {confidence}\nReasoning: {reasoning}"

Register `batch_score_list`:
- Schema: `{ workspace: z.string(), limit: z.number().default(50).describe("Max people to score in this batch"), confirm: z.boolean().default(false) }`
- Description: "Score all unscored people in a workspace. Call without confirm to see count. Set confirm=true to proceed."
- Implementation:
  - Find PersonWorkspace records where `workspace` matches AND `icpScore` is null, joined with Person
  - If `confirm` is false: Return "Found {count} unscored people in workspace '{workspace}'. Set confirm=true to score up to {limit}."
  - If `confirm` is true:
    - Loop through people (up to `limit`), calling `scorePersonIcp` for each
    - Track successes and failures
    - Return summary: "Scored {success}/{total}. Failures: {failure count}. Average score: {avg}."
    - Use try/catch per person — don't let one failure stop the batch
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/mcp/leads-agent/tools/search.ts src/mcp/leads-agent/tools/enrich.ts src/mcp/leads-agent/tools/score.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - search_people tool searches across name, email, company, job title with pagination and workspace/vertical/status filters
    - enrich_person tool requires confirm=true before running enrichment (shows cost estimate first)
    - score_person tool calls scorePersonIcp and returns formatted score
    - batch_score_list tool scores unscored people in batch with confirm gate
    - All tools return { content: [{ type: "text", text }] } format
    - No console.log calls anywhere
  </done>
</task>

<task type="auto">
  <name>Task 2: List + export + status + workspace tools + wire into index.ts</name>
  <files>
    src/mcp/leads-agent/tools/lists.ts
    src/mcp/leads-agent/tools/export.ts
    src/mcp/leads-agent/tools/status.ts
    src/mcp/leads-agent/tools/workspace.ts
    src/mcp/leads-agent/index.ts
  </files>
  <action>
**1. `src/mcp/leads-agent/tools/lists.ts` — `registerListTools`:**

Lists are stored using `PersonWorkspace.tags` as a JSON string array. Each tag is a list name. A person can be in multiple lists within a workspace.

Register `create_list`:
- Schema: `{ name: z.string(), workspace: z.string() }`
- Description: "Create a named list in a workspace. Lists are tags on PersonWorkspace records."
- Implementation: Just validates the workspace exists and returns confirmation. Lists are implicit — they exist when at least one person has the tag.
- Return: "List '{name}' ready in workspace '{workspace}'. Use add_to_list to add people."

Register `add_to_list`:
- Schema: `{ list_name: z.string(), person_ids: z.array(z.string()), workspace: z.string() }`
- Description: "Add people to a named list in a workspace."
- Implementation:
  - For each person_id, find their PersonWorkspace record for this workspace
  - Parse existing `tags` JSON array (or start with empty array)
  - Add `list_name` if not already present
  - Update `tags` with new JSON array
  - Return: "Added {count} people to list '{list_name}'."

Register `view_list`:
- Schema: `{ list_name: z.string(), workspace: z.string(), limit: z.number().default(50) }`
- Description: "View people in a named list with their enrichment status and ICP score."
- Implementation:
  - Query PersonWorkspace where `workspace` matches AND `tags` contains the list name (use Prisma `contains` on the JSON string field — match `"list_name"` within the tags string)
  - Join with Person to get name, email, company, status
  - Format as markdown table: Name | Email | Company | ICP Score | Status
  - Return: "{count} people in list '{list_name}':\n\n{table}"

**2. `src/mcp/leads-agent/tools/export.ts` — `registerExportTools`:**

Register `export_to_emailbison`:
- Schema: `{ list_name: z.string(), workspace: z.string(), campaign_id: z.string().optional().describe("EmailBison campaign ID (if known)"), confirm: z.boolean().default(false) }`
- Description: "Export a list to EmailBison. Verifies ALL emails first — blocks if any email is not 'valid'. Call without confirm to see pre-export summary."
- Implementation:
  - Find all people in the list (same query as view_list)
  - If `confirm` is false:
    - For each person, check `getVerificationStatus(personId)`:
      - If null (never verified): count as "needs verification"
      - If status is "valid": count as "ready"
      - If status is anything else: count as "blocked"
    - Return summary: "List '{list_name}': {total} people\n- Ready (verified): {ready}\n- Needs verification: {needs}\n- Blocked (invalid/catch-all): {blocked}\n\nEstimated verification cost: ~${needs * 0.05}\nSet confirm=true to verify and export."
  - If `confirm` is true:
    - Verify all unverified emails by calling `verifyEmail(email, personId)` for each
    - After verification, check results:
      - If ANY person has a non-valid status → BLOCK export. Return: "Export blocked: {count} emails are not valid.\n{list of blocked emails with status}\n\nRemove blocked people from the list or re-verify."
      - If ALL valid → proceed with export
    - For the actual EmailBison push: Return a formatted summary of what would be exported (the actual EmailBison API integration is Phase 5 — for now, return the verified list as structured data that can be manually pushed). Include: "All {total} emails verified as valid. EmailBison push endpoint integration coming in Phase 5. Export data:\n{formatted CSV-like output with name, email, company, title, etc.}"

**3. `src/mcp/leads-agent/tools/status.ts` — `registerStatusTools`:**

Register `update_lead_status`:
- Schema: `{ person_id: z.string(), status: z.enum(["new", "contacted", "replied", "interested", "bounced", "unsubscribed"]), workspace: z.string().optional().describe("Also update status on PersonWorkspace if provided") }`
- Description: "Update a person's status (new, contacted, replied, interested, bounced, unsubscribed)."
- Implementation:
  - Update `prisma.person.update({ where: { id: person_id }, data: { status } })`
  - If `workspace` provided, also update `prisma.personWorkspace.updateMany({ where: { personId: person_id, workspace }, data: { status } })`
  - Return: "Updated {person name/email} status to '{status}'."

**4. `src/mcp/leads-agent/tools/workspace.ts` — `registerWorkspaceTools`:**

Register `set_workspace_prompt`:
- Schema: `{ workspace: z.string(), prompt_type: z.enum(["icp_criteria", "normalization", "outreach_tone"]), prompt_text: z.string() }`
- Description: "Set an AI prompt override for a workspace. Types: icp_criteria (ICP scoring criteria), normalization (field normalization rules), outreach_tone (email writing tone)."
- Implementation:
  - Map prompt_type to column name: `icp_criteria` → `icpCriteriaPrompt`, `normalization` → `normalizationPrompt`, `outreach_tone` → `outreachTonePrompt`
  - `prisma.workspace.update({ where: { slug: workspace }, data: { [columnName]: prompt_text } })`
  - Return: "Updated {prompt_type} prompt for workspace '{workspace}'.\n\nCurrent prompt:\n{prompt_text}"

Register `get_workspace_prompts`:
- Schema: `{ workspace: z.string() }`
- Description: "View all AI prompt overrides configured for a workspace."
- Implementation:
  - `prisma.workspace.findUniqueOrThrow({ where: { slug: workspace } })`
  - Return formatted text showing all three prompts (or "Not set" for null ones)

**5. Update `src/mcp/leads-agent/index.ts`:**

Replace the placeholder ping tool with proper tool registration:

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { registerSearchTools } from "./tools/search.js";
import { registerEnrichTools } from "./tools/enrich.js";
import { registerScoreTools } from "./tools/score.js";
import { registerListTools } from "./tools/lists.js";
import { registerExportTools } from "./tools/export.js";
import { registerStatusTools } from "./tools/status.js";
import { registerWorkspaceTools } from "./tools/workspace.js";

const server = new McpServer({ name: "outsignal-leads", version: "1.0.0" });

// Register all tool modules
registerSearchTools(server);
registerEnrichTools(server);
registerScoreTools(server);
registerListTools(server);
registerExportTools(server);
registerStatusTools(server);
registerWorkspaceTools(server);

// Connect transport
const transport = new StdioServerTransport();
await server.connect(transport);
console.error("[outsignal-leads] MCP server connected via stdio — all tools registered");
```

**IMPORTANT:** Import paths must use `.js` extension for ESM compatibility (tsx resolves `.js` → `.ts` at runtime). Example: `import { registerSearchTools } from "./tools/search.js"`.

**IMPORTANT:** The `@/lib/*` path alias may not resolve in the tsx-run MCP process since it's outside the Next.js build. If TypeScript path aliases don't work, the tool modules should use relative imports: `import { prisma } from "../../../lib/db"` etc. Test this during verification — if `@/` imports fail, switch to relative paths.
  </action>
  <verify>
    <automated>cd /Users/jjay/programs/outsignal-agents && npx tsc --noEmit src/mcp/leads-agent/index.ts 2>&1 | head -30 && timeout 5 npx tsx src/mcp/leads-agent/index.ts 2>&1 || true</automated>
  </verify>
  <done>
    - create_list, add_to_list, view_list tools manage lists via PersonWorkspace.tags JSON
    - export_to_emailbison verifies all emails via LeadMagic before allowing export; blocks on any non-valid email
    - update_lead_status changes person and optionally PersonWorkspace status
    - set_workspace_prompt and get_workspace_prompts manage the three AI prompt override fields on Workspace
    - index.ts imports and registers all tool modules
    - MCP server starts without crash and reports all tools registered
    - No console.log calls — only console.error for logging
    - Import paths resolve correctly (either @/ aliases or relative paths)
  </done>
</task>

</tasks>

<verification>
1. MCP server starts without crash: `timeout 5 npx tsx src/mcp/leads-agent/index.ts 2>&1`
2. TypeScript compiles: `npx tsc --noEmit` for all tool files
3. All tools registered — stderr output shows "all tools registered"
4. search_people uses case-insensitive search across multiple fields
5. enrich_person requires confirm=true before making API calls
6. export_to_emailbison blocks when any email is not "valid" status
7. Workspace prompts can be set and retrieved
8. No console.log calls in any MCP server file (grep confirms)
</verification>

<success_criteria>
- All 6 Leads Agent capabilities functional: enrich, search, list, export, score, status
- Workspace prompt management working (set + get)
- Confirmation gates on expensive operations (enrich, batch_score, export)
- Email verification hard gate on export (blocks non-valid)
- MCP server starts cleanly with all tools registered
- Tools return structured text responses suitable for Claude Code conversation
</success_criteria>

<output>
After completion, create `.planning/phases/03-icp-qualification-leads-agent/03-03-SUMMARY.md`
</output>
